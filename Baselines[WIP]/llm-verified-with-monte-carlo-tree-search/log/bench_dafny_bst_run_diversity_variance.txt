

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 15 --language Dafny --problem_name problem_bst --seed 42 --same_for_many_samples False 


[2024-01-13 02:58:32,912] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.

SCORE
1.0
['// (2) Define a predicate that checks whether a given tree is a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['function IsBST(t: Tree, lower: nat, upper: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)

   |
18 |   if t == Empty then Node(Empty, value, Empty)
   |                                               ^

ex.dfy(18,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else

   |
19 |   else
   |       ^

ex.dfy(19,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t

   |
20 |     match t
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>

   |
21 |     case Node(left, t_value, right) =>
   |                                       ^

ex.dfy(21,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)

   |
22 |       if value < t_value then Node(Insert(left, value), t_value, right)
   |                                                                        ^

ex.dfy(22,71): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < t_value then Node(Insert(left, value), t_value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))

   |
23 |       else if value > t_value then Node(left, t_value, Insert(right, value))
   |                                                                             ^

ex.dfy(23,76): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > t_value then Node(left, t_value, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t

   |
24 |       else t
   |             ^

ex.dfy(24,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Define a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false

   |
31 |   case Empty => false
   |                      ^

ex.dfy(31,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>

   |
32 |   case Node(left, t_value, right) =>
   |                                     ^

ex.dfy(32,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)

   |
33 |     if value < t_value then Contains(left, value)
   |                                                  ^

ex.dfy(33,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < t_value then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)

   |
34 |     else if value > t_value then Contains(right, value)
   |                                                        ^

ex.dfy(34,55): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > t_value then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true

   |
35 |     else true
   |              ^

ex.dfy(35,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
42 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.

   |
43 |   // Base case: if t is Empty, then the result of Insert is a Node containing value.
   |                                                                                     ^

ex.dfy(43,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
44 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(44,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
45 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(45,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.

   |
53 |   // Proof by structural induction on t, with lower and upper as induction hypotheses.
   |                                                                                       ^

ex.dfy(53,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, with lower and upper as induction hypotheses.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.

   |
55 |   // and the BST property holds because there are no other elements.
   |                                                                     ^

ex.dfy(55,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because there are no other elements.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,

   |
57 |   // or recursively calls Insert on left or right subtree. In either case,
   |                                                                           ^

ex.dfy(57,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In either case,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,
  // the BST property holds because of the induction hypotheses on left and right.

   |
58 |   // the BST property holds because of the induction hypotheses on left and right.
   |                                                                                   ^

ex.dfy(58,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the BST property holds because of the induction hypotheses on left and right.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as induction hypotheses.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In either case,
  // the BST property holds because of the induction hypotheses on left and right.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.

   |
53 |   // Proof by structural induction on t, with the bounds lower and upper.
   |                                                                          ^

ex.dfy(53,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, with the bounds lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.

   |
55 |   // which preserves the BST property within the bounds.
   |                                                         ^

ex.dfy(55,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property within the bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property

   |
57 |   // or recursively calls Insert on left or right subtree, which preserves the BST property
   |                                                                                            ^

ex.dfy(57,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree, which preserves the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property
  // within the updated bounds.

   |
58 |   // within the updated bounds.
   |                                ^

ex.dfy(58,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // within the updated bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with the bounds lower and upper.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, which preserves the BST property
  // within the updated bounds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
53 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(53,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
   |                                                                                                  ^

ex.dfy(54,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
   |                                                                                                                 ^

ex.dfy(55,112): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds and maintains BST property,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.

   |
55 |   // which satisfies the BST property with any bounds.
   |                                                       ^

ex.dfy(55,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property with any bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved

   |
57 |   // or recursively calls Insert on left or right subtree. The BST property is preserved
   |                                                                                         ^

ex.dfy(57,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. The BST property is preserved\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved
  // by the recursive calls and the ordering of value relative to t_value.

   |
58 |   // by the recursive calls and the ordering of value relative to t_value.
   |                                                                           ^

ex.dfy(58,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // by the recursive calls and the ordering of value relative to t_value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with any bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property is preserved
  // by the recursive calls and the ordering of value relative to t_value.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.

   |
55 |   // and the BST property holds because it is a single node.
   |                                                             ^

ex.dfy(55,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because it is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.

   |
57 |   // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
   |                                                                                                 ^

ex.dfy(57,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
   |                                                                                                                       ^

ex.dfy(54,118): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(55,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.

   |
56 |   // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.
   |                                                                                                                     ^

ex.dfy(56,116): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value, which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, and the BST property is preserved by the recursive calls.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
['  // and the BST property holds because it is a single node.\n']
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
['  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.

   |
53 |   // Proof by structural induction on t, similar to the previous lemma.
   |                                                                        ^

ex.dfy(53,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, similar to the previous lemma.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.

   |
55 |   // which preserves the BST property.
   |                                       ^

ex.dfy(55,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.

   |
55 |   // which satisfies the BST property.
   |                                       ^

ex.dfy(55,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The BST property is preserved if the recursive calls also preserve the property.

   |
58 |   // The BST property is preserved if the recursive calls also preserve the property.
   |                                                                                      ^

ex.dfy(58,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // The BST property is preserved if the recursive calls also preserve the property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The BST property is preserved if the recursive calls also preserve the property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.

   |
55 |   // which preserves the BST property because it is a single node.
   |                                                                   ^

ex.dfy(55,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property because it is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.

   |
54 |   // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
   |                                                                                           ^

ex.dfy(54,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,

   |
55 |   // Inductive step: if t is a Node, then Insert either maintains the BST property,
   |                                                                                    ^

ex.dfy(55,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either maintains the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then Insert creates a new Node that satisfies BST property.
  // Inductive step: if t is a Node, then Insert either maintains the BST property,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.

   |
55 |   // which preserves the BST property because it is a single-node tree.
   |                                                                        ^

ex.dfy(55,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which preserves the BST property because it is a single-node tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved

   |
57 |   // or recursively calls Insert on left or right subtree. The lemma should be proved
   |                                                                                      ^

ex.dfy(57,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. The lemma should be proved\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved
  // by recursively calling itself on the subtrees and checking the BST property.

   |
58 |   // by recursively calling itself on the subtrees and checking the BST property.
   |                                                                                  ^

ex.dfy(58,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // by recursively calling itself on the subtrees and checking the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single-node tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The lemma should be proved
  // by recursively calling itself on the subtrees and checking the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.

   |
55 |   // which satisfies the BST property with respect to lower and upper.
   |                                                                       ^

ex.dfy(55,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property with respect to lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with respect to lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements in the tree.

   |
55 |   // and the BST property holds because there are no other elements in the tree.
   |                                                                                 ^

ex.dfy(55,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because there are no other elements in the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements in the tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements in the tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,

   |
57 |   // or recursively calls Insert on left or right subtree. In each case,
   |                                                                         ^

ex.dfy(57,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In each case,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements in the tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,
  // the BST property holds because the recursive calls preserve the BST property.

   |
58 |   // the BST property holds because the recursive calls preserve the BST property.
   |                                                                                   ^

ex.dfy(58,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the BST property holds because the recursive calls preserve the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because there are no other elements in the tree.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,
  // the BST property holds because the recursive calls preserve the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
['  // which preserves the BST property because it is a single node.\n']
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // In each case, the lemma checks that the BST property holds for the resulting tree.

   |
58 |   // In each case, the lemma checks that the BST property holds for the resulting tree.
   |                                                                                        ^

ex.dfy(58,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // In each case, the lemma checks that the BST property holds for the resulting tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which preserves the BST property because it is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // In each case, the lemma checks that the BST property holds for the resulting tree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.
   |                                                                                                   ^

ex.dfy(54,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value within bounds,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value within bounds,
   |                                                                                                       ^

ex.dfy(55,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value within bounds,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value within bounds,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value within bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value within bounds,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, using the previous lemma to reason about Contains.

   |
53 |   // Proof by structural induction on t, using the previous lemma to reason about Contains.
   |                                                                                            ^

ex.dfy(53,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, using the previous lemma to reason about Contains.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, using the previous lemma to reason about Contains.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as inequalities.

   |
53 |   // Proof by structural induction on t, with lower and upper as inequalities.
   |                                                                               ^

ex.dfy(53,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, with lower and upper as inequalities.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as inequalities.
  // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.
   |                                                                                    ^

ex.dfy(54,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as inequalities.
  // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(55,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as inequalities.
  // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, with lower and upper as inequalities.
  // Base case: if t is Empty, then the result of Insert is a Node, which is a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.
   |                                                                                                   ^

ex.dfy(54,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node within bounds,
   |                                                                                      ^

ex.dfy(55,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node within bounds,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within bounds, and hence a BST.
  // Inductive step: if t is a Node, then Insert either returns a Node within bounds,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
   |                                                                                      ^

ex.dfy(54,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
   |                                                                                          ^

ex.dfy(55,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
53 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(53,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
   |                                                                                      ^

ex.dfy(54,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
   |                                                                                          ^

ex.dfy(55,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because value is within the bounds.

   |
55 |   // and IsBST holds because value is within the bounds.
   |                                                         ^

ex.dfy(55,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and IsBST holds because value is within the bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because value is within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because value is within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property holds because

   |
57 |   // or recursively calls Insert on left or right subtree. The BST property holds because
   |                                                                                          ^

ex.dfy(57,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. The BST property holds because\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because value is within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property holds because
  // of the recursive calls and the ordering of values.

   |
58 |   // of the recursive calls and the ordering of values.
   |                                                        ^

ex.dfy(58,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // of the recursive calls and the ordering of values.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because value is within the bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. The BST property holds because
  // of the recursive calls and the ordering of values.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because the new tree is a single node.

   |
55 |   // and IsBST holds because the new tree is a single node.
   |                                                            ^

ex.dfy(55,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and IsBST holds because the new tree is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because the new tree is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because the new tree is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and IsBST holds because the new tree is a single node.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because the node is a singleton.

   |
55 |   // and the BST property holds because the node is a singleton.
   |                                                                 ^

ex.dfy(55,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because the node is a singleton.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.

   |
57 |   // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
   |                                                                                                 ^

ex.dfy(57,96): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case, the BST property holds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.

   |
53 |   // Proof by structural induction on t, similar to the previous lemma.
   |                                                                        ^

ex.dfy(53,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, similar to the previous lemma.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node containing value,
   |                                                                                     ^

ex.dfy(54,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which maintains the BST property.

   |
55 |   // which maintains the BST property.
   |                                       ^

ex.dfy(55,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which maintains the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which maintains the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which maintains the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, maintaining the BST property.

   |
57 |   // or recursively calls Insert on left or right subtree, maintaining the BST property.
   |                                                                                         ^

ex.dfy(57,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree, maintaining the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to the previous lemma.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which maintains the BST property.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree, maintaining the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node within the bounds.\n']
['  // Inductive step: if t is a Node, then Insert either returns a Node within the bounds,\n']
['  // or recursively calls Insert on left or right subtree.\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, checking the BST conditions at each node.

   |
53 |   // Proof by structural induction on t, checking the BST conditions at each node.
   |                                                                                   ^

ex.dfy(53,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, checking the BST conditions at each node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, checking the BST conditions at each node.
  // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.

   |
54 |   // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.
   |                                                                                                       ^

ex.dfy(54,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, checking the BST conditions at each node.
  // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node with value between lower and upper,

   |
55 |   // Inductive step: if t is a Node, then Insert either returns a Node with value between lower and upper,
   |                                                                                                           ^

ex.dfy(55,106): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node with value between lower and upper,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, checking the BST conditions at each node.
  // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node with value between lower and upper,
  // or recursively calls Insert on left or right subtree.

   |
56 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(56,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, checking the BST conditions at each node.
  // Base case: if t is Empty, then the result of Insert is a Node with value between lower and upper.
  // Inductive step: if t is a Node, then Insert either returns a Node with value between lower and upper,
  // or recursively calls Insert on left or right subtree.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.

   |
42 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(42,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.

   |
50 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(50,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
50 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(50,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to InsertEnsuresContains.

   |
50 |   // Proof by structural induction on t, similar to InsertEnsuresContains.
   |                                                                           ^

ex.dfy(50,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t, similar to InsertEnsuresContains.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t, similar to InsertEnsuresContains.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
50 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(50,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with the given bounds.

   |
55 |   // which satisfies the BST property with the given bounds.
   |                                                             ^

ex.dfy(55,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property with the given bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with the given bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with the given bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,

   |
57 |   // or recursively calls Insert on left or right subtree. In each case,
   |                                                                         ^

ex.dfy(57,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree. In each case,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with the given bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,
  // the BST property is preserved with the given bounds.

   |
58 |   // the BST property is preserved with the given bounds.
   |                                                          ^

ex.dfy(58,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the BST property is preserved with the given bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which satisfies the BST property with the given bounds.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree. In each case,
  // the BST property is preserved with the given bounds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: if t is Empty, then the result of Insert is a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which is a BST because it has no children.

   |
55 |   // which is a BST because it has no children.
   |                                                ^

ex.dfy(55,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which is a BST because it has no children.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which is a BST because it has no children.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,

   |
56 |   // Inductive step: if t is a Node, then Insert either returns a Node containing value,
   |                                                                                         ^

ex.dfy(56,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if t is a Node, then Insert either returns a Node containing value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which is a BST because it has no children.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.

   |
57 |   // or recursively calls Insert on left or right subtree.
   |                                                           ^

ex.dfy(57,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or recursively calls Insert on left or right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which is a BST because it has no children.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.

   |
58 |   // The lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
   |                                                                                                                  ^

ex.dfy(58,113): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // The lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: if t is Empty, then the result of Insert is a Node containing value,
  // which is a BST because it has no children.
  // Inductive step: if t is a Node, then Insert either returns a Node containing value,
  // or recursively calls Insert on left or right subtree.
  // The lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.

   |
42 |   // Base case: If t is empty, then the new tree contains the inserted value.
   |                                                                              ^

ex.dfy(42,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is empty, then the new tree contains the inserted value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {

   |
43 |   if t == Empty {
   |                  ^

ex.dfy(43,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {

   |
44 |   } else {
   |           ^

ex.dfy(44,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.

   |
45 |     // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
   |                                                                                                                   ^

ex.dfy(45,114): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.

   |
46 |     // If the value is greater than the root of the tree, then the value must be in the right subtree.
   |                                                                                                       ^

ex.dfy(46,102): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If the value is greater than the root of the tree, then the value must be in the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.

   |
47 |     // If the value is equal to the root of the tree, then it's already in the tree.
   |                                                                                     ^

ex.dfy(47,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    // If the value is equal to the root of the tree, then it's already in the tree.\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t

   |
48 |     match t
   |            ^

ex.dfy(48,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>

   |
49 |     case Node(left, t_value, right) =>
   |                                       ^

ex.dfy(49,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {

   |
50 |       if value < t_value {
   |                           ^

ex.dfy(50,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < t_value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);

   |
51 |         InsertEnsuresContains(left, value);
   |                                            ^

ex.dfy(51,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {

   |
52 |       } else if value > t_value {
   |                                  ^

ex.dfy(52,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > t_value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);

   |
53 |         InsertEnsuresContains(right, value);
   |                                             ^

ex.dfy(53,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);
      }

   |
54 |       }
   |        ^

ex.dfy(54,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);
      }
  }

   |
55 |   }
   |    ^

ex.dfy(55,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);
      }
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);
      }
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, t_value, right) =>
      if value < t_value then Node(Insert(left, value), t_value, right)
      else if value > t_value then Node(left, t_value, Insert(right, value))
      else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, t_value, right) =>
    if value < t_value then Contains(left, value)
    else if value > t_value then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is empty, then the new tree contains the inserted value.
  if t == Empty {
  } else {
    // Recursive case: If the value is less than the root of the tree, then the value must be in the left subtree.
    // If the value is greater than the root of the tree, then the value must be in the right subtree.
    // If the value is equal to the root of the tree, then it's already in the tree.
    match t
    case Node(left, t_value, right) =>
      if value < t_value {
        InsertEnsuresContains(left, value);
      } else if value > t_value {
        InsertEnsuresContains(right, value);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 165
number of gen nodes: 83 (including leaves: 25)
number of back nodes: 82 (including leaves: 58)

expansion count: 134 (including failed: 52)

cache stats {'hit': 169, 'miss': 227}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904]

Trial calls: [396]


Time Statistics:

  Min: 904.00 sec, Max: 904.00 sec, Average: 904.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 396 calls, Max: 396 calls, Average: 396.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904]

Trial calls: [396]


Time Statistics:

  Min: 904.00 sec, Max: 904.00 sec, Average: 904.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 396 calls, Max: 396 calls, Average: 396.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true

   |
11 |   case Empty => true
   |                     ^

ex.dfy(11,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
13 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(13,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
14 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
15 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
13 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
14 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(14,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

ex.dfy(13,27): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
12 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(12,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
13 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(13,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
14 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(14,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)

   |
20 |   if t == Empty then Node(Empty, value, Empty)
   |                                               ^

ex.dfy(20,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else

   |
21 |   else
   |       ^

ex.dfy(21,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t

   |
22 |     match t
   |            ^

ex.dfy(22,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>

   |
23 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(23,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)

   |
24 |       if value < nodeValue then Node(Insert(left, value), nodeValue, right)
   |                                                                            ^

ex.dfy(24,75): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))

   |
25 |       else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
   |                                                                                 ^

ex.dfy(25,80): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t

   |
26 |       else t
   |             ^

ex.dfy(26,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t

   |
32 |   match t
   |          ^

ex.dfy(32,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false

   |
33 |   case Empty => false
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>

   |
34 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(34,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)

   |
35 |     value == nodeValue || Contains(left, value) || Contains(right, value)
   |                                                                          ^

ex.dfy(35,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == nodeValue || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
  Contains(Insert(t, value), value)

   |
41 |   Contains(Insert(t, value), value)
   |                                    ^

ex.dfy(41,35): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
  Contains(Insert(t, value), value)
}

   |
41 |   Contains(Insert(t, value), value)
   |   ^^^^^^^^

ex.dfy(41,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
  Contains(Insert(t, value), value)
}


   |
41 |   Contains(Insert(t, value), value)
   |   ^^^^^^^^

ex.dfy(41,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
{
  Contains(Insert(t, value), value)
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion

   |
41 |   Contains(Insert(t, value), value)
   |   ^^^^^^^^

ex.dfy(41,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t

   |
42 |   // Proof by induction on the structure of t
   |                                              ^

ex.dfy(42,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty

   |
43 |   // Base case: t is Empty
   |                           ^

ex.dfy(43,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty

   |
44 |   if t == Empty
   |                ^

ex.dfy(44,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {

   |
45 |   {
   |    ^

ex.dfy(45,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);

   |
46 |     assert Contains(Node(Empty, value, Empty), value);
   |                                                       ^

ex.dfy(46,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, value, Empty), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }

   |
47 |   }
   |    ^

ex.dfy(47,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else

   |
48 |   else
   |       ^

ex.dfy(48,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {

   |
49 |   {
   |    ^

ex.dfy(49,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node

   |
50 |     // Inductive case: t is Node
   |                                 ^

ex.dfy(50,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: t is Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t

   |
51 |     match t
   |            ^

ex.dfy(51,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>

   |
52 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(52,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue

   |
53 |       // Case 1: value < nodeValue
   |                                   ^

ex.dfy(53,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Case 1: value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue

   |
54 |       if value < nodeValue
   |                           ^

ex.dfy(54,26): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {

   |
55 |       {
   |        ^

ex.dfy(55,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);

   |
56 |         InsertEnsuresContains(left, value);
   |                                            ^

ex.dfy(56,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);

   |
57 |         assert Contains(Insert(left, value), value);
   |                                                     ^

ex.dfy(57,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(left, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);

   |
58 |         assert Contains(Node(Insert(left, value), nodeValue, right), value);
   |                                                                             ^

ex.dfy(58,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Insert(left, value), nodeValue, right), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }

   |
59 |       }
   |        ^

ex.dfy(59,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue

   |
60 |       // Case 2: value > nodeValue
   |                                   ^

ex.dfy(60,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Case 2: value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue

   |
61 |       else if value > nodeValue
   |                                ^

ex.dfy(61,31): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {

   |
62 |       {
   |        ^

ex.dfy(62,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);

   |
63 |         InsertEnsuresContains(right, value);
   |                                             ^

ex.dfy(63,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);

   |
64 |         assert Contains(Insert(right, value), value);
   |                                                      ^

ex.dfy(64,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(right, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);
        assert Contains(Node(left, nodeValue, Insert(right, value)), value);

   |
65 |         assert Contains(Node(left, nodeValue, Insert(right, value)), value);
   |                                                                             ^

ex.dfy(65,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(left, nodeValue, Insert(right, value)), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);
        assert Contains(Node(left, nodeValue, Insert(right, value)), value);
      }

   |
66 |       }
   |        ^

ex.dfy(66,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);
        assert Contains(Node(left, nodeValue, Insert(right, value)), value);
      }
      // Case 3: value == nodeValue

   |
67 |       // Case 3: value == nodeValue
   |                                    ^

ex.dfy(67,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Case 3: value == nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);
        assert Contains(Node(left, nodeValue, Insert(right, value)), value);
      }
      // Case 3: value == nodeValue
      else

   |
68 |       else
   |           ^

ex.dfy(68,10): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  // Base case: t is Empty
  if t == Empty
  {
    assert Contains(Node(Empty, value, Empty), value);
  }
  else
  {
    // Inductive case: t is Node
    match t
    case Node(left, nodeValue, right) =>
      // Case 1: value < nodeValue
      if value < nodeValue
      {
        InsertEnsuresContains(left, value);
        assert Contains(Insert(left, value), value);
        assert Contains(Node(Insert(left, value), nodeValue, right), value);
      }
      // Case 2: value > nodeValue
      else if value > nodeValue
      {
        InsertEnsuresContains(right, value);
        assert Contains(Insert(right, value), value);
        assert Contains(Node(left, nodeValue, Insert(right, value)), value);
      }
      // Case 3: value == nodeValue
      else
      {

   |
69 |       {
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
```

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package com.example.android.miwok;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['``` package com.example.android.miwok;\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package org.apache.hadoop.hbase.regionserver.skiplist.hbase;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.hadoop.hbase.regionserver.skiplist.hbase;\n']
['{\n']
['}\n']
['``` package com.example.android.miwok;\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` <?php

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package org.apache.ignite.internal.processors.query.h2.database.io;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.ignite.internal.processors.query.h2.database.io;\n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['``` package com.example.android.miwok;\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package com.example.android.pets.data;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.pets.data;\n']
['{\n']
['}\n']
['```\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
}
``` import React from 'react';

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import React from 'react';\n"]
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
['{\n']
['  Contains(Insert(t, value), value)\n']
['}\n']
['\n']
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t

   |
42 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(42,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  if t == Empty then

   |
43 |   if t == Empty then
   |                 ^

ex.dfy(43,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  if t == Empty then
    assert t == Empty;

   |
43 |   if t == Empty then
   |                 ^

ex.dfy(43,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert t == Empty;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  if t == Empty then
    assert t == Empty;
    assert Insert(t, value) == Node(Empty, value, Empty);

   |
43 |   if t == Empty then
   |                 ^

ex.dfy(43,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Insert(t, value) == Node(Empty, value, Empty);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...

   |
42 |   // ... base cases and recursive calls ...
   |                                            ^

ex.dfy(42,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ... base cases and recursive calls ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ... base cases and recursive calls ...

   |
50 |   // ... base cases and recursive calls ...
   |                                            ^

ex.dfy(50,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ... base cases and recursive calls ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... base cases and recursive calls ...
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ... base cases and recursive calls ...
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['{\n']
['  // ... base cases and recursive calls ...\n']
['}\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t

   |
43 |   match t
   |          ^

ex.dfy(43,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>

   |
44 |   case Empty =>
   |                ^

ex.dfy(44,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)

   |
45 |     // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
   |                                                                   ^

ex.dfy(45,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);

   |
46 |     assert Contains(Node(Empty, value, Empty), value);
   |                                                       ^

ex.dfy(46,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, value, Empty), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, nodeValue, right) =>

   |
47 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(47,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, nodeValue, right) =>
    // Inductive case

   |
48 |     // Inductive case
   |                      ^

ex.dfy(48,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, nodeValue, right) =>
    // Inductive case
    if value < nodeValue then

   |
49 |     if value < nodeValue then
   |                          ^

ex.dfy(49,25): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, nodeValue, right) =>
    // Inductive case
    if value < nodeValue then
      assert Contains(Insert(left, value), value);

   |
49 |     if value < nodeValue then
   |                          ^

ex.dfy(49,25): Error: lbrace expected
   |
50 |       assert Contains(Insert(left, value), value);
   |                                                   ^

ex.dfy(50,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(left, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Empty =>
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, nodeValue, right) =>
    // Inductive case
    if value < nodeValue then
      assert Contains(Insert(left, value), value);
    else if value > nodeValue then

   |
49 |     if value < nodeValue then
   |                          ^

ex.dfy(49,25): Error: lbrace expected
   |
51 |     else if value > nodeValue then
   |     ^

ex.dfy(51,4): Error: this symbol not expected in CaseStmt
   |
51 |     else if value > nodeValue then
   |                               ^

ex.dfy(51,30): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > nodeValue then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.

   |
42 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(42,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.

   |
50 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(50,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
49 | {
   |  ^

ex.dfy(49,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.

   |
50 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(50,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on the tree t.
}

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(49,0): Error: a postcondition could not be proved on this return path
   |
49 | {
   | ^

ex.dfy(48,10): Related location: this is the postcondition that could not be proved
   |
48 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  match t\n']
['  case Empty => false\n']
['  case Node(left, nodeValue, right) =>\n']
['    value == nodeValue || Contains(left, value) || Contains(right, value)\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
42 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.

   |
43 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
   |                                                                                     ^

ex.dfy(43,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,

   |
44 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
   |                                                                                                                                                       ^

ex.dfy(44,150): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.

   |
45 |   // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
   |                                                                                                                                                            ^

ex.dfy(45,155): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
53 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(53,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.
   |                                                                                                                ^

ex.dfy(54,111): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST with bounds lower and nodeValue,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST with bounds lower and nodeValue,
   |                                                                                                                                                                                 ^

ex.dfy(55,176): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST with bounds lower and nodeValue,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST with bounds lower and nodeValue,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST with bounds nodeValue and upper, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST with bounds nodeValue and upper, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                                                ^

ex.dfy(56,175): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST with bounds nodeValue and upper, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST with bounds lower and upper.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST with bounds lower and nodeValue,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST with bounds nodeValue and upper, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.
   |                                                                                                                        ^

ex.dfy(54,119): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
   |                                                                                                                                                 ^

ex.dfy(55,144): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                ^

ex.dfy(56,143): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property is preserved.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.
   |                                                                                                                 ^

ex.dfy(54,112): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
   |                                                                                                                                                                   ^

ex.dfy(55,162): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case the BST property holds.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case the BST property holds.
   |                                                                                                                                                                              ^

ex.dfy(56,173): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case the BST property holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and the BST property holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case the BST property holds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.
   |                                                                                                                                                                                                   ^

ex.dfy(54,194): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
   |                                                                                                                                                       ^

ex.dfy(55,150): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
   |                                                                                                                                                            ^

ex.dfy(56,155): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
  // In each case, IsBST(Insert(t, value), lower, upper) holds because IsBST(t, lower, upper) holds.

   |
57 |   // In each case, IsBST(Insert(t, value), lower, upper) holds because IsBST(t, lower, upper) holds.
   |                                                                                                     ^

ex.dfy(57,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // In each case, IsBST(Insert(t, value), lower, upper) holds because IsBST(t, lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and IsBST(Insert(t, value), lower, upper) holds because IsBST(Node(Empty, value, Empty), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
  // In each case, IsBST(Insert(t, value), lower, upper) holds because IsBST(t, lower, upper) holds.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.
   |                                                                                                                       ^

ex.dfy(54,118): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
   |                                                                                                                                                                   ^

ex.dfy(55,162): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
   |                                                                                                                                                                                    ^

ex.dfy(56,179): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which preserves the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.
   |                                                                                                                       ^

ex.dfy(54,118): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
   |                                                                                                                                                                   ^

ex.dfy(55,162): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
   |                                                                                                                                                                                    ^

ex.dfy(56,179): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which satisfies the BST property.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.
   |                                                                                                                                               ^

ex.dfy(54,142): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
   |                                                                                                                                                       ^

ex.dfy(55,150): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
   |                                                                                                                                                            ^

ex.dfy(56,155): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
  // In each case, the BST property holds, and the lemma is proved by induction.

   |
57 |   // In each case, the BST property holds, and the lemma is proved by induction.
   |                                                                                 ^

ex.dfy(57,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // In each case, the BST property holds, and the lemma is proved by induction.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and this is a BST since the BST property holds vacuously.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
  // In each case, the BST property holds, and the lemma is proved by induction.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.

   |
53 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(53,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
   |                                                                                                     ^

ex.dfy(54,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
   |                                                                                                                                                 ^

ex.dfy(55,144): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                ^

ex.dfy(56,143): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.
   |                                                                                                                                                                     ^

ex.dfy(54,164): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST rooted at nodeValue,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST rooted at nodeValue,
   |                                                                                                                                                                     ^

ex.dfy(55,164): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST rooted at nodeValue,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST rooted at nodeValue,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST rooted at nodeValue, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST rooted at nodeValue, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                                    ^

ex.dfy(56,163): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST rooted at nodeValue, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, and since lower <= value <= upper, IsBST(Insert(t, value), lower, upper) holds.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST rooted at nodeValue,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST rooted at nodeValue, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.
   |                                                                                    ^

ex.dfy(54,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
   |                                                                                                                                                 ^

ex.dfy(55,144): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                ^

ex.dfy(56,143): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].
   |                                                                                                                                ^

ex.dfy(54,127): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
   |                                                                                                                                                                   ^

ex.dfy(55,162): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
   |                                                                                                                                                                                    ^

ex.dfy(56,179): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is within the bounds [lower, upper].
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) preserves the BST property,
  // or value is greater than nodeValue, in which case Insert(right, value) preserves the BST property, or value is equal to nodeValue, in which case t preserves the BST property.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.

   |
54 |   // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
   |                                                                                                     ^

ex.dfy(54,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,

   |
55 |   // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
   |                                                                                                                                                 ^

ex.dfy(55,144): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.

   |
56 |   // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
   |                                                                                                                                                ^

ex.dfy(56,143): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then Node(Empty, value, Empty)
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else t
}

// (4) Predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) contains value,
  // or value is greater than nodeValue, in which case Insert(right, value) contains value, or value is equal to nodeValue, in which case t contains value.
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Proof by structural induction on t.
  // Base case: If t is Empty, then Insert(t, value) is a new node containing value, which is a BST.
  // Inductive case: If t is Node(left, nodeValue, right), then either value is less than nodeValue, in which case Insert(left, value) is a BST,
  // or value is greater than nodeValue, in which case Insert(right, value) is a BST, or value is equal to nodeValue, in which case t is a BST.
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,22): Related location
   |
12 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 201
number of gen nodes: 101 (including leaves: 30)
number of back nodes: 100 (including leaves: 71)

expansion count: 170 (including failed: 70)

cache stats {'hit': 218, 'miss': 217}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

Trial  3
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

SCORE
1.0
['  | Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true

   |
11 |   case Leaf() => true
   |                      ^

ex.dfy(11,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
13 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(13,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
14 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(14,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
15 |     IsBST(right, value, max)
   |                             ^

ex.dfy(15,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{

   |
21 | {
   |  ^

ex.dfy(21,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
22 |   match t
   |          ^

ex.dfy(22,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf() => Node(Leaf(), value, Leaf())

   |
23 |   case Leaf() => Node(Leaf(), value, Leaf())
   |                                             ^

ex.dfy(23,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf() => Node(Leaf(), value, Leaf())
  case Node(left, v, right) =>

   |
24 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(24,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf() => Node(Leaf(), value, Leaf())
  case Node(left, v, right) =>
    if value < v {

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf() => Node(Leaf(), value, Leaf())
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
   |
26 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(26,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf() => Node(Leaf(), value, Leaf())
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
   |
27 |     } else if value > v {
   |                         ^

ex.dfy(27,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf() => Node(Leaf(), value, Leaf())\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf() => Node(Leaf(), value, Leaf())\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf() => Node(Leaf(), value, Leaf())\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['// (3) Function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())

   |
22 |   if t == Leaf() then Node(Leaf(), value, Leaf())
   |                                                  ^

ex.dfy(22,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf() then Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else

   |
23 |   else
   |       ^

ex.dfy(23,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t

   |
24 |     match t
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>

   |
25 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(25,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)

   |
26 |       if value < v then Node(Insert(left, value), v, right)
   |                                                            ^

ex.dfy(26,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))

   |
27 |       else if value > v then Node(left, v, Insert(right, value))
   |                                                                 ^

ex.dfy(27,64): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t

   |
28 |       else t
   |             ^

ex.dfy(28,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false

   |
36 |   case Leaf() => false
   |                       ^

ex.dfy(36,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true

   |
38 |     if value == v then true
   |                            ^

ex.dfy(38,27): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value == v then true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)

   |
39 |     else if value < v then Contains(left, value)
   |                                                 ^

ex.dfy(39,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value < v then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)

   |
40 |     else Contains(right, value)
   |                                ^

ex.dfy(40,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()
```

```dafny
// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf() => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}
```

```dafny
// (3) Function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}
```

```dafny
// (4) Predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Leaf() => false
  case Node(left, v, right) =>
    if value == v then true
    else if value < v then Contains(left, value)
    else Contains(right, value)
}
```

```dafny
// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
}
```


STATS

number of nodes: 63
number of gen nodes: 32 (including leaves: 3)
number of back nodes: 31 (including leaves: 29)

expansion count: 35 (including failed: 4)

cache stats {'hit': 25, 'miss': 59}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175]

Trial calls: [396, 435, 84]


Time Statistics:

  Min: 175.00 sec, Max: 904.00 sec, Average: 660.00 sec, Standard Deviation: 342.95 sec

Call Statistics:

  Min: 84 calls, Max: 435 calls, Average: 305.00 calls, Standard Deviation: 157.08 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175]

Trial calls: [84]


Time Statistics:

  Min: 175.00 sec, Max: 175.00 sec, Average: 175.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 84 calls, Max: 84 calls, Average: 84.00 calls, Standard Deviation: 0.00 calls

Trial  4
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree

  |
6 |   reads tree
  |         ^^^^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree

  |
8 |   match tree
  |             ^

ex.dfy(8,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
11 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(11,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
12 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
13 |     IsBST(right, value, max)
   |                             ^

ex.dfy(13,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

  |
6 |   reads tree
  |         ^^^^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree

  |
7 |   match tree
  |             ^

ex.dfy(7,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
11 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
12 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(12,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

ex.dfy(11,27): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
['predicate IsBST(tree: Tree, min: nat, max: nat)\n']
['{\n']
['  match tree\n']
['  case Empty => true\n']
['  case Node(left, value, right) =>\n']
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)

   |
17 |   if tree == Empty then Node(Empty, value, Empty)
   |                                                  ^

ex.dfy(17,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Empty then Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else

   |
18 |   else
   |       ^

ex.dfy(18,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree

   |
19 |     match tree
   |               ^

ex.dfy(19,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>

   |
20 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(20,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)

   |
21 |       if value < nodeValue then Node(Insert(left, value), nodeValue, right)
   |                                                                            ^

ex.dfy(21,75): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))

   |
22 |       else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
   |                                                                                 ^

ex.dfy(22,80): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree

   |
23 |       else tree
   |                ^

ex.dfy(23,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
28 |   match tree
   |             ^

ex.dfy(28,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false

   |
29 |   case Empty => false
   |                      ^

ex.dfy(29,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>

   |
30 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(30,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)

   |
31 |     value == nodeValue || Contains(left, value) || Contains(right, value)
   |                                                                          ^

ex.dfy(31,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == nodeValue || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)

SCORE
1.0
['lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)

SCORE
1.0
['  requires Contains(tree, originalValue)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)

SCORE
1.0
['  ensures Contains(Insert(tree, value), originalValue)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree

   |
38 |   // proof by structural recursion on tree
   |                                           ^

ex.dfy(38,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural recursion on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)

SCORE
1.0
['  requires IsBST(tree, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max

SCORE
1.0
['  requires min <= value <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // proof by structural recursion on tree

   |
46 |   // proof by structural recursion on tree
   |                                           ^

ex.dfy(46,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural recursion on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // proof by structural recursion on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // proof by structural recursion on tree
}
``` package org.apache.ignite.internal.processors.cache.distributed.dht.atomic;

SCORE
1.0
['``` package org.apache.ignite.internal.processors.cache.distributed.dht.atomic;\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then Node(left, nodeValue, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)
  requires Contains(tree, originalValue)
  ensures Contains(Insert(tree, value), originalValue)
{
  // proof by structural recursion on tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // proof by structural recursion on tree
}
``` package org.apache.ignite.internal.processors.cache.distributed.dht.atomic;


STATS

number of nodes: 47
number of gen nodes: 24 (including leaves: 2)
number of back nodes: 23 (including leaves: 22)

expansion count: 25 (including failed: 2)

cache stats {'hit': 6, 'miss': 60}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152]

Trial calls: [396, 435, 84, 66]


Time Statistics:

  Min: 152.00 sec, Max: 904.00 sec, Average: 533.00 sec, Standard Deviation: 369.59 sec

Call Statistics:

  Min: 66 calls, Max: 435 calls, Average: 245.25 calls, Standard Deviation: 170.93 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152]

Trial calls: [84, 66]


Time Statistics:

  Min: 152.00 sec, Max: 175.00 sec, Average: 163.50 sec, Standard Deviation: 11.50 sec

Call Statistics:

  Min: 66 calls, Max: 84 calls, Average: 75.00 calls, Standard Deviation: 9.00 calls

Trial  5
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true

   |
11 |   case Empty => true
   |                     ^

ex.dfy(11,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&

   |
13 |     min <= value <= max &&
   |                           ^

ex.dfy(13,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    min <= value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&

   |
14 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
15 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
['{\n']
['  match t\n']
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, v, right) =>

   |
12 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
13 |     v >= min && v <= max &&
   |                            ^

ex.dfy(13,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&

   |
14 |     IsBST(left, min, v) &&
   |                           ^

ex.dfy(14,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)

   |
15 |     IsBST(right, v, max)
   |                         ^

ex.dfy(15,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool

SCORE
1.0
['function IsBST(tree: Tree): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&

   |
12 |     IsBST(left) &&
   |                   ^

ex.dfy(12,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || MaxValue(left) < value) &&

   |
13 |     (left == Empty || MaxValue(left) < value) &&
   |                                                 ^

ex.dfy(13,48): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (left == Empty || MaxValue(left) < value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || MaxValue(left) < value) &&
    (right == Empty || value < MinValue(right)) &&

   |
14 |     (right == Empty || value < MinValue(right)) &&
   |                                                   ^

ex.dfy(14,50): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (right == Empty || value < MinValue(right)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || MaxValue(left) < value) &&
    (right == Empty || value < MinValue(right)) &&
    IsBST(right)

   |
15 |     IsBST(right)
   |                 ^

ex.dfy(15,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || MaxValue(left) < value) &&
    (right == Empty || value < MinValue(right)) &&
    IsBST(right)
}

   |
13 |     (left == Empty || MaxValue(left) < value) &&
   |                       ^^^^^^^^

ex.dfy(13,22): Error: unresolved identifier: MaxValue
   |
14 |     (right == Empty || value < MinValue(right)) &&
   |                                ^^^^^^^^

ex.dfy(14,31): Error: unresolved identifier: MinValue
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match tree\n']
['  case Empty => true\n']
['  case Node(left, value, right) =>\n']
['    IsBST(left) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || treeMax(left) < value) &&

   |
13 |     (left == Empty || treeMax(left) < value) &&
   |                                                ^

ex.dfy(13,47): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (left == Empty || treeMax(left) < value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || treeMax(left) < value) &&
    (right == Empty || value < treeMin(right)) &&

   |
14 |     (right == Empty || value < treeMin(right)) &&
   |                                                  ^

ex.dfy(14,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (right == Empty || value < treeMin(right)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || treeMax(left) < value) &&
    (right == Empty || value < treeMin(right)) &&
    IsBST(right)

   |
15 |     IsBST(right)
   |                 ^

ex.dfy(15,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree): bool
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || treeMax(left) < value) &&
    (right == Empty || value < treeMin(right)) &&
    IsBST(right)
}

   |
13 |     (left == Empty || treeMax(left) < value) &&
   |                       ^^^^^^^

ex.dfy(13,22): Error: unresolved identifier: treeMax
   |
14 |     (right == Empty || value < treeMin(right)) &&
   |                                ^^^^^^^

ex.dfy(14,31): Error: unresolved identifier: treeMin
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree

   |
10 |   match tree
   |             ^

ex.dfy(10,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true

   |
11 |   case Empty => true
   |                     ^

ex.dfy(11,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&

   |
13 |     value >= lo && value <= hi &&
   |                                  ^

ex.dfy(13,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lo && value <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value - 1) &&

   |
14 |     IsBST(left, lo, value - 1) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lo, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value - 1) &&
    IsBST(right, value + 1, hi)

   |
15 |     IsBST(right, value + 1, hi)
   |                                ^

ex.dfy(15,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
  reads tree
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value - 1) &&
    IsBST(right, value + 1, hi)
}

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&

   |
12 |     value >= lo &&
   |                   ^

ex.dfy(12,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lo &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&

   |
13 |     value <= hi &&
   |                   ^

ex.dfy(13,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&

   |
14 |     IsBST(left, lo, value) &&
   |                              ^

ex.dfy(14,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)

   |
15 |     IsBST(right, value, hi)
   |                            ^

ex.dfy(15,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then

   |
21 |   if tree == Empty then
   |                        ^

ex.dfy(21,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)

   |
22 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(22,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else

   |
23 |   else
   |       ^

ex.dfy(23,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree

   |
24 |     match tree
   |               ^

ex.dfy(24,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>

   |
25 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(25,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then

   |
26 |       if value < v then
   |                        ^

ex.dfy(26,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)

   |
27 |         Node(Insert(left, value), v, right)
   |                                            ^

ex.dfy(27,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then

   |
28 |       else if value > v then
   |                             ^

ex.dfy(28,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))

   |
29 |         Node(left, v, Insert(right, value))
   |                                            ^

ex.dfy(29,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else

   |
30 |       else
   |           ^

ex.dfy(30,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree

   |
31 |         tree
   |             ^

ex.dfy(31,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element

SCORE
1.0
['// (4) Predicate for checking if a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{

   |
36 | {
   |  ^

ex.dfy(36,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
37 |   match tree
   |             ^

ex.dfy(37,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false

   |
38 |   case Empty => false
   |                      ^

ex.dfy(38,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>

   |
39 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(39,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)

   |
40 |     value == v || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(40,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == v || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
{
  Contains(Insert(tree, value), value)

   |
46 |   Contains(Insert(tree, value), value)
   |                                       ^

ex.dfy(46,38): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
{
  Contains(Insert(tree, value), value)
}

   |
46 |   Contains(Insert(tree, value), value)
   |   ^^^^^^^^

ex.dfy(46,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
{
  Contains(Insert(tree, value), value)
}


   |
46 |   Contains(Insert(tree, value), value)
   |   ^^^^^^^^

ex.dfy(46,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
{
  Contains(Insert(tree, value), value)
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

   |
46 |   Contains(Insert(tree, value), value)
   |   ^^^^^^^^

ex.dfy(46,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['{\n']
['  Contains(Insert(tree, value), value)\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
47 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(47,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)

SCORE
1.0
['  requires IsBST(tree, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{

   |
54 | {
   |  ^

ex.dfy(54,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on tree

   |
55 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(55,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on tree
}

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,10): Related location: this is the postcondition that could not be proved
   |
53 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,10): Related location: this is the postcondition that could not be proved
   |
53 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)

SCORE
1.0
['  requires IsBST(tree, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{

   |
54 | {
   |  ^

ex.dfy(54,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on tree

   |
55 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(55,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on tree
}

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,10): Related location: this is the postcondition that could not be proved
   |
53 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,10): Related location: this is the postcondition that could not be proved
   |
53 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(tree, lo, hi)\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
['{\n']
['  Contains(Insert(tree, value), value)\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.

   |
47 |   // Proof by structural induction on the tree.
   |                                                ^

ex.dfy(47,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.

   |
48 |   // Base case: If the tree is empty, then the result is a new node containing the value.
   |                                                                                          ^

ex.dfy(48,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If the tree is empty, then the result is a new node containing the value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
49 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(49,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
50 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(50,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.

   |
51 |   // contains the value.
   |                         ^

ex.dfy(51,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // contains the value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma for insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)

SCORE
1.0
['  requires IsBST(tree, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{

   |
58 | {
   |  ^

ex.dfy(58,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.

   |
59 |   // Proof by structural induction on the tree.
   |                                                ^

ex.dfy(59,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,

   |
60 |   // Base case: If the tree is empty, then the result is a new node containing the value,
   |                                                                                          ^

ex.dfy(60,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If the tree is empty, then the result is a new node containing the value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property because it is a single node.

   |
61 |   // which satisfies the BST property because it is a single node.
   |                                                                   ^

ex.dfy(61,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property because it is a single node.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property because it is a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
62 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(62,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property because it is a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
63 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(63,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property because it is a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property because the recursive calls to Insert and IsBST ensure it.

   |
64 |   // satisfies the BST property because the recursive calls to Insert and IsBST ensure it.
   |                                                                                           ^

ex.dfy(64,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // satisfies the BST property because the recursive calls to Insert and IsBST ensure it.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property because it is a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property because the recursive calls to Insert and IsBST ensure it.
}

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree.\n']
['  // Base case: If the tree is empty, then the result is a new node containing the value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.

   |
61 |   // which satisfies the BST property.
   |                                       ^

ex.dfy(61,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
62 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(62,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
63 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(63,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.

   |
64 |   // satisfies the BST property.
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.
}

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof by structural induction on the tree.\n']
['  // Base case: If the tree is empty, then the result is a new node containing the value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because it's a single node.

   |
61 |   // and the BST property holds because it's a single node.
   |                                                            ^

ex.dfy(61,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["  // and the BST property holds because it's a single node.\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because it's a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
62 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(62,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because it's a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
63 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(63,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because it's a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // maintains the BST property.

   |
64 |   // maintains the BST property.
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // maintains the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because it's a single node.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // maintains the BST property.
}

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree.\n']
['  // Base case: If the tree is empty, then the result is a new node containing the value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because the node is a singleton.

   |
61 |   // and the BST property holds because the node is a singleton.
   |                                                                 ^

ex.dfy(61,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // and the BST property holds because the node is a singleton.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
62 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(62,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
63 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(63,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.

   |
64 |   // satisfies the BST property.
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // and the BST property holds because the node is a singleton.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.
}

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= lo &&
   |     ^^^^^^^^^^^

ex.dfy(58,0): Error: a postcondition could not be proved on this return path
   |
58 | {
   | ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(tree, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value <= hi &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['  requires IsBST(tree, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi

SCORE
1.0
['  requires lo <= value <= hi\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{

   |
59 | {
   |  ^

ex.dfy(59,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.

   |
60 |   // Proof by structural induction on the tree.
   |                                                ^

ex.dfy(60,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,

   |
61 |   // Base case: If the tree is empty, then the result is a new node containing the value,
   |                                                                                          ^

ex.dfy(61,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If the tree is empty, then the result is a new node containing the value,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.

   |
62 |   // which satisfies the BST property.
   |                                       ^

ex.dfy(62,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,

   |
63 |   // Inductive step: If the tree is not empty, then either the value is in the left subtree,
   |                                                                                             ^

ex.dfy(63,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: If the tree is not empty, then either the value is in the left subtree,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result

   |
64 |   // or the value is in the right subtree, or the value is the root. In any case, the result
   |                                                                                             ^

ex.dfy(64,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // or the value is in the right subtree, or the value is the root. In any case, the result\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.

   |
65 |   // satisfies the BST property.
   |                                 ^

ex.dfy(65,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // satisfies the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.
}
``` package com.example.administrator.myapplication.db;

SCORE
1.0
['``` package com.example.administrator.myapplication.db;\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lo &&
    value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

// (3) Function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then
        Node(Insert(left, value), v, right)
      else if value > v then
        Node(left, v, Insert(right, value))
      else
        tree
}

// (4) Predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // contains the value.
}

// (6) Lemma for insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(tree, lo, hi)
  requires lo <= value <= hi
  ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof by structural induction on the tree.
  // Base case: If the tree is empty, then the result is a new node containing the value,
  // which satisfies the BST property.
  // Inductive step: If the tree is not empty, then either the value is in the left subtree,
  // or the value is in the right subtree, or the value is the root. In any case, the result
  // satisfies the BST property.
}
``` package com.example.administrator.myapplication.db;


STATS

number of nodes: 163
number of gen nodes: 82 (including leaves: 23)
number of back nodes: 81 (including leaves: 59)

expansion count: 131 (including failed: 50)

cache stats {'hit': 175, 'miss': 155}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596]

Trial calls: [396, 435, 84, 66, 330]


Time Statistics:

  Min: 152.00 sec, Max: 904.00 sec, Average: 545.60 sec, Standard Deviation: 331.53 sec

Call Statistics:

  Min: 66 calls, Max: 435 calls, Average: 262.20 calls, Standard Deviation: 156.59 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596]

Trial calls: [84, 66, 330]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 307.67 sec, Standard Deviation: 204.10 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 160.00 calls, Standard Deviation: 120.43 calls

Trial  6
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree

  |
5 |   match tree
  |             ^

ex.dfy(5,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true

  |
6 |   case Empty => true
  |                     ^

ex.dfy(6,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

  |
7 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(7,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

  |
8 |     value >= min && value <= max &&
  |                                    ^

ex.dfy(8,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

  |
9 |     IsBST(left, min, value) &&
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
10 |     IsBST(right, value, max)
   |                             ^

ex.dfy(10,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)

   |
15 |   if tree == Empty then Node(Empty, value, Empty)
   |                                                  ^

ex.dfy(15,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Empty then Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else

   |
16 |   else
   |       ^

ex.dfy(16,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree

   |
17 |     match tree
   |               ^

ex.dfy(17,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>

   |
18 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(18,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)

   |
19 |       if value < v then Node(Insert(left, value), v, right)
   |                                                            ^

ex.dfy(19,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))

   |
20 |       else if value > v then Node(left, v, Insert(right, value))
   |                                                                 ^

ex.dfy(20,64): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree

   |
21 |       else tree
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
['lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
requires value == Insert(tree, value)

   |
25 | requires value == Insert(tree, value)
   |                ^^

ex.dfy(25,15): Error: arguments must have comparable types (got nat and Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['requires value == Insert(tree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
requires value == Insert(tree, value)
ensures IsBST(newTree, Min(tree), Max(tree))

   |
26 | ensures IsBST(newTree, Min(tree), Max(tree))
   |                        ^^^

ex.dfy(26,23): Error: unresolved identifier: Min
   |
26 | ensures IsBST(newTree, Min(tree), Max(tree))
   |                                   ^^^

ex.dfy(26,34): Error: unresolved identifier: Max
   |
25 | requires value == Insert(tree, value)
   |                ^^

ex.dfy(25,15): Error: arguments must have comparable types (got nat and Tree)
3 resolution/type errors detected in ex.dfy

SCORE
None
['ensures IsBST(newTree, Min(tree), Max(tree))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
requires value == Insert(tree, value)
ensures IsBST(newTree, Min(tree), Max(tree))
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
requires value == Insert(tree, value)
ensures IsBST(newTree, Min(tree), Max(tree))
{
  // Proof omitted

   |
28 |   // Proof omitted
   |                   ^

ex.dfy(28,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
requires value == Insert(tree, value)
ensures IsBST(newTree, Min(tree), Max(tree))
{
  // Proof omitted
}

   |
26 | ensures IsBST(newTree, Min(tree), Max(tree))
   |                        ^^^

ex.dfy(26,23): Error: unresolved identifier: Min
   |
26 | ensures IsBST(newTree, Min(tree), Max(tree))
   |                                   ^^^

ex.dfy(26,34): Error: unresolved identifier: Max
   |
25 | requires value == Insert(tree, value)
   |                ^^

ex.dfy(25,15): Error: arguments must have comparable types (got nat and Tree)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree

SCORE
1.0
['  requires Insert(tree, value) == newTree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&

   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                                                               ^

ex.dfy(26,62): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
          (Contains(tree, value) ==> Contains(newTree, value))

   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                       ^^^

ex.dfy(26,22): Error: unresolved identifier: min
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                            ^^^

ex.dfy(26,27): Error: unresolved identifier: max
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                                                   ^^^

ex.dfy(26,50): Error: unresolved identifier: min
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                                                        ^^^

ex.dfy(26,55): Error: unresolved identifier: max
   |
27 |           (Contains(tree, value) ==> Contains(newTree, value))
   |            ^^^^^^^^

ex.dfy(27,11): Error: unresolved identifier: Contains
   |
27 |           (Contains(tree, value) ==> Contains(newTree, value))
   |                                      ^^^^^^^^

ex.dfy(27,37): Error: unresolved identifier: Contains
6 resolution/type errors detected in ex.dfy

SCORE
None
['          (Contains(tree, value) ==> Contains(newTree, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
          (Contains(tree, value) ==> Contains(newTree, value))
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
          (Contains(tree, value) ==> Contains(newTree, value))
{
  // proof omitted; use pattern matching on tree and newTree, and recursively call the lemma

   |
29 |   // proof omitted; use pattern matching on tree and newTree, and recursively call the lemma
   |                                                                                             ^

ex.dfy(29,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof omitted; use pattern matching on tree and newTree, and recursively call the lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
          (Contains(tree, value) ==> Contains(newTree, value))
{
  // proof omitted; use pattern matching on tree and newTree, and recursively call the lemma
}

   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                       ^^^

ex.dfy(26,22): Error: unresolved identifier: min
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                            ^^^

ex.dfy(26,27): Error: unresolved identifier: max
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                                                   ^^^

ex.dfy(26,50): Error: unresolved identifier: min
   |
26 |   ensures IsBST(tree, min, max) && IsBST(newTree, min, max) &&
   |                                                        ^^^

ex.dfy(26,55): Error: unresolved identifier: max
   |
27 |           (Contains(tree, value) ==> Contains(newTree, value))
   |            ^^^^^^^^

ex.dfy(27,11): Error: unresolved identifier: Contains
   |
27 |           (Contains(tree, value) ==> Contains(newTree, value))
   |                                      ^^^^^^^^

ex.dfy(27,37): Error: unresolved identifier: Contains
6 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures newTree != Empty && newTree.value == value

SCORE
1.0
['  ensures newTree != Empty && newTree.value == value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures newTree != Empty && newTree.value == value
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures newTree != Empty && newTree.value == value
{
  // ...

   |
28 |   // ...
   |         ^

ex.dfy(28,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

lemma InsertMaintainsElement(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures newTree != Empty && newTree.value == value
{
  // ...
}

ex.dfy(27,0): Error: a postcondition could not be proved on this return path
   |
27 | {
   | ^

ex.dfy(26,30): Related location: this is the postcondition that could not be proved
   |
26 |   ensures newTree != Empty && newTree.value == value
   |                               ^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // ...\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
26 |   match tree
   |             ^

ex.dfy(26,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false

   |
27 |   case Empty => false
   |                      ^

ex.dfy(27,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>

   |
28 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(28,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)

   |
29 |     value == v || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(29,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == v || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesElement(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
35 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(35,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)

SCORE
1.0
['  requires IsBST(tree, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  ensures IsBST(Insert(tree, value), min, max)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree

   |
42 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(42,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,10): Related location: this is the postcondition that could not be proved
   |
40 |   ensures IsBST(Insert(tree, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= min && value <= max &&
  |     ^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,10): Related location: this is the postcondition that could not be proved
   |
40 |   ensures IsBST(Insert(tree, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,20): Related location
  |
8 |     value >= min && value <= max &&
  |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max

SCORE
1.0
['  requires min <= value <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree

   |
43 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(43,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Empty => false
  case Node(left, v, right) =>
    value == v || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

lemma InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat)
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // Proof by structural induction on tree
}
```


STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 3)
number of back nodes: 25 (including leaves: 23)

expansion count: 31 (including failed: 6)

cache stats {'hit': 6, 'miss': 65}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596, 171]

Trial calls: [396, 435, 84, 66, 330, 71]


Time Statistics:

  Min: 152.00 sec, Max: 904.00 sec, Average: 483.17 sec, Standard Deviation: 333.29 sec

Call Statistics:

  Min: 66 calls, Max: 435 calls, Average: 230.33 calls, Standard Deviation: 159.73 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596, 171]

Trial calls: [84, 66, 330, 71]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 273.50 sec, Standard Deviation: 186.40 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 137.75 calls, Standard Deviation: 111.19 calls

Trial  7
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree

  |
5 |   match tree
  |             ^

ex.dfy(5,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true

  |
6 |   case Leaf => true
  |                    ^

ex.dfy(6,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

  |
7 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(7,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&

  |
8 |     value >= lo && value <= hi &&
  |                                  ^

ex.dfy(8,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lo && value <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&

  |
9 |     IsBST(left, lo, value) &&
  |                              ^

ex.dfy(9,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)

   |
10 |     IsBST(right, value, hi)
   |                            ^

ex.dfy(10,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then

   |
15 |   if value < NatMin(tree) then
   |                               ^

ex.dfy(15,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if value < NatMin(tree) then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))

   |
16 |     Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
   |                                                               ^

ex.dfy(16,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
  else if value > NatMax(tree) then

   |
17 |   else if value > NatMax(tree) then
   |                                    ^

ex.dfy(17,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else if value > NatMax(tree) then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
  else if value > NatMax(tree) then
    Node(Left(tree), NatMin(tree), Insert(Right(tree), value))

   |
18 |     Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
   |                                                               ^

ex.dfy(18,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Left(tree), NatMin(tree), Insert(Right(tree), value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
  else if value > NatMax(tree) then
    Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
  else

   |
19 |   else
   |       ^

ex.dfy(19,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
  else if value > NatMax(tree) then
    Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
  else
    tree

   |
20 |     tree
   |         ^

ex.dfy(20,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMin(tree) then
    Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
  else if value > NatMax(tree) then
    Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
  else
    tree
}

   |
15 |   if value < NatMin(tree) then
   |              ^^^^^^

ex.dfy(15,13): Error: unresolved identifier: NatMin
   |
16 |     Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
   |                 ^^^^

ex.dfy(16,16): Error: unresolved identifier: Left
   |
16 |     Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
   |                                     ^^^^^^

ex.dfy(16,36): Error: unresolved identifier: NatMin
   |
16 |     Node(Insert(Left(tree), value), NatMin(tree), Right(tree))
   |                                                   ^^^^^

ex.dfy(16,50): Error: unresolved identifier: Right
   |
17 |   else if value > NatMax(tree) then
   |                   ^^^^^^

ex.dfy(17,18): Error: unresolved identifier: NatMax
   |
18 |     Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
   |          ^^^^

ex.dfy(18,9): Error: unresolved identifier: Left
   |
18 |     Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
   |                      ^^^^^^

ex.dfy(18,21): Error: unresolved identifier: NatMin
   |
18 |     Node(Left(tree), NatMin(tree), Insert(Right(tree), value))
   |                                           ^^^^^

ex.dfy(18,42): Error: unresolved identifier: Right
8 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree

   |
15 |   match tree
   |             ^

ex.dfy(15,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)

   |
16 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(16,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>

   |
17 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(17,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue

   |
18 |     if value < nodeValue
   |                         ^

ex.dfy(18,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)

   |
19 |       then Node(Insert(left, value), nodeValue, right)
   |                                                       ^

ex.dfy(19,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue

   |
20 |     else if value > nodeValue
   |                              ^

ex.dfy(20,29): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))

   |
21 |       then Node(left, nodeValue, Insert(right, value))
   |                                                       ^

ex.dfy(21,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else

   |
22 |     else
   |         ^

ex.dfy(22,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree

   |
23 |       tree
   |           ^

ex.dfy(23,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
28 |   match tree
   |             ^

ex.dfy(28,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false

   |
29 |   case Leaf => false
   |                     ^

ex.dfy(29,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>

   |
30 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(30,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)

   |
31 |     value == nodeValue || Contains(left, value) || Contains(right, value)
   |                                                                          ^

ex.dfy(31,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == nodeValue || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertMaintainsContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true

SCORE
1.0
['requires Contains(tree, value) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true

SCORE
1.0
['ensures Contains(Insert(tree, value), value) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree

   |
38 |   // proof by cases on the structure of tree
   |                                             ^

ex.dfy(38,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases on the structure of tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true

SCORE
1.0
['requires IsBST(tree, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree

   |
45 |   // proof by cases on the structure of tree
   |                                             ^

ex.dfy(45,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases on the structure of tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertPreservesBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['requires IsBST(tree, lo, hi) == true\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true

SCORE
1.0
['requires IsBST(tree, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree

   |
45 |   // proof by cases on the structure of tree
   |                                             ^

ex.dfy(45,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases on the structure of tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree, and using InsertMaintainsContains

   |
45 |   // proof by cases on the structure of tree, and using InsertMaintainsContains
   |                                                                                ^

ex.dfy(45,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases on the structure of tree, and using InsertMaintainsContains\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree, and using InsertMaintainsContains
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases

   |
38 |   // proof by cases
   |                    ^

ex.dfy(38,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true

SCORE
1.0
['requires IsBST(tree, lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true

SCORE
1.0
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases

   |
45 |   // proof by cases
   |                    ^

ex.dfy(45,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // proof by cases\n']
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases\n']
['}\n']
['{\n']
['  // proof by cases\n']
['}\n']
['requires IsBST(tree, lo, hi) == true\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases\n']
['}\n']
['{\n']
['  // proof by cases\n']
['}\n']
['{\n']
['  // proof by cases\n']
['}\n']
['\n']
['lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
['requires IsBST(tree, lo, hi) == true\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree, and possibly recursively invoking the lemma

   |
45 |   // proof by cases on the structure of tree, and possibly recursively invoking the lemma
   |                                                                                          ^

ex.dfy(45,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by cases on the structure of tree, and possibly recursively invoking the lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value), value) == true
{
  // proof by cases on the structure of tree
}

lemma InsertMaintainsIsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) == true
ensures IsBST(Insert(tree, value), lo, hi) == true
{
  // proof by cases on the structure of tree, and possibly recursively invoking the lemma
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi) == true
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['requires IsBST(tree, lo, hi) == true\n']
['ensures IsBST(Insert(tree, value), lo, hi) == true\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
['{\n']
['  // proof by cases on the structure of tree\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value'), value) == Contains(tree, value)

   |
36 | ensures Contains(Insert(tree, value'), value) == Contains(tree, value)
   |                               ^^^^^^

ex.dfy(36,30): Error: unresolved identifier: value'
1 resolution/type errors detected in ex.dfy

SCORE
None
["ensures Contains(Insert(tree, value'), value) == Contains(tree, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value'), value) == Contains(tree, value)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value'), value) == Contains(tree, value)
{
  // proof here

   |
38 |   // proof here
   |                ^

ex.dfy(38,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value) == true
ensures Contains(Insert(tree, value'), value) == Contains(tree, value)
{
  // proof here
}

   |
36 | ensures Contains(Insert(tree, value'), value) == Contains(tree, value)
   |                               ^^^^^^

ex.dfy(36,30): Error: unresolved identifier: value'
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)

SCORE
1.0
['requires Contains(tree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)

   |
36 | ensures Contains(Insert(tree, value'), value)
   |                               ^^^^^^

ex.dfy(36,30): Error: unresolved identifier: value'
1 resolution/type errors detected in ex.dfy

SCORE
None
["ensures Contains(Insert(tree, value'), value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases

   |
38 |   // base cases
   |                ^

ex.dfy(38,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {

   |
39 |   if tree == Leaf {
   |                    ^

ex.dfy(39,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {

   |
40 |   } else {
   |           ^

ex.dfy(40,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree

   |
41 |     match tree
   |               ^

ex.dfy(41,14): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>

   |
42 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {

   |
43 |       if value == nodeValue {
   |                              ^

ex.dfy(43,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value == nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {

   |
44 |       } else if value < nodeValue {
   |                                    ^

ex.dfy(44,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);

   |
45 |         InsertMaintainsContains(left, value);
   |                                              ^

ex.dfy(45,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);
      } else {

   |
46 |       } else {
   |               ^

ex.dfy(46,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);
      } else {
        InsertMaintainsContains(right, value);

   |
47 |         InsertMaintainsContains(right, value);
   |                                               ^

ex.dfy(47,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);
      } else {
        InsertMaintainsContains(right, value);
      }

   |
48 |       }
   |        ^

ex.dfy(48,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);
      } else {
        InsertMaintainsContains(right, value);
      }
  }

   |
49 |   }
   |    ^

ex.dfy(49,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat)
requires Contains(tree, value)
ensures Contains(Insert(tree, value'), value)
{
  // base cases
  if tree == Leaf {
  } else {
    match tree
    case Node(left, nodeValue, right) =>
      if value == nodeValue {
      } else if value < nodeValue {
        InsertMaintainsContains(left, value);
      } else {
        InsertMaintainsContains(right, value);
      }
  }
}

   |
36 | ensures Contains(Insert(tree, value'), value)
   |                               ^^^^^^

ex.dfy(36,30): Error: unresolved identifier: value'
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
['lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)

SCORE
1.0
['requires Contains(tree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)

SCORE
1.0
['ensures Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case

   |
38 |   // base case
   |               ^

ex.dfy(38,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);

   |
39 |   assert Contains(tree, value);
   |                                ^

ex.dfy(39,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  assert Contains(tree, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree

   |
40 |   match tree
   |             ^

ex.dfy(40,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree
  case Node(left, nodeValue, right) =>

   |
41 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(41,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree
  case Node(left, nodeValue, right) =>
    if value == nodeValue

   |
42 |     if value == nodeValue
   |                          ^

ex.dfy(42,25): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value == nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree
  case Node(left, nodeValue, right) =>
    if value == nodeValue
      then assert Contains(newTree, nodeValue);

   |
43 |       then assert Contains(newTree, nodeValue);
   |       ^

ex.dfy(43,6): Error: lbrace expected
   |
43 |       then assert Contains(newTree, nodeValue);
   |                                                ^

ex.dfy(43,47): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      then assert Contains(newTree, nodeValue);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree
  case Node(left, nodeValue, right) =>
    if value == nodeValue
      then assert Contains(newTree, nodeValue);
    else if value < nodeValue

   |
43 |       then assert Contains(newTree, nodeValue);
   |       ^

ex.dfy(43,6): Error: lbrace expected
   |
44 |     else if value < nodeValue
   |     ^

ex.dfy(44,4): Error: this symbol not expected in CaseStmt
   |
44 |     else if value < nodeValue
   |                              ^

ex.dfy(44,29): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    else if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // base case
  assert Contains(tree, value);
  match tree
  case Node(left, nodeValue, right) =>
    if value == nodeValue
      then assert Contains(newTree, nodeValue);
    else if value < nodeValue
      then assert Contains(left, value);

   |
43 |       then assert Contains(newTree, nodeValue);
   |       ^

ex.dfy(43,6): Error: lbrace expected
   |
44 |     else if value < nodeValue
   |     ^

ex.dfy(44,4): Error: this symbol not expected in CaseStmt
   |
45 |       then assert Contains(left, value);
   |       ^

ex.dfy(45,6): Error: lbrace expected
   |
45 |       then assert Contains(left, value);
   |                                         ^

ex.dfy(45,40): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
-1.0
['      then assert Contains(left, value);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // proof by structural induction on tree

   |
38 |   // proof by structural induction on tree
   |                                           ^

ex.dfy(38,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // proof by structural induction on tree
  // base case: tree = Leaf

   |
39 |   // base case: tree = Leaf
   |                            ^

ex.dfy(39,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: tree = Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // proof by structural induction on tree
  // base case: tree = Leaf
  // induction step: tree = Node(left, value, right)

   |
40 |   // induction step: tree = Node(left, value, right)
   |                                                     ^

ex.dfy(40,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction step: tree = Node(left, value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // proof by structural induction on tree
  // base case: tree = Leaf
  // induction step: tree = Node(left, value, right)
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(29,15): Related location
   |
29 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['ensures Contains(newTree, value)\n']
['{\n']
['  // proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // proof by structural induction on tree
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(29,15): Related location
   |
29 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // Proof by structural induction on tree.

   |
38 |   // Proof by structural induction on tree.
   |                                            ^

ex.dfy(38,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value)
ensures Contains(newTree, value)
{
  // Proof by structural induction on tree.
}

ex.dfy(37,0): Error: a postcondition could not be proved on this return path
   |
37 | {
   | ^

ex.dfy(36,8): Related location: this is the postcondition that could not be proved
   |
36 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(29,15): Related location
   |
29 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)

SCORE
1.0
['lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)

SCORE
1.0
['requires Contains(tree, originalValue)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)

SCORE
1.0
['ensures Contains(Insert(tree, value), originalValue)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted

   |
38 |   // Proof omitted
   |                   ^

ex.dfy(38,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi)

SCORE
1.0
['requires IsBST(tree, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi)
ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi)
ensures IsBST(Insert(tree, value), lo, hi)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi)
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted

   |
45 |   // Proof omitted
   |                   ^

ex.dfy(45,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi)
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lo && value <= hi &&
  |     ^^^^^^^^^^^

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures IsBST(Insert(tree, value), lo, hi)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,19): Related location
  |
8 |     value >= lo && value <= hi &&
  |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof omitted\n']
['}\n']
['ensures IsBST(Insert(tree, value), lo, hi)\n']
['{\n']
['  // Proof omitted\n']
['}\n']
['{\n']
['  // Proof omitted\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi

SCORE
1.0
['requires IsBST(tree, lo, hi) && lo <= value <= hi\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)

SCORE
1.0
['ensures IsBST(Insert(tree, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted

   |
45 |   // Proof omitted
   |                   ^

ex.dfy(45,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(tree: Tree, lo: nat, hi: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
}

predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)
}

lemma InsertMaintainsContains(tree: Tree, value: nat, originalValue: nat)
requires Contains(tree, originalValue)
ensures Contains(Insert(tree, value), originalValue)
{
  // Proof omitted
}

lemma InsertMaintainsBST(tree: Tree, value: nat, lo: nat, hi: nat)
requires IsBST(tree, lo, hi) && lo <= value <= hi
ensures IsBST(Insert(tree, value), lo, hi)
{
  // Proof omitted
}
```


STATS

number of nodes: 123
number of gen nodes: 62 (including leaves: 18)
number of back nodes: 61 (including leaves: 44)

expansion count: 99 (including failed: 38)

cache stats {'hit': 101, 'miss': 130}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596, 171, 445]

Trial calls: [396, 435, 84, 66, 330, 71, 231]


Time Statistics:

  Min: 152.00 sec, Max: 904.00 sec, Average: 477.71 sec, Standard Deviation: 308.86 sec

Call Statistics:

  Min: 66 calls, Max: 435 calls, Average: 230.43 calls, Standard Deviation: 147.88 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596, 171, 445]

Trial calls: [84, 66, 330, 71, 231]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 307.80 sec, Standard Deviation: 180.28 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 156.40 calls, Standard Deviation: 106.22 calls

Trial  8
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers

SCORE
1.0
['// (1) Write an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['function IsBST(tree: Tree, lower: nat, upper: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree

  |
9 |   reads tree
  |         ^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree

   |
11 |   match tree
   |             ^

ex.dfy(11,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>
    lower <= value && value < upper &&

   |
13 |     lower <= value && value < upper &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&

   |
14 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(14,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
15 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(15,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
  case Empty => true

   |
16 |   case Empty => true
   |                     ^

ex.dfy(16,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
  reads tree
{
  match tree
  case Node(left, value, right) =>
    lower <= value && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
  case Empty => true
}

  |
9 |   reads tree
  |         ^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree

   |
10 |   match tree
   |             ^

ex.dfy(10,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&

   |
12 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&

   |
13 |     IsBST(right, value, upper) &&
   |                                  ^

ex.dfy(13,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&

   |
14 |     lower < value &&
   |                     ^

ex.dfy(14,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lower < value &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper

   |
15 |     value < upper
   |                  ^

ex.dfy(15,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value < upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true

   |
16 |   case Empty => true
   |                     ^

ex.dfy(16,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)

   |
19 | predicate IsBST(tree: Tree)
   |           ^^^^^

ex.dfy(19,10): Error: Duplicate member name: IsBST
1 resolution/type errors detected in ex.dfy

SCORE
None
['predicate IsBST(tree: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{
  IsBST(tree, 0, maxInt)

   |
21 |   IsBST(tree, 0, maxInt)
   |                         ^

ex.dfy(21,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  IsBST(tree, 0, maxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{
  IsBST(tree, 0, maxInt)
}

   |
19 | predicate IsBST(tree: Tree)
   |           ^^^^^

ex.dfy(19,10): Error: Duplicate member name: IsBST
   |
21 |   IsBST(tree, 0, maxInt)
   |                  ^^^^^^

ex.dfy(21,17): Error: unresolved identifier: maxInt
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['predicate IsBST(tree: Tree)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{
  IsBST(tree, 0, nat.MaxInt)

   |
21 |   IsBST(tree, 0, nat.MaxInt)
   |                  ^

ex.dfy(21,17): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  IsBST(tree, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{
  IsBST(tree, 0, nat.MaxInt)
}

   |
21 |   IsBST(tree, 0, nat.MaxInt)
   |                  ^

ex.dfy(21,17): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate IsBST(tree: Tree)
{
  IsBST(tree, 0, nat.MaxInt)
}
```

   |
21 |   IsBST(tree, 0, nat.MaxInt)
   |                  ^

ex.dfy(21,17): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['```\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

function IsBST(tree: Tree): bool {

   |
19 | function IsBST(tree: Tree): bool {
   |                                   ^

ex.dfy(19,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function IsBST(tree: Tree): bool {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

function IsBST(tree: Tree): bool {
  IsBST(tree, 0, max_int)

   |
20 |   IsBST(tree, 0, max_int)
   |                          ^

ex.dfy(20,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  IsBST(tree, 0, max_int)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

function IsBST(tree: Tree): bool {
  IsBST(tree, 0, max_int)
}

   |
19 | function IsBST(tree: Tree): bool {
   |          ^^^^^

ex.dfy(19,9): Error: Duplicate member name: IsBST
   |
20 |   IsBST(tree, 0, max_int)
   |                  ^^^^^^^

ex.dfy(20,17): Error: unresolved identifier: max_int
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {

   |
19 | predicate BST(tree: Tree, lower: nat, upper: nat) {
   |                                                    ^

ex.dfy(19,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate BST(tree: Tree, lower: nat, upper: nat) {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)

   |
20 |   IsBST(tree, lower, upper)
   |                            ^

ex.dfy(20,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  IsBST(tree, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree

   |
27 |   match tree
   |             ^

ex.dfy(27,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>

   |
28 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(28,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['              : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))
  case Empty => Node(Empty, value, Empty)

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>

   |
28 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(28,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue {

   |
29 |     if value < nodeValue {
   |                          ^

ex.dfy(29,25): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)

   |
29 |     if value < nodeValue {
   |                          ^

ex.dfy(29,25): Error: then expected
   |
30 |       Node(Insert(left, value), nodeValue, right)
   |                                                  ^

ex.dfy(30,49): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)
    } else if value > nodeValue {

   |
29 |     if value < nodeValue {
   |                          ^

ex.dfy(29,25): Error: then expected
   |
31 |     } else if value > nodeValue {
   |                                 ^

ex.dfy(31,32): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > nodeValue {\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right) :

   |
29 |     (value < v) ? Node(Insert(left, value), v, right) :
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right) :
    (v < value) ? Node(left, v, Insert(right, value)) :

   |
29 |     (value < v) ? Node(Insert(left, value), v, right) :
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value) ? Node(left, v, Insert(right, value)) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right) :
    (v < value) ? Node(left, v, Insert(right, value)) :
    tree

   |
29 |     (value < v) ? Node(Insert(left, value), v, right) :
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    tree\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['```dafny\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : (v < value) ? Node(left, v, Insert(right, value))

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : (v < value) ? Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : (v < value) ? Node(left, v, Insert(right, value))
                          : tree

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                          : tree\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['```\n']
['\n']
['```dafny\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right) :
    (value > v) ? Node(left, v, Insert(right, value)) :

   |
29 |     (value < v) ? Node(Insert(left, value), v, right) :
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value > v) ? Node(left, v, Insert(right, value)) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right) :
    (value > v) ? Node(left, v, Insert(right, value)) :
    tree

   |
29 |     (value < v) ? Node(Insert(left, value), v, right) :
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    tree\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))
  case Empty => Node(Empty, value, Empty)

   |
29 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => Node(Empty, value, Empty)\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, x, right) =>

   |
28 |   case Node(left, x, right) =>
   |                               ^

ex.dfy(28,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, x, right) =>
    (value < x) ? Node(Insert(left, value), x, right)

   |
29 |     (value < x) ? Node(Insert(left, value), x, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < x) ? Node(Insert(left, value), x, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, x, right) =>
    (value < x) ? Node(Insert(left, value), x, right)
               : Node(left, x, Insert(right, value))

   |
29 |     (value < x) ? Node(Insert(left, value), x, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['               : Node(left, x, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, x, right) =>
    (value < x) ? Node(Insert(left, value), x, right)
               : Node(left, x, Insert(right, value))
  case Empty => Node(Empty, value, Empty)

   |
29 |     (value < x) ? Node(Insert(left, value), x, right)
   |                 ^

ex.dfy(29,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['             : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :

   |
29 |     (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :
   |                         ^

ex.dfy(29,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :
    (value > nodeValue) ? Node(left, nodeValue, Insert(right, value)) :

   |
29 |     (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :
   |                         ^

ex.dfy(29,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value > nodeValue) ? Node(left, nodeValue, Insert(right, value)) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    lower < value &&
    value < upper
  case Empty => true
}

predicate BST(tree: Tree, lower: nat, upper: nat) {
  IsBST(tree, lower, upper)
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :
    (value > nodeValue) ? Node(left, nodeValue, Insert(right, value)) :
                          tree

   |
29 |     (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :
   |                         ^

ex.dfy(29,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                          tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool

SCORE
1.0
['function IsBST(t: Tree): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>

   |
11 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&

   |
12 |     IsBST(l) &&
   |                ^

ex.dfy(12,15): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&
    (l == Empty || MaxValue(l) < v) &&

   |
13 |     (l == Empty || MaxValue(l) < v) &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (l == Empty || MaxValue(l) < v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&
    (l == Empty || MaxValue(l) < v) &&
    (r == Empty || v < MinValue(r)) &&

   |
14 |     (r == Empty || v < MinValue(r)) &&
   |                                       ^

ex.dfy(14,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (r == Empty || v < MinValue(r)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&
    (l == Empty || MaxValue(l) < v) &&
    (r == Empty || v < MinValue(r)) &&
    IsBST(r)

   |
15 |     IsBST(r)
   |             ^

ex.dfy(15,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&
    (l == Empty || MaxValue(l) < v) &&
    (r == Empty || v < MinValue(r)) &&
    IsBST(r)
  case Empty => true

   |
16 |   case Empty => true
   |                     ^

ex.dfy(16,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&
    (l == Empty || MaxValue(l) < v) &&
    (r == Empty || v < MinValue(r)) &&
    IsBST(r)
  case Empty => true
}

   |
13 |     (l == Empty || MaxValue(l) < v) &&
   |                    ^^^^^^^^

ex.dfy(13,19): Error: unresolved identifier: MaxValue
   |
14 |     (r == Empty || v < MinValue(r)) &&
   |                        ^^^^^^^^

ex.dfy(14,23): Error: unresolved identifier: MinValue
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
['```dafny\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    if value < nodeValue {\n']
['      Node(Insert(left, value), nodeValue, right)\n']
['    } else if value > nodeValue {\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['function Insert(tree: Tree, value: nat): Tree\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['             : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  match tree\n']
['  case Node(left, nodeValue, right) =>\n']
['    (value < nodeValue) ? Node(Insert(left, value), nodeValue, right) :\n']
['    (value > nodeValue) ? Node(left, nodeValue, Insert(right, value)) :\n']
['                          tree\n']
['{\n']
['  match tree\n']
['  case Node(left, value, right) =>\n']
['    IsBST(left, lower, value) &&\n']
['    IsBST(right, value, upper) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&

   |
14 |     value <= upper &&
   |                      ^

ex.dfy(14,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower

   |
15 |     value >= lower
   |                   ^

ex.dfy(15,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true

   |
16 |   case Empty => true
   |                     ^

ex.dfy(16,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree

   |
23 |   match tree
   |             ^

ex.dfy(23,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>

   |
24 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(24,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue

   |
25 |     if value < nodeValue
   |                         ^

ex.dfy(25,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)

   |
26 |       then Node(Insert(left, value), nodeValue, right)
   |                                                       ^

ex.dfy(26,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue

   |
27 |     else if value > nodeValue
   |                              ^

ex.dfy(27,29): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))

   |
28 |       then Node(left, nodeValue, Insert(right, value))
   |                                                       ^

ex.dfy(28,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else

   |
29 |     else
   |         ^

ex.dfy(29,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree

   |
30 |       tree
   |           ^

ex.dfy(30,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>

   |
31 |   case Empty =>
   |                ^

ex.dfy(31,15): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)

   |
32 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(32,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool

SCORE
1.0
['function Contains(tree: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree

   |
39 |   match tree
   |             ^

ex.dfy(39,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>

   |
40 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(40,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue

   |
41 |     if value < nodeValue
   |                         ^

ex.dfy(41,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)

   |
42 |       then Contains(left, value)
   |                                 ^

ex.dfy(42,32): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue

   |
43 |     else if value > nodeValue
   |                              ^

ex.dfy(43,29): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)

   |
44 |       then Contains(right, value)
   |                                  ^

ex.dfy(44,33): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else

   |
45 |     else
   |         ^

ex.dfy(45,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true

   |
46 |       true
   |           ^

ex.dfy(46,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false

   |
47 |   case Empty => false
   |                      ^

ex.dfy(47,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

SCORE
1.0
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny

SCORE
1.0
['```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
54 | {
   |  ^

ex.dfy(54,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // This lemma is proved by structural induction on tree

   |
55 |   // This lemma is proved by structural induction on tree
   |                                                          ^

ex.dfy(55,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // This lemma is proved by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // This lemma is proved by structural induction on tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // This lemma is proved by structural induction on tree
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty
```

```dafny
// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lower: nat, upper: nat): bool
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    IsBST(right, value, upper) &&
    value <= upper &&
    value >= lower
  case Empty => true
}
```

```dafny
// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(tree: Tree, value: nat): Tree
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue
      then Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Empty =>
    Node(Empty, value, Empty)
}
```

```dafny
// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue
      then Contains(left, value)
    else if value > nodeValue
      then Contains(right, value)
    else
      true
  case Empty => false
}
```

```dafny
// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // This lemma is proved by structural induction on tree
}
```


STATS

number of nodes: 123
number of gen nodes: 62 (including leaves: 15)
number of back nodes: 61 (including leaves: 47)

expansion count: 92 (including failed: 31)

cache stats {'hit': 161, 'miss': 129}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596, 171, 445, 506]

Trial calls: [396, 435, 84, 66, 330, 71, 231, 290]


Time Statistics:

  Min: 152.00 sec, Max: 904.00 sec, Average: 481.25 sec, Standard Deviation: 289.06 sec

Call Statistics:

  Min: 66 calls, Max: 435 calls, Average: 237.88 calls, Standard Deviation: 139.72 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901]

Trial calls: [396, 435]


Time Statistics:

  Min: 901.00 sec, Max: 904.00 sec, Average: 902.50 sec, Standard Deviation: 1.50 sec

Call Statistics:

  Min: 396 calls, Max: 435 calls, Average: 415.50 calls, Standard Deviation: 19.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596, 171, 445, 506]

Trial calls: [84, 66, 330, 71, 231, 290]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 340.83 sec, Standard Deviation: 180.39 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 178.67 calls, Standard Deviation: 109.00 calls

Trial  9
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
13 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
14 |     IsBST(right, value, max)
   |                             ^

ex.dfy(14,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
20 |   match t
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
21 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(21,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
22 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(22,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
23 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(23,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
24 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(24,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
25 |     else t
   |           ^

ex.dfy(25,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{

   |
30 | {
   |  ^

ex.dfy(30,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t

   |
31 |   match t
   |          ^

ex.dfy(31,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false

   |
32 |   case Empty => false
   |                      ^

ex.dfy(32,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>

   |
33 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(33,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)

   |
34 |     if value < v then Contains(left, value)
   |                                            ^

ex.dfy(34,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)

   |
35 |     else if value > v then Contains(right, value)
   |                                                  ^

ex.dfy(35,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true

   |
36 |     else true
   |              ^

ex.dfy(36,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t

   |
44 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(44,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty

   |
45 |   // Base case: t is Empty
   |                           ^

ex.dfy(45,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {

   |
46 |   if t == Empty {
   |                  ^

ex.dfy(46,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {

   |
47 |   } else {
   |           ^

ex.dfy(47,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node

   |
48 |     // Inductive case: t is a Node
   |                                   ^

ex.dfy(48,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: t is a Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees

   |
49 |     // Recursively call the lemma on left and right subtrees
   |                                                             ^

ex.dfy(49,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);

   |
50 |     InsertEnsuresContains(t.left, value);
   |                                          ^

ex.dfy(50,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(t.left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);

   |
51 |     InsertEnsuresContains(t.right, value);
   |                                           ^

ex.dfy(51,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(t.right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }

   |
52 |   }
   |    ^

ex.dfy(52,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
59 | {
   |  ^

ex.dfy(59,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t

   |
60 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(60,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty

   |
61 |   // Base case: t is Empty
   |                           ^

ex.dfy(61,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {

   |
62 |   if t == Empty {
   |                  ^

ex.dfy(62,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {

   |
63 |   } else {
   |           ^

ex.dfy(63,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node

   |
64 |     // Inductive case: t is a Node
   |                                   ^

ex.dfy(64,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: t is a Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees

   |
65 |     // Recursively call the lemma on left and right subtrees
   |                                                             ^

ex.dfy(65,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);

   |
66 |     InsertPreservesIsBST(t.left, value, min, t.value);
   |                                                       ^

ex.dfy(66,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);

   |
67 |     InsertPreservesIsBST(t.right, value, t.value, max);
   |                                                        ^

ex.dfy(67,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);
  }

   |
68 |   }
   |    ^

ex.dfy(68,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {

   |
66 |     if value < t.value {
   |                         ^

ex.dfy(66,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < t.value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);

   |
67 |       InsertPreservesIsBST(t.left, value, min, t.value);
   |                                                         ^

ex.dfy(67,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else if value > t.value {

   |
68 |     } else if value > t.value {
   |                                ^

ex.dfy(68,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if value > t.value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesIsBST(t.right, value, t.value, max);

   |
69 |       InsertPreservesIsBST(t.right, value, t.value, max);
   |                                                          ^

ex.dfy(69,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }

   |
70 |     }
   |      ^

ex.dfy(70,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }
  }

   |
71 |   }
   |    ^

ex.dfy(71,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    if value < t.value {\n']
['      InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    } else if value > t.value {\n']
['      InsertPreservesIsBST(t.right, value, t.value, max);\n']
['    }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['\n']
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{

   |
59 | {
   |  ^

ex.dfy(59,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t

   |
60 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(60,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty

   |
61 |   // Base case: t is Empty
   |                           ^

ex.dfy(61,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {

   |
62 |   if t == Empty {
   |                  ^

ex.dfy(62,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {

   |
63 |   } else {
   |           ^

ex.dfy(63,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node

   |
64 |     // Inductive case: t is a Node
   |                                   ^

ex.dfy(64,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: t is a Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees

   |
65 |     // Recursively call the lemma on left and right subtrees
   |                                                             ^

ex.dfy(65,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);

   |
66 |     InsertPreservesIsBST(t.left, value, min, t.value);
   |                                                       ^

ex.dfy(66,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);

   |
67 |     InsertPreservesIsBST(t.right, value, t.value, max);
   |                                                        ^

ex.dfy(67,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);
  }

   |
68 |   }
   |    ^

ex.dfy(68,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires true
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesIsBST(t.left, value, min, t.value);
    InsertPreservesIsBST(t.right, value, t.value, max);
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^

ex.dfy(63,9): Error: a postcondition could not be proved on this return path
   |
63 |   } else {
   |          ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     IsBST(left, min, value) &&
   |     ^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(63,9): Error: a postcondition could not be proved on this return path
   |
63 |   } else {
   |          ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(14,4): Related location
   |
14 |     IsBST(right, value, max)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 4 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    if value < t.value {\n']
['      InsertPreservesIsBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else {

   |
68 |     } else {
   |             ^

ex.dfy(68,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else {
      InsertPreservesIsBST(t.right, value, t.value, max);

   |
69 |       InsertPreservesIsBST(t.right, value, t.value, max);
   |                                                          ^

ex.dfy(69,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }

   |
70 |     }
   |      ^

ex.dfy(70,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }
  }

   |
71 |   }
   |    ^

ex.dfy(71,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesIsBST(t.left, value, min, t.value);
    } else {
      InsertPreservesIsBST(t.right, value, t.value, max);
    }
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesIsBST(t.left, value, min, t.value);\n']
['    InsertPreservesIsBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
59 | {
   |  ^

ex.dfy(59,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t

   |
60 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(60,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty

   |
61 |   // Base case: t is Empty
   |                           ^

ex.dfy(61,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {

   |
62 |   if t == Empty {
   |                  ^

ex.dfy(62,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {

   |
63 |   } else {
   |           ^

ex.dfy(63,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node

   |
64 |     // Inductive case: t is a Node
   |                                   ^

ex.dfy(64,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: t is a Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees

   |
65 |     // Recursively call the lemma on left and right subtrees
   |                                                             ^

ex.dfy(65,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesBST(t.left, value, min, t.value);

   |
66 |     InsertPreservesBST(t.left, value, min, t.value);
   |                                                     ^

ex.dfy(66,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesBST(t.left, value, min, t.value);
    InsertPreservesBST(t.right, value, t.value, max);

   |
67 |     InsertPreservesBST(t.right, value, t.value, max);
   |                                                      ^

ex.dfy(67,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesBST(t.left, value, min, t.value);
    InsertPreservesBST(t.right, value, t.value, max);
  }

   |
68 |   }
   |    ^

ex.dfy(68,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertPreservesBST(t.left, value, min, t.value);
    InsertPreservesBST(t.right, value, t.value, max);
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesBST(t.left, value, min, t.value);\n']
['    InsertPreservesBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesBST(t.left, value, min, t.value);\n']
['    InsertPreservesBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {

   |
66 |     if value < t.value {
   |                         ^

ex.dfy(66,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < t.value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);

   |
67 |       InsertPreservesBST(t.left, value, min, t.value);
   |                                                       ^

ex.dfy(67,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);
    } else if value > t.value {

   |
68 |     } else if value > t.value {
   |                                ^

ex.dfy(68,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if value > t.value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesBST(t.right, value, t.value, max);

   |
69 |       InsertPreservesBST(t.right, value, t.value, max);
   |                                                        ^

ex.dfy(69,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesBST(t.right, value, t.value, max);
    }

   |
70 |     }
   |      ^

ex.dfy(70,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesBST(t.right, value, t.value, max);
    }
  }

   |
71 |   }
   |    ^

ex.dfy(71,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    InsertEnsuresContains(t.left, value);
    InsertEnsuresContains(t.right, value);
  }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t
  // Base case: t is Empty
  if t == Empty {
  } else {
    // Inductive case: t is a Node
    // Recursively call the lemma on left and right subtrees
    if value < t.value {
      InsertPreservesBST(t.left, value, min, t.value);
    } else if value > t.value {
      InsertPreservesBST(t.right, value, t.value, max);
    }
  }
}

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(62,16): Error: a postcondition could not be proved on this return path
   |
62 |   if t == Empty {
   |                 ^

ex.dfy(58,8): Related location: this is the postcondition that could not be proved
   |
58 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesBST(t.left, value, min, t.value);\n']
['    InsertPreservesBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesBST(t.left, value, min, t.value);\n']
['    InsertPreservesBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  // Base case: t is Empty\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive case: t is a Node\n']
['    // Recursively call the lemma on left and right subtrees\n']
['    InsertPreservesBST(t.left, value, min, t.value);\n']
['    InsertPreservesBST(t.right, value, t.value, max);\n']
['  }\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
44 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(44,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.

   |
45 |   // Base case: t is Empty.
   |                            ^

ex.dfy(45,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),

   |
46 |   //   In this case, Insert(t, value) = Node(Empty, value, Empty),
   |                                                                   ^

ex.dfy(46,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   In this case, Insert(t, value) = Node(Empty, value, Empty),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.

   |
47 |   //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
   |                                                                                           ^

ex.dfy(47,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).

   |
48 |   // Inductive case: t is Node(left, v, right).
   |                                                ^

ex.dfy(48,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: t is Node(left, v, right).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),

   |
49 |   //   If value < v, then Insert(t, value) = Insert(left, value),
   |                                                                  ^

ex.dfy(49,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value < v, then Insert(t, value) = Insert(left, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.

   |
50 |   //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
   |                                                                                    ^

ex.dfy(50,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),

   |
51 |   //   If value > v, then Insert(t, value) = Insert(right, value),
   |                                                                   ^

ex.dfy(51,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value > v, then Insert(t, value) = Insert(right, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.

   |
52 |   //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
   |                                                                                     ^

ex.dfy(52,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,

   |
53 |   //   If value = v, then Insert(t, value) = t,
   |                                                ^

ex.dfy(53,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value = v, then Insert(t, value) = t,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.

   |
54 |   //   and Contains(t, value) holds by the definition of Contains.
   |                                                                   ^

ex.dfy(54,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and Contains(t, value) holds by the definition of Contains.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
61 | {
   |  ^

ex.dfy(61,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.

   |
62 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(62,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.

   |
63 |   // Base case: t is Empty.
   |                            ^

ex.dfy(63,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: t is Empty.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),

   |
64 |   //   In this case, Insert(t, value) = Node(Empty, value, Empty),
   |                                                                   ^

ex.dfy(64,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   In this case, Insert(t, value) = Node(Empty, value, Empty),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.

   |
65 |   //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
   |                                                                                        ^

ex.dfy(65,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).

   |
66 |   // Inductive case: t is Node(left, v, right).
   |                                                ^

ex.dfy(66,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: t is Node(left, v, right).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),

   |
67 |   //   If value < v, then Insert(t, value) = Insert(left, value),
   |                                                                  ^

ex.dfy(67,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value < v, then Insert(t, value) = Insert(left, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.

   |
68 |   //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
   |                                                                                  ^

ex.dfy(68,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),

   |
69 |   //   If value > v, then Insert(t, value) = Insert(right, value),
   |                                                                   ^

ex.dfy(69,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value > v, then Insert(t, value) = Insert(right, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.

   |
70 |   //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
   |                                                                                   ^

ex.dfy(70,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,

   |
71 |   //   If value = v, then Insert(t, value) = t,
   |                                                ^

ex.dfy(71,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value = v, then Insert(t, value) = t,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and IsBST(t, min, max) holds by the precondition.

   |
72 |   //   and IsBST(t, min, max) holds by the precondition.
   |                                                         ^

ex.dfy(72,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and IsBST(t, min, max) holds by the precondition.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and IsBST(t, min, max) holds by the precondition.
}

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: t is Empty.\n']
['  //   In this case, Insert(t, value) = Node(Empty, value, Empty),\n']
['  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.\n']
['  // Inductive case: t is Node(left, v, right).\n']
['  //   If value < v, then Insert(t, value) = Insert(left, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,

   |
68 |   //   and by the inductive hypothesis and the definition of IsBST,
   |                                                                    ^

ex.dfy(68,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis and the definition of IsBST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.

   |
69 |   //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
   |                                                                         ^

ex.dfy(69,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),

   |
70 |   //   If value > v, then Insert(t, value) = Insert(right, value),
   |                                                                   ^

ex.dfy(70,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value > v, then Insert(t, value) = Insert(right, value),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis and the definition of IsBST,

   |
71 |   //   and by the inductive hypothesis and the definition of IsBST,
   |                                                                    ^

ex.dfy(71,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the inductive hypothesis and the definition of IsBST,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.

   |
72 |   //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.
   |                                                                         ^

ex.dfy(72,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,

   |
73 |   //   If value = v, then Insert(t, value) = t,
   |                                                ^

ex.dfy(73,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value = v, then Insert(t, value) = t,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and by the definition of IsBST, IsBST(t, min, max) holds.

   |
74 |   //   and by the definition of IsBST, IsBST(t, min, max) holds.
   |                                                                 ^

ex.dfy(74,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and by the definition of IsBST, IsBST(t, min, max) holds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(Insert(left, value), min, v) && IsBST(right, v, max) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis and the definition of IsBST,
  //   IsBST(left, min, v) && IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and by the definition of IsBST, IsBST(t, min, max) holds.
}

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  // Base case: t is Empty.\n']
['  //   In this case, Insert(t, value) = Node(Empty, value, Empty),\n']
['  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.\n']
['  // Inductive case: t is Node(left, v, right).\n']
['  //   If value < v, then Insert(t, value) = Insert(left, value),\n']
['  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.\n']
['  //   If value > v, then Insert(t, value) = Insert(right, value),\n']
['  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.\n']
['  //   If value = v, then Insert(t, value) = t,\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and IsBST(t, min, max) holds by the premise.

   |
72 |   //   and IsBST(t, min, max) holds by the premise.
   |                                                    ^

ex.dfy(72,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   and IsBST(t, min, max) holds by the premise.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    if value < v then Contains(left, value)
    else if value > v then Contains(right, value)
    else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and Contains(Node(Empty, value, Empty), value) holds by the definition of Contains.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, Contains(Insert(left, value), value) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, Contains(Insert(right, value), value) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and Contains(t, value) holds by the definition of Contains.
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
  // Base case: t is Empty.
  //   In this case, Insert(t, value) = Node(Empty, value, Empty),
  //   and IsBST(Node(Empty, value, Empty), min, max) holds by the definition of IsBST.
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value),
  //   and by the inductive hypothesis, IsBST(Insert(left, value), min, v) holds.
  //   If value > v, then Insert(t, value) = Insert(right, value),
  //   and by the inductive hypothesis, IsBST(Insert(right, value), v, max) holds.
  //   If value = v, then Insert(t, value) = t,
  //   and IsBST(t, min, max) holds by the premise.
}

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(61,0): Error: a postcondition could not be proved on this return path
   |
61 | {
   | ^

ex.dfy(60,8): Related location: this is the postcondition that could not be proved
   |
60 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 113
number of gen nodes: 57 (including leaves: 14)
number of back nodes: 56 (including leaves: 43)

expansion count: 86 (including failed: 30)

cache stats {'hit': 295, 'miss': 155}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596, 171, 445, 506, 921]

Trial calls: [396, 435, 84, 66, 330, 71, 231, 290, 450]


Time Statistics:

  Min: 152.00 sec, Max: 921.00 sec, Average: 530.11 sec, Standard Deviation: 305.57 sec

Call Statistics:

  Min: 66 calls, Max: 450 calls, Average: 261.44 calls, Standard Deviation: 147.64 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 921]

Trial calls: [396, 435, 450]


Time Statistics:

  Min: 901.00 sec, Max: 921.00 sec, Average: 908.67 sec, Standard Deviation: 8.81 sec

Call Statistics:

  Min: 396 calls, Max: 450 calls, Average: 427.00 calls, Standard Deviation: 22.76 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596, 171, 445, 506]

Trial calls: [84, 66, 330, 71, 231, 290]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 340.83 sec, Standard Deviation: 180.39 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 178.67 calls, Standard Deviation: 109.00 calls

Trial  10
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

SCORE
1.0
['datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(T: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T

  |
7 |   match T
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>

  |
8 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(8,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)

  |
9 |     IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  |                                                            ^

ex.dfy(9,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v) && v <= max && IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  case Leaf() => true

   |
10 |   case Leaf() => true
   |                      ^

ex.dfy(10,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  case Leaf() => true
  else false

   |
11 |   else false
   |   ^

ex.dfy(11,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  case Leaf() => true
  else false
}

   |
11 |   else false
   |   ^

ex.dfy(11,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  case Leaf() => true
  else false
}


   |
11 |   else false
   |   ^

ex.dfy(11,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
  match T
  case Node(left, v, right) =>
    IsBST(left, min, v) && v <= max && IsBST(right, v, max)
  case Leaf() => true
  else false
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property

   |
11 |   else false
   |   ^

ex.dfy(11,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T

  |
7 |     match T
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true

  |
8 |     case Leaf() => true
  |                        ^

ex.dfy(8,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
10 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&

   |
11 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)

   |
12 |         IsBST(right, value, max)
   |                                 ^

ex.dfy(12,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree

SCORE
1.0
['function Insert(T: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T

   |
18 |     match T
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())

   |
19 |     case Leaf() => Node(Leaf(), value, Leaf())
   |                                               ^

ex.dfy(19,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, nodeValue, right) =>

   |
20 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(20,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, nodeValue, right) =>
        if value < nodeValue {

   |
21 |         if value < nodeValue {
   |                              ^

ex.dfy(21,29): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, nodeValue, right) =>
        if value < nodeValue {
            Node(Insert(left, value), nodeValue, right)

   |
21 |         if value < nodeValue {
   |                              ^

ex.dfy(21,29): Error: then expected
   |
22 |             Node(Insert(left, value), nodeValue, right)
   |                                                        ^

ex.dfy(22,55): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['            Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, nodeValue, right) =>
        if value < nodeValue {
            Node(Insert(left, value), nodeValue, right)
        } else if value > nodeValue {

   |
21 |         if value < nodeValue {
   |                              ^

ex.dfy(21,29): Error: then expected
   |
23 |         } else if value > nodeValue {
   |                                     ^

ex.dfy(23,36): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        } else if value > nodeValue {\n']
['{\n']
['    match T\n']
['    case Leaf() => Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>

   |
20 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then

   |
21 |         if value < v then
   |                          ^

ex.dfy(21,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)

   |
22 |             Node(Insert(left, value), v, right)
   |                                                ^

ex.dfy(22,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then

   |
23 |         else if value > v then
   |                               ^

ex.dfy(23,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))

   |
24 |             Node(left, v, Insert(right, value))
   |                                                ^

ex.dfy(24,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else

   |
25 |         else
   |             ^

ex.dfy(25,12): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T

   |
26 |             T
   |              ^

ex.dfy(26,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool

SCORE
1.0
['function Contains(T: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T

   |
32 |     match T
   |            ^

ex.dfy(32,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false

   |
33 |     case Leaf() => false
   |                         ^

ex.dfy(33,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>

   |
34 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(34,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)

   |
35 |         if value < v then Contains(left, value)
   |                                                ^

ex.dfy(35,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)

   |
36 |         else if value > v then Contains(right, value)
   |                                                      ^

ex.dfy(36,53): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > v then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true

   |
37 |         else true
   |                  ^

ex.dfy(37,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(T: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, max_nat)

   |
42 | requires IsBST(T, 0, max_nat)
   |                      ^^^^^^^

ex.dfy(42,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['requires IsBST(T, 0, max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, max_nat)
ensures Contains(Insert(T, value), value)

   |
42 | requires IsBST(T, 0, max_nat)
   |                      ^^^^^^^

ex.dfy(42,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['ensures Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, max_nat)
ensures Contains(Insert(T, value), value)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, max_nat)
ensures Contains(Insert(T, value), value)
{
    // Proof is by structural induction on T

   |
45 |     // Proof is by structural induction on T
   |                                             ^

ex.dfy(45,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof is by structural induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, max_nat)
ensures Contains(Insert(T, value), value)
{
    // Proof is by structural induction on T
}

   |
42 | requires IsBST(T, 0, max_nat)
   |                      ^^^^^^^

ex.dfy(42,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)

SCORE
1.0
['ensures Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...

   |
45 |     // ...
   |           ^

ex.dfy(45,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // ...

   |
53 |     // ...
   |           ^

ex.dfy(53,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // ...
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // ...\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['\n']
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // ...

   |
53 |     // ...
   |           ^

ex.dfy(53,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion.
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // ...
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // ...\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
51 | {
   |  ^

ex.dfy(51,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    if value < min || value > max then

   |
52 |     if value < min || value > max then
   |                                   ^

ex.dfy(52,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < min || value > max then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    if value < min || value > max then
    {

   |
52 |     if value < min || value > max then
   |                                   ^

ex.dfy(52,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    if value < min || value > max then
    {
        assert T == Insert(T, value);

   |
52 |     if value < min || value > max then
   |                                   ^

ex.dfy(52,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        assert T == Insert(T, value);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
``` #include "gtest/gtest.h"

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "gtest/gtest.h"\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    if value < min || value > max then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    if value < min || value > max then
        assert IsBST(T, min, max) == IsBST(Insert(T, value), min, max);

   |
52 |     if value < min || value > max then
   |                                   ^

ex.dfy(52,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(T, min, max) == IsBST(Insert(T, value), min, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    if value < min || value > max then
        assert IsBST(T, min, max) == IsBST(Insert(T, value), min, max);
    else if value < max then

   |
52 |     if value < min || value > max then
   |                                   ^

ex.dfy(52,34): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value < max then\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
``` import { useState } from 'react';

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { useState } from 'react';\n"]
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
``` import {

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import {\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
```

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
51 | {
   |  ^

ex.dfy(51,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
``` 

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
```

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
}
``` <?php

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,8): Related location: this is the postcondition that could not be proved
   |
50 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['ensures Contains(Insert(T, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T

   |
45 |     // Proof by induction on T
   |                               ^

ex.dfy(45,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // Proof by induction on T

   |
53 |     // Proof by induction on T
   |                               ^

ex.dfy(53,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // Proof by induction on T
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)

SCORE
1.0
['requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // Proof by induction on T

   |
53 |     // Proof by induction on T
   |                               ^

ex.dfy(53,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires true
ensures Contains(Insert(T, value), value)
{
    // Proof by induction on T
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
requires IsBST(T, min, max)
ensures IsBST(Insert(T, value), min, max)
{
    // Proof by induction on T
}

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(52,0): Error: a postcondition could not be proved on this return path
   |
52 | {
   | ^

ex.dfy(51,8): Related location: this is the postcondition that could not be proved
   |
51 | ensures IsBST(Insert(T, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // Proof by induction on T\n']
['}\n']
['requires IsBST(T, min, max)\n']
['ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['lemma InsertEnsuresContains(T: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)

SCORE
1.0
['    ensures Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T

   |
44 |     // Proof by structural induction on T
   |                                          ^

ex.dfy(44,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by structural induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T

   |
45 |     match T
   |            ^

ex.dfy(45,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>

   |
46 |     case Leaf() =>
   |                   ^

ex.dfy(46,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value

   |
47 |         // Base case: If T is a Leaf, then the result of Insert is a Node with value
   |                                                                                     ^

ex.dfy(47,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Base case: If T is a Leaf, then the result of Insert is a Node with value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);

   |
48 |         assert Contains(Insert(Leaf(), value), value);
   |                                                       ^

ex.dfy(48,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Insert(Leaf(), value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);
    case Node(left, v, right) =>

   |
49 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(49,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);
    case Node(left, v, right) =>
        // Inductive case: If T is a Node, then the result of Insert is a Node

   |
50 |         // Inductive case: If T is a Node, then the result of Insert is a Node
   |                                                                               ^

ex.dfy(50,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Inductive case: If T is a Node, then the result of Insert is a Node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);
    case Node(left, v, right) =>
        // Inductive case: If T is a Node, then the result of Insert is a Node
        if value < v then

   |
51 |         if value < v then
   |                      ^

ex.dfy(51,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);
    case Node(left, v, right) =>
        // Inductive case: If T is a Node, then the result of Insert is a Node
        if value < v then
            assert Contains(Insert(left, value), value);

   |
51 |         if value < v then
   |                      ^

ex.dfy(51,21): Error: lbrace expected
   |
52 |             assert Contains(Insert(left, value), value);
   |                                                         ^

ex.dfy(52,56): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['            assert Contains(Insert(left, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Proof by structural induction on T
    match T
    case Leaf() =>
        // Base case: If T is a Leaf, then the result of Insert is a Node with value
        assert Contains(Insert(Leaf(), value), value);
    case Node(left, v, right) =>
        // Inductive case: If T is a Node, then the result of Insert is a Node
        if value < v then
            assert Contains(Insert(left, value), value);
        else if value > v then

   |
51 |         if value < v then
   |                      ^

ex.dfy(51,21): Error: lbrace expected
   |
53 |         else if value > v then
   |         ^

ex.dfy(53,8): Error: this symbol not expected in CaseStmt
   |
53 |         else if value > v then
   |                           ^

ex.dfy(53,26): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if value > v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...

   |
44 |     // ...
   |           ^

ex.dfy(44,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)

SCORE
1.0
['    requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['    ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{

   |
51 | {
   |  ^

ex.dfy(51,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{
    // ...

   |
52 |     // ...
   |           ^

ex.dfy(52,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertEnsuresIsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{
    // ...
}

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,12): Related location: this is the postcondition that could not be proved
   |
50 |     ensures IsBST(Insert(T, value), min, max)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,12): Related location: this is the postcondition that could not be proved
   |
50 |     ensures IsBST(Insert(T, value), min, max)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // ...\n']
['}\n']
['    ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['    requires IsBST(T, min, max)\n']
['    ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)

SCORE
1.0
['    requires IsBST(T, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)

SCORE
1.0
['    ensures IsBST(Insert(T, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{

   |
51 | {
   |  ^

ex.dfy(51,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{
    // ...

   |
52 |     // ...
   |           ^

ex.dfy(52,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // ...
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max)
    ensures IsBST(Insert(T, value), min, max)
{
    // ...
}

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,12): Related location: this is the postcondition that could not be proved
   |
50 |     ensures IsBST(Insert(T, value), min, max)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,24): Related location
   |
10 |         value >= min && value <= max &&
   |                         ^^^^^^^^^^^^

ex.dfy(51,0): Error: a postcondition could not be proved on this return path
   |
51 | {
   | ^

ex.dfy(50,12): Related location: this is the postcondition that could not be proved
   |
50 |     ensures IsBST(Insert(T, value), min, max)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,8): Related location
   |
10 |         value >= min && value <= max &&
   |         ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['    // ...\n']
['}\n']
['    ensures IsBST(Insert(T, value), min, max)\n']
['{\n']
['    // ...\n']
['}\n']
['{\n']
['    // ...\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)

SCORE
1.0
['requires IsBST(T, 0, 100)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)

SCORE
1.0
['ensures Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T

   |
45 |     // proof by structural induction on T
   |                                          ^

ex.dfy(45,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // proof by structural induction on T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T

   |
46 |     match T
   |            ^

ex.dfy(46,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match T\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T
    case Leaf() =>

   |
47 |     case Leaf() =>
   |                   ^

ex.dfy(47,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T
    case Leaf() =>
    case Node(left, v, right) =>

   |
48 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(48,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T
    case Leaf() =>
    case Node(left, v, right) =>
        if value < v then

   |
49 |         if value < v then
   |                      ^

ex.dfy(49,21): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T
    case Leaf() =>
    case Node(left, v, right) =>
        if value < v then
            InsertEnsuresContains(left, value)

   |
49 |         if value < v then
   |                      ^

ex.dfy(49,21): Error: lbrace expected
   |
50 |             InsertEnsuresContains(left, value)
   |                                               ^

ex.dfy(50,46): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['            InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // proof by structural induction on T
    match T
    case Leaf() =>
    case Node(left, v, right) =>
        if value < v then
            InsertEnsuresContains(left, value)
        else if value > v then

   |
49 |         if value < v then
   |                      ^

ex.dfy(49,21): Error: lbrace expected
   |
51 |         else if value > v then
   |         ^

ex.dfy(51,8): Error: invalid UpdateStmt
   |
51 |         else if value > v then
   |                           ^

ex.dfy(51,26): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        else if value > v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value

   |
45 |     // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
   |                                                                                   ^

ex.dfy(45,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {

   |
46 |     if T == Leaf() {
   |                     ^

ex.dfy(46,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if T == Leaf() {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());

   |
47 |         assert Insert(T, value) == Node(Leaf(), value, Leaf());
   |                                                                ^

ex.dfy(47,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Insert(T, value) == Node(Leaf(), value, Leaf());\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);

   |
48 |         assert Contains(Node(Leaf(), value, Leaf()), value);
   |                                                             ^

ex.dfy(48,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Leaf(), value, Leaf()), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }

   |
49 |     }
   |      ^

ex.dfy(49,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }
    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value

   |
50 |     // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value
   |                                                                                        ^

ex.dfy(50,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }
    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value
    else {

   |
51 |     else {
   |           ^

ex.dfy(51,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }
    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value
    else {
        var Node(left, v, right) = T;

   |
52 |         var Node(left, v, right) = T;
   |                                  ^

ex.dfy(52,33): Error: invalid VarDeclStatement
1 parse errors detected in ex.dfy

SCORE
None
['        var Node(left, v, right) = T;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }
    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value
    else {
        var Node(left, v, right) = T;
        if value < v {

   |
52 |         var Node(left, v, right) = T;
   |                                  ^

ex.dfy(52,33): Error: invalid VarDeclStatement
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(T: Tree, value: nat)
requires IsBST(T, 0, 100)
ensures Contains(Insert(T, value), value)
{
    // Base case: if T is a Leaf, then Insert(T, value) is a Node containing value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value);
    }
    // Inductive case: if T is a Node, then Insert(T, value) is a Node containing value
    else {
        var Node(left, v, right) = T;
        if value < v {
            InsertEnsuresContains(left, value);

   |
52 |         var Node(left, v, right) = T;
   |                                  ^

ex.dfy(52,33): Error: invalid VarDeclStatement
1 parse errors detected in ex.dfy

SCORE
-1.0
['            InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)

SCORE
1.0
['lemma {:invariant} ElementInserted(T: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)
{
    Contains(Insert(T, value), value)

   |
43 |     Contains(Insert(T, value), value)
   |                                      ^

ex.dfy(43,37): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)
{
    Contains(Insert(T, value), value)
}

   |
43 |     Contains(Insert(T, value), value)
   |     ^^^^^^^^

ex.dfy(43,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)
{
    Contains(Insert(T, value), value)
}


   |
43 |     Contains(Insert(T, value), value)
   |     ^^^^^^^^

ex.dfy(43,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property)
lemma {:invariant} ElementInserted(T: Tree, value: nat)
{
    Contains(Insert(T, value), value)
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.

   |
43 |     Contains(Insert(T, value), value)
   |     ^^^^^^^^

ex.dfy(43,4): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
['{\n']
['    Contains(Insert(T, value), value)\n']
['}\n']
['\n']
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)

SCORE
1.0
['lemma {:induction} Insert_Contains(T: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)

SCORE
1.0
['    ensures Contains(Insert(T, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value

   |
44 |     // Base case: If T is a leaf, the new tree is a node with the inserted value
   |                                                                                 ^

ex.dfy(44,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If T is a leaf, the new tree is a node with the inserted value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {

   |
45 |     if T == Leaf() {
   |                     ^

ex.dfy(45,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if T == Leaf() {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());

   |
46 |         assert Insert(T, value) == Node(Leaf(), value, Leaf());
   |                                                                ^

ex.dfy(46,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Insert(T, value) == Node(Leaf(), value, Leaf());\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;

   |
47 |         assert Contains(Node(Leaf(), value, Leaf()), value) == true;
   |                                                                     ^

ex.dfy(47,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Leaf(), value, Leaf()), value) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {

   |
48 |     } else {
   |             ^

ex.dfy(48,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree

   |
49 |         // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
   |                                                                                                   ^

ex.dfy(49,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {

   |
50 |         match T {
   |                  ^

ex.dfy(50,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match T {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>

   |
51 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(51,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {

   |
52 |             if value < v {
   |                           ^

ex.dfy(52,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;

   |
53 |                 assert Contains(Insert(left, value), value) == true;
   |                                                                     ^

ex.dfy(53,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert Contains(Insert(left, value), value) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {

   |
54 |             } else if value > v {
   |                                  ^

ex.dfy(54,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;

   |
55 |                 assert Contains(Insert(right, value), value) == true;
   |                                                                      ^

ex.dfy(55,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert Contains(Insert(right, value), value) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {

   |
56 |             } else {
   |                     ^

ex.dfy(56,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;

   |
57 |                 assert Contains(T, value) == true;
   |                                                   ^

ex.dfy(57,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert Contains(T, value) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }

   |
58 |             }
   |              ^

ex.dfy(58,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }

   |
59 |         }
   |          ^

ex.dfy(59,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }

   |
60 |     }
   |      ^

ex.dfy(60,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true

SCORE
1.0
['    requires IsBST(T, min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true

SCORE
1.0
['    ensures IsBST(Insert(T, value), min, max) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{

   |
67 | {
   |  ^

ex.dfy(67,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds

   |
68 |     // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
   |                                                                                                             ^

ex.dfy(68,108): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {

   |
69 |     if T == Leaf() {
   |                     ^

ex.dfy(69,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if T == Leaf() {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());

   |
70 |         assert Insert(T, value) == Node(Leaf(), value, Leaf());
   |                                                                ^

ex.dfy(70,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Insert(T, value) == Node(Leaf(), value, Leaf());\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;

   |
71 |         assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
   |                                                                     ^

ex.dfy(71,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {

   |
72 |     } else {
   |             ^

ex.dfy(72,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree

   |
73 |         // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
   |                                                                                                   ^

ex.dfy(73,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {

   |
74 |         match T {
   |                  ^

ex.dfy(74,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match T {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>

   |
75 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(75,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {

   |
76 |             if value < v {
   |                           ^

ex.dfy(76,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;

   |
77 |                 assert IsBST(Insert(left, value), min, v) == true;
   |                                                                   ^

ex.dfy(77,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(Insert(left, value), min, v) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {

   |
78 |             } else if value > v {
   |                                  ^

ex.dfy(78,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;

   |
79 |                 assert IsBST(Insert(right, value), v, max) == true;
   |                                                                    ^

ex.dfy(79,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(Insert(right, value), v, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {

   |
80 |             } else {
   |                     ^

ex.dfy(80,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;

   |
81 |                 assert IsBST(T, min, max) == true;
   |                                                   ^

ex.dfy(81,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(T, min, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }

   |
82 |             }
   |              ^

ex.dfy(82,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }

   |
83 |         }
   |          ^

ex.dfy(83,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }
    }

   |
84 |     }
   |      ^

ex.dfy(84,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value, and the BST property holds
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }
    }
}

ex.dfy(71,15): Error: assertion might not hold
   |
71 |         assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value

   |
68 |     // Base case: If T is a leaf, the new tree is a node with the inserted value
   |                                                                                 ^

ex.dfy(68,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If T is a leaf, the new tree is a node with the inserted value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {

   |
69 |     if T == Leaf() {
   |                     ^

ex.dfy(69,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if T == Leaf() {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());

   |
70 |         assert Insert(T, value) == Node(Leaf(), value, Leaf());
   |                                                                ^

ex.dfy(70,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Insert(T, value) == Node(Leaf(), value, Leaf());\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;

   |
71 |         assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
   |                                                                     ^

ex.dfy(71,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {

   |
72 |     } else {
   |             ^

ex.dfy(72,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree

   |
73 |         // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
   |                                                                                                   ^

ex.dfy(73,98): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {

   |
74 |         match T {
   |                  ^

ex.dfy(74,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match T {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>

   |
75 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(75,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {

   |
76 |             if value < v {
   |                           ^

ex.dfy(76,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;

   |
77 |                 assert IsBST(Insert(left, value), min, v) == true;
   |                                                                   ^

ex.dfy(77,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(Insert(left, value), min, v) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {

   |
78 |             } else if value > v {
   |                                  ^

ex.dfy(78,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;

   |
79 |                 assert IsBST(Insert(right, value), v, max) == true;
   |                                                                    ^

ex.dfy(79,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(Insert(right, value), v, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {

   |
80 |             } else {
   |                     ^

ex.dfy(80,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;

   |
81 |                 assert IsBST(T, min, max) == true;
   |                                                   ^

ex.dfy(81,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                assert IsBST(T, min, max) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }

   |
82 |             }
   |              ^

ex.dfy(82,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }

   |
83 |         }
   |          ^

ex.dfy(83,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }
    }

   |
84 |     }
   |      ^

ex.dfy(84,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(T: Tree, min: nat, max: nat): bool
{
    match T
    case Leaf() => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property
function Insert(T: Tree, value: nat): Tree
{
    match T
    case Leaf() => Node(Leaf(), value, Leaf())
    case Node(left, v, right) =>
        if value < v then
            Node(Insert(left, value), v, right)
        else if value > v then
            Node(left, v, Insert(right, value))
        else
            T
}

// (4) Write a predicate that checks whether a given tree contains a given element
function Contains(T: Tree, value: nat): bool
{
    match T
    case Leaf() => false
    case Node(left, v, right) =>
        if value < v then Contains(left, value)
        else if value > v then Contains(right, value)
        else true
}

// (5) Write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma {:induction} Insert_Contains(T: Tree, value: nat)
    ensures Contains(Insert(T, value), value)
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert Contains(Node(Leaf(), value, Leaf()), value) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert Contains(Insert(left, value), value) == true;
            } else if value > v {
                assert Contains(Insert(right, value), value) == true;
            } else {
                assert Contains(T, value) == true;
            }
        }
    }
}

// (6) Write another lemma about the insert function that checks the BST property continues to hold after insertion
lemma {:induction} Insert_IsBST(T: Tree, value: nat, min: nat, max: nat)
    requires IsBST(T, min, max) == true
    ensures IsBST(Insert(T, value), min, max) == true
{
    // Base case: If T is a leaf, the new tree is a node with the inserted value
    if T == Leaf() {
        assert Insert(T, value) == Node(Leaf(), value, Leaf());
        assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
    } else {
        // Recursive case: If T is a node, recursively call the lemma on the left or right subtree
        match T {
        case Node(left, v, right) =>
            if value < v {
                assert IsBST(Insert(left, value), min, v) == true;
            } else if value > v {
                assert IsBST(Insert(right, value), v, max) == true;
            } else {
                assert IsBST(T, min, max) == true;
            }
        }
    }
}

ex.dfy(71,15): Error: assertion might not hold
   |
71 |         assert IsBST(Node(Leaf(), value, Leaf()), min, max) == true;
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 215
number of gen nodes: 108 (including leaves: 32)
number of back nodes: 107 (including leaves: 76)

expansion count: 180 (including failed: 73)

cache stats {'hit': 208, 'miss': 238}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 175, 152, 596, 171, 445, 506, 921, 927]

Trial calls: [396, 435, 84, 66, 330, 71, 231, 290, 450, 446]


Time Statistics:

  Min: 152.00 sec, Max: 927.00 sec, Average: 569.80 sec, Standard Deviation: 313.39 sec

Call Statistics:

  Min: 66 calls, Max: 450 calls, Average: 279.90 calls, Standard Deviation: 150.61 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [904, 901, 921, 927]

Trial calls: [396, 435, 450, 446]


Time Statistics:

  Min: 901.00 sec, Max: 927.00 sec, Average: 913.25 sec, Standard Deviation: 11.01 sec

Call Statistics:

  Min: 396 calls, Max: 450 calls, Average: 431.75 calls, Standard Deviation: 21.36 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [175, 152, 596, 171, 445, 506]

Trial calls: [84, 66, 330, 71, 231, 290]


Time Statistics:

  Min: 152.00 sec, Max: 596.00 sec, Average: 340.83 sec, Standard Deviation: 180.39 sec

Call Statistics:

  Min: 66 calls, Max: 330 calls, Average: 178.67 calls, Standard Deviation: 109.00 calls

To complete all experiments, 95 minutes and 38 seconds elapsed.


