

========
Experiment configuration: python experiments.py --experiment_name run_diversity.py --n_trials 10 --mins_timeout 12 --language Dafny --problem_name problem_bst --seed 42 --same_for_many_samples False 


[2024-01-13 08:47:11,572] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = 

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers.\n', 'datatype Tree = \n', '// (1) ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n', '// (1) Define an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Node(value: nat, left: Tree, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(value: nat, left: Tree, right: Tree)\n', '  | Empty\n', '    | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

SCORE
1.0
['\n', '\n', '\n', '\n', '```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate for checking whether a tree is a binary search tree.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define the predicate for being a binary search tree.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate to check if a given tree is a binary search tree.

SCORE
1.0
['// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).\n', '// (2) Define a predicate that checks whether a given tree is a binary search tree.\n', '// (2) Define a predicate for checking whether a tree is a binary search tree.\n', '// (2) Define the predicate for being a binary search tree.\n', '// (2) Define a predicate to check if a given tree is a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(tree: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['function IsBST(tree: Tree, min: nat, max: nat): bool\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t

  |
9 |   reads t
  |         ^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '  reads t\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t

   |
11 |   match t
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true

   |
12 |   case Empty => true
   |                     ^

ex.dfy(12,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
13 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>

   |
13 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(13,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(l, v, r) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= lower && v <= upper &&

   |
14 |     v >= lower && v <= upper &&
   |                                ^

ex.dfy(14,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    l == Empty || (v > lower && IsBST(l, lower, v)) &&

   |
14 |     l == Empty || (v > lower && IsBST(l, lower, v)) &&
   |                                                     ^^

ex.dfy(14,52): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     l == Empty || (v > lower && IsBST(l, lower, v)) &&
   |                                                       ^

ex.dfy(14,54): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    l != null && r != null &&

   |
14 |     l != null && r != null &&
   |                              ^

ex.dfy(14,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= lower && v <= upper &&\n', '    l == Empty || (v > lower && IsBST(l, lower, v)) &&\n', '    v >= lower && v <= upper &&\n', '    l != null && r != null &&\n', '    v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    l == Empty || (v > lower && IsBST(l, lower, v)) &&
    r == Empty || (v < upper && IsBST(r, v, upper))

   |
14 |     l == Empty || (v > lower && IsBST(l, lower, v)) &&
   |                                                     ^^

ex.dfy(14,52): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
15 |     r == Empty || (v < upper && IsBST(r, v, upper))
   |                                                    ^

ex.dfy(15,51): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    r == Empty || (v < upper && IsBST(r, v, upper))\n', '    r == Empty || (v < upper && IsBST(r, v, upper))\n', '    r == Empty || (v < upper && IsBST(r, v, upper))\n', '    r == Empty || (v < upper && IsBST(r, v, upper))\n', '    r == Empty || (v < upper && IsBST(r, v, upper))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    l == Empty || (v > lower && IsBST(l, lower, v)) &&
    r == Empty || (v < upper && IsBST(r, v, upper))
}

   |
14 |     l == Empty || (v > lower && IsBST(l, lower, v)) &&
   |                                                     ^^

ex.dfy(14,52): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  reads t\n', '{\n', '  reads t\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true

   |
11 |   case Empty => true
   |                     ^

ex.dfy(11,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&

   |
13 |     value >= lower && value < upper &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
13 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value <= upper && value >= lower &&

   |
13 |     value <= upper && value >= lower &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value < upper &&\n', '    value >= lower && value <= upper &&\n', '    value >= lower && value < upper &&\n', '    value <= upper && value >= lower &&\n', '    value >= lower && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&

   |
14 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(14,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
15 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(15,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n', '    IsBST(right, value, upper)\n', '    IsBST(right, value, upper)\n', '    IsBST(right, value, upper)\n', '    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}
```

SCORE
1.0
['\n', '```\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

predicate BST(t: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function IsBST(t: Tree): bool

   |
18 | function IsBST(t: Tree): bool
   |          ^^^^^

ex.dfy(18,9): Error: Duplicate member name: IsBST
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

predicate IsBST(t: Tree) = IsBST(t, 0, nat.MaxInt);

   |
18 | predicate IsBST(t: Tree) = IsBST(t, 0, nat.MaxInt);
   |                          ^

ex.dfy(18,25): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// Lemma: If IsBST(t, lower, upper) is true, then IsBST(t, lower, upper + 1) is also true.

SCORE
1.0
['predicate BST(t: Tree)\n', 'function IsBST(t: Tree): bool\n', 'lemma IsBST_Empty(lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree) = IsBST(t, 0, nat.MaxInt);\n', '// Lemma: If IsBST(t, lower, upper) is true, then IsBST(t, lower, upper + 1) is also true.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper);

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

SCORE
1.0
['  ensures IsBST(Empty, lower, upper);\n', '  ensures IsBST(Empty, lower, upper);\n', '  ensures IsBST(Empty, lower, upper) == true;\n', '  ensures IsBST(Empty, lower, upper);\n', '  ensures IsBST(Empty, lower, upper) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;
lemma IsBST_Node(t: Tree, lower: nat, value: nat, upper: nat, left: Tree, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;


SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;
lemma IsBST_Node(t: Tree, value: nat, lower: nat, upper: nat, left: Tree, right: Tree)

SCORE
1.0
['lemma IsBST_Node(t: Tree, lower: nat, value: nat, upper: nat, left: Tree, right: Tree)\n', '\n', '\n', 'lemma IsBST_Node(t: Tree, value: nat, lower: nat, upper: nat, left: Tree, right: Tree)\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(t: Tree, lower: nat, upper: nat, value: nat)

SCORE
1.0
['lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)\n', 'lemma IsBST_Node(t: Tree, lower: nat, upper: nat, value: nat)\n', 'lemma IsBST_Node(t: Tree, lower: nat, upper: nat, value: nat)\n', 'lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)\n', 'lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) && IsBST(right, value, upper) &&

   |
19 |   ensures IsBST(Empty, lower, upper) == true;
   |                                             ^

ex.dfy(19,44): Warning: deprecated style: a semi-colon is not needed here
   |
22 |   requires IsBST(left, lower, value) && IsBST(right, value, upper) &&
   |                                                                      ^

ex.dfy(22,69): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) && IsBST(right, value, upper)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) &&

   |
19 |   ensures IsBST(Empty, lower, upper) == true;
   |                                             ^

ex.dfy(19,44): Warning: deprecated style: a semi-colon is not needed here
   |
22 |   requires IsBST(left, lower, value) &&
   |                                        ^

ex.dfy(22,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['  requires IsBST(left, lower, value) && IsBST(right, value, upper) &&\n', '  requires IsBST(left, lower, value) && IsBST(right, value, upper)\n', '  requires IsBST(left, lower, value) &&\n', '  requires IsBST(left, lower, value) && IsBST(right, value, upper)\n', '  requires IsBST(left, lower, value) && IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) && IsBST(right, value, upper)
  ensures IsBST(Node(left, value, right), lower, upper) == true;

SCORE
1.0
['  ensures IsBST(Node(left, value, right), lower, upper) == true;\n', '  ensures IsBST(Node(left, value, right), lower, upper) == true;\n', '  ensures IsBST(Node(left, value, right), lower, upper) == true;\n', '  ensures IsBST(Node(left, value, right), lower, upper) == true;\n', '  ensures IsBST(Node(left, value, right), lower, upper) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) && IsBST(right, value, upper)
  ensures IsBST(Node(left, value, right), lower, upper) == true;
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)
```

```dafny
// (2) Define a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value < upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

lemma IsBST_Empty(lower: nat, upper: nat)
  ensures IsBST(Empty, lower, upper) == true;

lemma IsBST_Node(left: Tree, value: nat, right: Tree, lower: nat, upper: nat)
  requires IsBST(left, lower, value) && IsBST(right, value, upper)
  ensures IsBST(Node(left, value, right), lower, upper) == true;
```


STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 1)
number of back nodes: 17 (including leaves: 17)

expansion count: 18 (including failed: 1)

cache stats {'hit': 98, 'miss': 67}
calls to generate 33
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define the tree ADT\n', '// (1) Define an ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n', '// (1) Define the ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Leaf()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Node(value: nat, left: Tree, right: Tree) | Leaf()\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define the predicate for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define the predicate IsBST

SCORE
1.0
['// (2) Define the predicate for BST\n', '// (2) Define the predicate for BST\n', '// (2) Define a predicate for BST\n', '// (2) Define the predicate for BST\n', '// (2) Define the predicate IsBST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
function IsBST(tree: Tree, lo: nat, hi: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'function IsBST(tree: Tree, lo: nat, hi: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t

  |
7 |     match t
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true

  |
8 |     case Leaf => true
  |                      ^

ex.dfy(8,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, v, right) =>

  |
8 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(8,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(l, v, r) =>

  |
8 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(8,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)

  |
8 |     case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)
  |                                                                                               ^

ex.dfy(8,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Node(left, v, right) =>\n', '    case Node(l, v, r) =>\n', '    case Leaf => true\n', '    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>

  |
9 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>

  |
9 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(9,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        l == Leaf || IsBST(l, min, v)

   |
10 |         l == Leaf || IsBST(l, min, v)
   |                                      ^

ex.dfy(10,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        v >= min && v <= max &&

   |
10 |         v >= min && v <= max &&
   |                                ^

ex.dfy(10,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        l == Leaf || IsBST(l, min, v)\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        l == Leaf || IsBST(l, min, v)
        && v <= max

   |
11 |         && v <= max
   |         ^^

ex.dfy(11,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         && v <= max
   |                    ^

ex.dfy(11,19): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        l == Leaf || IsBST(l, min, v)
        && v >= min && v <= max

   |
11 |         && v >= min && v <= max
   |         ^^

ex.dfy(11,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         && v >= min && v <= max
   |                     ^^

ex.dfy(11,20): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         && v >= min && v <= max
   |                                ^

ex.dfy(11,31): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['        && v <= max\n', '        && v >= min && v <= max\n', '        && v <= max\n', '        && v <= max\n', '        && v <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        l == Leaf || IsBST(l, min, v)
        && v >= min && v <= max
        && r == Leaf || IsBST(r, v, max)

   |
11 |         && v >= min && v <= max
   |         ^^

ex.dfy(11,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         && v >= min && v <= max
   |                     ^^

ex.dfy(11,20): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         && r == Leaf || IsBST(r, v, max)
   |         ^^

ex.dfy(12,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         && r == Leaf || IsBST(r, v, max)
   |                                         ^

ex.dfy(12,40): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
['        && r == Leaf || IsBST(r, v, max)\n', '        && r == Leaf || IsBST(r, v, max)\n', '        && r == Leaf || IsBST(r, v, max)\n', '        && r == Leaf || IsBST(r, v, max)\n', '        && r == Leaf || IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(l, v, r) =>
        l == Leaf || IsBST(l, min, v)
        && v >= min && v <= max
        && r == Leaf || IsBST(r, v, max)
}

   |
11 |         && v >= min && v <= max
   |         ^^

ex.dfy(11,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         && v >= min && v <= max
   |                     ^^

ex.dfy(11,20): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         && r == Leaf || IsBST(r, v, max)
   |         ^^

ex.dfy(12,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
3 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(l, v, r) =>

  |
8 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(8,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>

  |
8 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(8,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Node(l, v, r) =>\n', '  case Leaf => true\n', '  case Node(l, v, r) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&

  |
9 |     IsBST(left, min, value) &&
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&

  |
9 |     value >= min && value <= max &&
  |                                    ^

ex.dfy(9,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    value >= min && value <= max &&\n', '    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    value <= max &&

   |
10 |     value <= max &&
   |                    ^

ex.dfy(10,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds

   |
10 |     min <= value <= max && // value is within the bounds
   |                                                         ^

ex.dfy(10,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max &&

   |
10 |     min <= value <= max &&
   |                           ^

ex.dfy(10,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    value <= max &&\n', '    min <= value <= max && // value is within the bounds\n', '    value <= max &&\n', '    min <= value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)

   |
11 |     IsBST(right, value, max)
   |                             ^

ex.dfy(11,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true

   |
12 |   case Leaf => true
   |                    ^

ex.dfy(12,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define the insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function for insertion

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element into a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element

SCORE
1.0
['// (3) Define the insert function\n', '// (3) Define a function for insertion\n', '// (3) Define a function to insert an element into a BST\n', '// (3) Define a function to insert an element\n', '// (3) Define the insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then

   |
18 |   if t == Leaf then
   |                    ^

ex.dfy(18,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else

   |
18 |   if t == Leaf then Node(Leaf, value, Leaf) else
   |                                                 ^

ex.dfy(18,48): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf)

   |
18 |   if t == Leaf then Node(Leaf, value, Leaf)
   |                                            ^

ex.dfy(18,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf then\n', '  match t\n', '  if t == Leaf then Node(Leaf, value, Leaf) else\n', '  if t == Leaf then Node(Leaf, value, Leaf)\n', '  if t == Leaf then Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then

   |
19 |   if value < t.value then
   |                          ^

ex.dfy(19,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then Node(Insert(t.left, value), t.value, t.right) else

   |
19 |   if value < t.value then Node(Insert(t.left, value), t.value, t.right) else
   |                                                                             ^

ex.dfy(19,76): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if value < t.value then\n', '  match t\n', '  match t\n', '  match t\n', '  if value < t.value then Node(Insert(t.left, value), t.value, t.right) else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)

   |
20 |     Node(Insert(t.left, value), t.value, t.right)
   |                                                  ^

ex.dfy(20,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Insert(t.left, value), t.value, t.right)\n', '    Node(Insert(t.left, value), t.value, t.right)\n', '    Node(Insert(t.left, value), t.value, t.right)\n', '    Node(Insert(t.left, value), t.value, t.right)\n', '    Node(Insert(t.left, value), t.value, t.right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else if value > t.value then

   |
21 |   else if value > t.value then
   |                               ^

ex.dfy(21,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else

   |
21 |   else
   |       ^

ex.dfy(21,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else if value > t.value then\n', '  else\n', '  else\n', '  else if value > t.value then\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))

   |
22 |     Node(t.left, t.value, Insert(t.right, value))
   |                                                  ^

ex.dfy(22,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(t.left, t.value, Insert(t.right, value))\n', '    Node(t.left, t.value, Insert(t.right, value))\n', '    Node(t.left, t.value, Insert(t.right, value))\n', '    Node(t.left, t.value, Insert(t.right, value))\n', '    Node(t.left, t.value, Insert(t.right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if an element is in the tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains a value

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element

SCORE
1.0
['// (4) Define a predicate to check if an element is in the tree\n', '// (4) Define a predicate to check if a tree contains a value\n', '// (4) Define a predicate to check if a tree contains a value\n', '// (4) Define a predicate to check if a tree contains an element\n', '// (4) Define a predicate to check if a tree contains an element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t

   |
28 |   match t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>

   |
29 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(29,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :

   |
30 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))

   |
30 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(30,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (v > value && Contains(left, value)) || (v < value && Contains(right, value))

   |
30 |     (v == value) || (v > value && Contains(left, value)) || (v < value && Contains(right, value))
   |                                                                                                  ^

ex.dfy(30,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)

   |
30 |     (v == value) || Contains(left, value) || Contains(right, value)
   |                                                                    ^

ex.dfy(30,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) :\n', '    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))\n', '    (v == value) || (v > value && Contains(left, value)) || (v < value && Contains(right, value))\n', '    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))\n', '    (v == value) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false

   |
30 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(30,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false
}

   |
30 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(30,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value == v) || (value < v ? Contains(left, value) : Contains(right, value))

   |
30 |     (value == v) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(30,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||

   |
30 |     (v == value) ||
   |                    ^

ex.dfy(30,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || Contains(left, value) || Contains(right, value)\n', '    (value == v) || (value < v ? Contains(left, value) : Contains(right, value))\n', '    (v == value) ||\n', '    (v == value) ||\n', '    (v == value) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||

   |
31 |     (v > value && Contains(left, value)) ||
   |                                            ^

ex.dfy(31,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value ? Contains(left, value) : Contains(right, value))

   |
31 |     (v > value ? Contains(left, value) : Contains(right, value))
   |                ^

ex.dfy(31,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value ? false : Contains(left, value)) ||

   |
31 |     (v > value ? false : Contains(left, value)) ||
   |                ^

ex.dfy(31,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v > value && Contains(left, value)) ||\n', '    (v > value ? Contains(left, value) : Contains(right, value))\n', '    (v > value && Contains(left, value)) ||\n', '    (v > value ? Contains(left, value) : Contains(right, value))\n', '    (v > value ? false : Contains(left, value)) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))

   |
32 |     (v < value && Contains(right, value))
   |                                          ^

ex.dfy(32,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value && Contains(right, value))\n', '    (v < value && Contains(right, value))\n', '    (v < value && Contains(right, value))\n', '    (v < value && Contains(right, value))\n', '    (v < value && Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false

   |
33 |   case Leaf => false
   |                     ^

ex.dfy(33,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about insertion maintaining the Contains property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the element is in the resulting tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Define a lemma about Insert function without requiring BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Define a lemma about the insert function without bounds

SCORE
1.0
['// (5) Lemma about the insert function preserving the element\n', '// (5) Lemma about insertion maintaining the Contains property\n', '// (5) Define a lemma about the insert function that ensures the element is in the resulting tree\n', '// (5) Define a lemma about Insert function without requiring BST property\n', '// (5) Define a lemma about the insert function without bounds\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma InsertPreservesElement(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma PreservesElement(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesElement(t: Tree, value: nat)\n', 'lemma InsertPreservesElement(t: Tree, value: nat)\n', 'lemma PreservesElement(t: Tree, value: nat)\n', 'lemma PreservesElement(t: Tree, value: nat)\n', 'lemma {:auto} InsertPreservesElement(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['{\n', '{\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is Leaf, then value is inserted directly

   |
40 |   // Base case: if t is Leaf, then value is inserted directly
   |                                                              ^

ex.dfy(40,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Structural induction on t

   |
40 |   // Structural induction on t
   |                               ^

ex.dfy(40,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // base case

   |
40 |   // base case
   |               ^

ex.dfy(40,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t

   |
40 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(40,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case

   |
40 |   // Base case
   |               ^

ex.dfy(40,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if t is Leaf, then value is inserted directly\n', '  // Structural induction on t\n', '  // base case\n', '  // Proof by structural induction on t\n', '  // Base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf then

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf {

   |
41 |   if t == Leaf {
   |                 ^

ex.dfy(41,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf then\n', '  if t == Leaf then\n', '  if t == Leaf then\n', '  if t == Leaf {\n', '  if t == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf then
  {

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf then
    Contains(Node(Leaf, value, Leaf), value) // Reflexive case

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf then
    assert Contains(Node(Leaf, value, Leaf), value);

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '    Contains(Node(Leaf, value, Leaf), value) // Reflexive case\n', '    assert Contains(Node(Leaf, value, Leaf), value);\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case
  if t == Leaf then
    assert Contains(Node(Leaf, value, Leaf), value);
  else

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: if t is a Leaf, it's clear that the element is in the new tree.

   |
40 |   // Base case: if t is a Leaf, it's clear that the element is in the new tree.
   |                                                                                ^

ex.dfy(40,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases

   |
40 |   // Base cases
   |                ^

ex.dfy(40,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
40 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(40,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural recursion on t

   |
40 |   // Proof by structural recursion on t
   |                                        ^

ex.dfy(40,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["  // Base case: if t is a Leaf, it's clear that the element is in the new tree.\n", '  // Base cases\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural recursion on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Leaf {

   |
41 |   if t == Leaf {
   |                 ^

ex.dfy(41,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Leaf then

   |
41 |   if t == Leaf then
   |                ^

ex.dfy(41,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

SCORE
1.0
['  if t == Leaf {\n', '  if t == Leaf then\n', '}\n', '  if t == Leaf then\n', '  if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function maintaining the BST property

SCORE
1.0
['// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function maintaining the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.

   |
48 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(48,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,10): Related location: this is the postcondition that could not be proved
   |
46 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     min <= value <= max && // value is within the bounds
   |     ^^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,10): Related location: this is the postcondition that could not be proved
   |
46 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,11): Related location
   |
10 |     min <= value <= max && // value is within the bounds
   |            ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.

   |
48 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(48,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

// (2) Define a predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&
    min <= value <= max && // value is within the bounds
    IsBST(right, value, max)
  case Leaf => true
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf then Node(Leaf, value, Leaf) else
  if value < t.value then
    Node(Insert(t.left, value), t.value, t.right)
  else
    Node(t.left, t.value, Insert(t.right, value))
}

// (4) Define a predicate to check if a tree contains an element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) ||
    (v > value && Contains(left, value)) ||
    (v < value && Contains(right, value))
  case Leaf => false
}

// (5) Lemma about the insert function preserving the element
lemma {:auto} InsertPreservesElement(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

// (6) Lemma about the insert function preserving the BST property
lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on t.
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,10): Related location: this is the postcondition that could not be proved
   |
46 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     min <= value <= max && // value is within the bounds
   |     ^^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,10): Related location: this is the postcondition that could not be proved
   |
46 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,11): Related location
   |
10 |     min <= value <= max && // value is within the bounds
   |            ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n', '// (6) Lemma about the insert function preserving the BST property\n']
['lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n', '  // Proof by structural induction on t.\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 75
number of gen nodes: 38 (including leaves: 7)
number of back nodes: 37 (including leaves: 31)

expansion count: 54 (including failed: 17)

cache stats {'hit': 471, 'miss': 129}
calls to generate 120
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729]

Trial calls: [165, 600]


Time Statistics:

  Min: 236.00 sec, Max: 729.00 sec, Average: 482.50 sec, Standard Deviation: 246.50 sec

Call Statistics:

  Min: 165 calls, Max: 600 calls, Average: 382.50 calls, Standard Deviation: 217.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729]

Trial calls: [600]


Time Statistics:

  Min: 729.00 sec, Max: 729.00 sec, Average: 729.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 600 calls, Max: 600 calls, Average: 600.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

Trial  3
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['// (1) ADT for a tree\n', '// (1) Define an ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n', '// (1) Define an ADT for a tree of natural numbers\n', 'datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null()

SCORE
1.0
['datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', 'datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf

SCORE
1.0
['  | Nil\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Empty\n', '  | Empty\n', '  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat) \n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true

   |
11 |   case Leaf => true
   |                    ^

ex.dfy(11,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

   |
12 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    lo < value && value < hi &&

   |
13 |     lo < value && value < hi &&
   |                                ^

ex.dfy(13,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lo && value <= hi &&

   |
13 |     value >= lo && value <= hi &&
   |                                  ^

ex.dfy(13,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lo < value && value < hi &&\n', '    lo < value && value < hi &&\n', '    value >= lo && value <= hi &&\n', '    value >= lo && value <= hi &&\n', '    lo < value && value < hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    lo < value && value < hi &&
    IsBST(left, lo, value) &&

   |
14 |     IsBST(left, lo, value) &&
   |                              ^

ex.dfy(14,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lo, value) &&\n', '    IsBST(left, lo, value) &&\n', '    IsBST(left, lo, value) &&\n', '    IsBST(left, lo, value) &&\n', '    IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    lo < value && value < hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)

   |
15 |     IsBST(right, value, hi)
   |                            ^

ex.dfy(15,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, hi)\n', '    IsBST(right, value, hi)\n', '    IsBST(right, value, hi)\n', '    IsBST(right, value, hi)\n', '    IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    lo < value && value < hi &&
    IsBST(left, lo, value) &&
    IsBST(right, value, hi)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>

   |
11 |   case Node(left, x, right) =>
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, x, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    x >= lo && x <= hi &&

   |
12 |     x >= lo && x <= hi &&
   |                          ^

ex.dfy(12,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    x >= lo &&

   |
12 |     x >= lo &&
   |               ^

ex.dfy(12,14): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)

   |
12 |     left == Leaf || IsBST(left, lo, x - 1)
   |                                           ^

ex.dfy(12,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    lo < x && x < hi &&

   |
12 |     lo < x && x < hi &&
   |                        ^

ex.dfy(12,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    x >= lo && x <= hi &&\n', '    x >= lo &&\n', '    x >= lo && x <= hi &&\n', '    left == Leaf || IsBST(left, lo, x - 1)\n', '    lo < x && x < hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)
    && IsBST(right, x + 1, hi)

   |
13 |     && IsBST(right, x + 1, hi)
   |     ^^

ex.dfy(13,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     && IsBST(right, x + 1, hi)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)
    && x <= hi + 1

   |
13 |     && x <= hi + 1
   |     ^^

ex.dfy(13,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     && x <= hi + 1
   |                   ^

ex.dfy(13,18): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    && IsBST(right, x + 1, hi)\n', '    && IsBST(right, x + 1, hi)\n', '    && x <= hi + 1\n', '    && IsBST(right, x + 1, hi)\n', '    && IsBST(right, x + 1, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)
    && x <= hi + 1
    && right == Leaf || IsBST(right, x + 1, hi)

   |
13 |     && x <= hi + 1
   |     ^^

ex.dfy(13,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     && right == Leaf || IsBST(right, x + 1, hi)
   |     ^^

ex.dfy(14,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     && right == Leaf || IsBST(right, x + 1, hi)
   |                                                ^

ex.dfy(14,47): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)
    && x <= hi + 1
    && (right == Leaf || IsBST(right, x + 1, hi))

   |
13 |     && x <= hi + 1
   |     ^^

ex.dfy(13,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     && (right == Leaf || IsBST(right, x + 1, hi))
   |     ^^

ex.dfy(14,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     && (right == Leaf || IsBST(right, x + 1, hi))
   |                                                  ^

ex.dfy(14,49): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    && right == Leaf || IsBST(right, x + 1, hi)\n', '    && right == Leaf || IsBST(right, x + 1, hi)\n', '    && (right == Leaf || IsBST(right, x + 1, hi))\n', '    && right == Leaf || IsBST(right, x + 1, hi)\n', '    && right == Leaf || IsBST(right, x + 1, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t
  case Leaf => true
  case Node(left, x, right) =>
    left == Leaf || IsBST(left, lo, x - 1)
    && x <= hi + 1
    && (right == Leaf || IsBST(right, x + 1, hi))
}

   |
13 |     && x <= hi + 1
   |     ^^

ex.dfy(13,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     && (right == Leaf || IsBST(right, x + 1, hi))
   |     ^^

ex.dfy(14,4): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
2 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

   |
11 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
12 |     v >= min && v <= max &&
   |                            ^

ex.dfy(12,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&

   |
13 |     IsBST(left, min, v - 1) &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v) &&

   |
13 |     IsBST(left, min, v) &&
   |                           ^

ex.dfy(13,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v - 1) &&\n', '    IsBST(left, min, v) &&\n', '    IsBST(left, min, v) &&\n', '    IsBST(left, min, v) &&\n', '    IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)

   |
14 |     IsBST(right, v + 1, max)
   |                             ^

ex.dfy(14,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v + 1, max)\n', '    IsBST(right, v + 1, max)\n', '    IsBST(right, v + 1, max)\n', '    IsBST(right, v + 1, max)\n', '    IsBST(right, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)
}

ex.dfy(13,23): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |     IsBST(left, min, v - 1) &&
   |                        ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '  reads t\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true

   |
11 |   case Leaf => true
   |                    ^

ex.dfy(11,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

   |
12 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
13 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(13,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
14 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(14,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
15 |     IsBST(right, value, max)
   |                             ^

ex.dfy(15,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, lo: nat, hi: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(t: Tree, lo: nat, hi: nat): bool\n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&

   |
12 |     value > min &&
   |                   ^

ex.dfy(12,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    value > min &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value > min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&

   |
13 |     value < max &&
   |                   ^

ex.dfy(13,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value < max &&\n', '    value < max &&\n', '    value < max &&\n', '    value < max &&\n', '    value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&

   |
14 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(14,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
15 |     IsBST(right, value, max)
   |                             ^

ex.dfy(15,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert element into BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function

SCORE
1.0
['// (3) Insert element into BST\n', '// (3) Insert function\n', '// (3) Insert function\n', '// (3) Insert function\n', '// (3) Insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then Node(Leaf, value, Leaf)

   |
21 |   if tree == Leaf then Node(Leaf, value, Leaf)
   |                                               ^

ex.dfy(21,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation

   |
21 |   if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
   |                                                                                  ^

ex.dfy(21,81): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value

   |
21 |   if value < tree.value
   |                        ^

ex.dfy(21,23): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, max_nat()) {

   |
21 |   if IsBST(tree, 0, max_nat()) {
   |                                ^

ex.dfy(21,31): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Leaf then Node(Leaf, value, Leaf)\n', '  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation\n', '  if value < tree.value\n', '  if IsBST(tree, 0, max_nat()) {\n', '  if tree == Leaf then Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then

   |
22 |   then
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  then\n', '  then\n', '  then\n', '  then\n', '  then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    match tree

   |
23 |     match tree
   |               ^

ex.dfy(23,14): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)

   |
23 |     InsertCore(tree, value, 0, 100)
   |                                    ^

ex.dfy(23,35): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    InsertCore(tree, value, 0, 100)\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else

   |
24 |   else
   |       ^

ex.dfy(24,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    tree // Insert only if the tree is a BST

   |
25 |     tree // Insert only if the tree is a BST
   |                                             ^

ex.dfy(25,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    InsertCore(Leaf, value, 0, 100) // Example bounds, not required in actual implementation

   |
25 |     InsertCore(Leaf, value, 0, 100) // Example bounds, not required in actual implementation
   |                                                                                             ^

ex.dfy(25,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    tree

   |
25 |     tree
   |         ^

ex.dfy(25,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    Leaf

   |
25 |     Leaf
   |         ^

ex.dfy(25,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    // Add error handling or contract violation here

   |
25 |     // Add error handling or contract violation here
   |                                                     ^

ex.dfy(25,52): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    tree // Insert only if the tree is a BST\n', '    InsertCore(Leaf, value, 0, 100) // Example bounds, not required in actual implementation\n', '    tree\n', '    Leaf\n', '    // Add error handling or contract violation here\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, 100) // Example bounds, not required in actual implementation
  then
    InsertCore(tree, value, 0, 100)
  else
    tree // Insert only if the tree is a BST
}

   |
23 |     InsertCore(tree, value, 0, 100)
   |     ^^^^^^^^^^

ex.dfy(23,4): Error: unresolved identifier: InsertCore
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if IsBST(tree, 0, nat.MaxValue) then

   |
21 |   if IsBST(tree, 0, nat.MaxValue) then
   |                     ^

ex.dfy(21,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < NatMinValue(tree) then

   |
21 |   if value < NatMinValue(tree) then
   |                                    ^

ex.dfy(21,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Leaf then

   |
21 |   if tree == Leaf then
   |                       ^

ex.dfy(21,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree

   |
21 |   if value < 0 then tree
   |                         ^

ex.dfy(21,24): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Leaf then Node(Leaf, value, Leaf)\n', '  if IsBST(tree, 0, nat.MaxValue) then\n', '  if value < NatMinValue(tree) then\n', '  if tree == Leaf then\n', '  if value < 0 then tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else

   |
22 |   else
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree

   |
23 |     match tree
   |               ^

ex.dfy(23,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)

   |
24 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(24,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n', '    case Leaf => Node(Leaf, value, Leaf)\n', '    case Leaf => Node(Leaf, value, Leaf)\n', '    case Leaf => Node(Leaf, value, Leaf)\n', '    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, x, right) =>

   |
25 |     case Node(left, x, right) =>
   |                                 ^

ex.dfy(25,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>

   |
25 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(25,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>

   |
25 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(25,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, x, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, x, right) =>\n', '    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue then

   |
26 |       if value < nodeValue then
   |                                ^

ex.dfy(26,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue then Node(Insert(left, value), nodeValue, right)

   |
26 |       if value < nodeValue then Node(Insert(left, value), nodeValue, right)
   |                                                                            ^

ex.dfy(26,75): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue

   |
26 |       if value < nodeValue
   |                           ^

ex.dfy(26,26): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then\n', '      if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n', '      if value < nodeValue then\n', '      if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n', '      if value < nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)

   |
27 |       then Node(Insert(left, value), nodeValue, right)
   |                                                       ^

ex.dfy(27,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      then Node(Insert(left, value), nodeValue, right)\n', '      then Node(Insert(left, value), nodeValue, right)\n', '      then Node(Insert(left, value), nodeValue, right)\n', '      then Node(Insert(left, value), nodeValue, right)\n', '      then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))

   |
28 |       else Node(left, nodeValue, Insert(right, value))
   |                                                       ^

ex.dfy(28,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue

   |
28 |       else if value > nodeValue
   |                                ^

ex.dfy(28,31): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      else Node(left, nodeValue, Insert(right, value))\n', '      else Node(left, nodeValue, Insert(right, value))\n', '      else if value > nodeValue\n', '      else Node(left, nodeValue, Insert(right, value))\n', '      else if value > nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains predicate

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Predicate for containment

SCORE
1.0
['// (4) Contains predicate\n', '// (4) Contains function\n', '// (4) Contains element\n', '// (4) Contains predicate\n', '// (4) Predicate for containment\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
function Contains(tree: Tree, value: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n', 'predicate Contains(tree: Tree, value: nat)\n', 'function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
34 |   match tree
   |             ^

ex.dfy(34,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false

   |
35 |   case Leaf => false
   |                     ^

ex.dfy(35,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n', '  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>

   |
36 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(36,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||

   |
37 |     value == nodeValue ||
   |                          ^

ex.dfy(37,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue || Contains(left, value) || Contains(right, value)

   |
37 |     value == nodeValue || Contains(left, value) || Contains(right, value)
   |                                                                          ^

ex.dfy(37,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    if value == nodeValue

   |
37 |     if value == nodeValue
   |                          ^

ex.dfy(37,25): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == nodeValue ||\n', '    value == nodeValue || Contains(left, value) || Contains(right, value)\n', '    value == nodeValue || Contains(left, value) || Contains(right, value)\n', '    value == nodeValue ||\n', '    if value == nodeValue\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ? Contains(left, value) : Contains(right, value))

   |
38 |     (value < nodeValue ? Contains(left, value) : Contains(right, value))
   |                        ^

ex.dfy(38,23): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue && Contains(left, value)) ||

   |
38 |     (value < nodeValue && Contains(left, value)) ||
   |                                                    ^

ex.dfy(38,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||

   |
38 |     (value < nodeValue ==> Contains(left, value)) ||
   |                                                     ^

ex.dfy(38,52): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (value < nodeValue ? Contains(left, value) : Contains(right, value))\n', '    (value < nodeValue && Contains(left, value)) ||\n', '    (value < nodeValue ==> Contains(left, value)) ||\n', '    (value < nodeValue && Contains(left, value)) ||\n', '    (value < nodeValue ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    Contains(right, value)

   |
39 |     Contains(right, value)
   |                           ^

ex.dfy(39,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value > nodeValue ==> Contains(right, value))

   |
39 |     (value > nodeValue ==> Contains(right, value))
   |                                                   ^

ex.dfy(39,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))

   |
39 |     (value >= nodeValue ==> Contains(right, value))
   |                                                    ^

ex.dfy(39,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Contains(right, value)\n', '    (value > nodeValue ==> Contains(right, value))\n', '    Contains(right, value)\n', '    Contains(right, value)\n', '    (value >= nodeValue ==> Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma about insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Insert maintains Contains

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert without BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma about insertion

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert

SCORE
1.0
['// (5) Lemma about insert function\n', '// (5) Insert maintains Contains\n', '// (5) Lemma for insert without BST\n', '// (5) Lemma about insertion\n', '// (5) Lemma for insert\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma InsertPreservesContains(tree: Tree, value: nat, oldValue: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:inline 1} InsertPreservesContains(tree: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:verify false} InsertPreservesValue(tree: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)

SCORE
1.0
['lemma InsertPreservesContains(tree: Tree, value: nat, oldValue: nat)\n', 'lemma {:inline 1} InsertPreservesContains(tree: Tree, value: nat)\n', 'lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)\n', 'lemma {:verify false} InsertPreservesValue(tree: Tree, value: nat)\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, originalValue: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
  ensures Contains(newTree, value) <==> Contains(tree, value)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)

SCORE
1.0
['{\n', '  ensures Contains(newTree, value) <==> Contains(tree, value)\n', '{\n', 'requires Contains(tree, value) && newTree == Insert(tree, value)\n', 'requires Contains(tree, value) && newTree == Insert(tree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)

SCORE
1.0
['ensures Contains(newTree, value)\n', 'ensures Contains(newTree, value)\n', 'ensures Contains(newTree, value)\n', 'ensures Contains(newTree, value)\n', 'ensures Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // Base case: if value is in tree, it's in newTree

   |
47 |   // Base case: if value is in tree, it's in newTree
   |                                                     ^

ex.dfy(47,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...

   |
47 |   // ...
   |         ^

ex.dfy(47,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
}

SCORE
1.0
["  // Base case: if value is in tree, it's in newTree\n", '  // ...\n', '}\n', '  // ...\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for BST property after insert

SCORE
1.0
['// (6) Lemma for insert and BST property\n', '// (6) Lemma for BST\n', '// (6) Lemma for insert and BST\n', '// (6) Lemma for BST property\n', '// (6) Lemma for BST property after insert\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)

SCORE
1.0
['lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)\n', 'lemma {:auto} InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)\n', 'lemma {:auto} InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)\n', 'lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)\n', 'lemma {:auto} InsertPreservesBST(tree: Tree, value: nat, min: nat, max: nat, newTree: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max

SCORE
1.0
['requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value)\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max
ensures IsBST(newTree, min, max)

SCORE
1.0
['ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max
ensures IsBST(newTree, min, max)
{

   |
54 | {
   |  ^

ex.dfy(54,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max
ensures IsBST(newTree, min, max)
{
  // ...

   |
55 |   // ...
   |         ^

ex.dfy(55,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value <= max
ensures IsBST(newTree, min, max)
{
  // ...
}

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,8): Related location: this is the postcondition that could not be proved
   |
53 | ensures IsBST(newTree, min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value > min &&
   |     ^^^^^^^^^^^

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,8): Related location: this is the postcondition that could not be proved
   |
53 | ensures IsBST(newTree, min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(13,4): Related location
   |
13 |     value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['requires IsBST(tree, min, max) && newTree == Insert(tree, value)\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value)\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value)\n', 'requires IsBST(tree, min, max) && newTree == Insert(tree, value) && min <= value && value < max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) && (value < min || value > max ==> Contains(newTree, value))

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) && Contains(newTree, value)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&

   |
53 | ensures IsBST(newTree, min, max) &&
   |                                    ^

ex.dfy(53,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max)

SCORE
1.0
['ensures IsBST(newTree, min, max) && (value < min || value > max ==> Contains(newTree, value))\n', 'ensures IsBST(newTree, min, max) && Contains(newTree, value)\n', 'ensures IsBST(newTree, min, max) &&\n', 'ensures IsBST(newTree, min, max)\n', 'ensures IsBST(newTree, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value < min || value > max ==> Contains(newTree, value))

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value < min || value >= max ==> Contains(newTree, value)) &&

   |
54 |         (value < min || value >= max ==> Contains(newTree, value)) &&
   |                                                                      ^

ex.dfy(54,69): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value >= min && value <= max ==> Contains(newTree, value))

SCORE
1.0
['        (value < min || value > max ==> Contains(newTree, value))\n', '        (value < min || value >= max ==> Contains(newTree, value)) &&\n', '        (value >= min && value <= max ==> Contains(newTree, value))\n', '        (value >= min && value <= max ==> Contains(newTree, value))\n', '        (value >= min && value <= max ==> Contains(newTree, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value < min || value >= max ==> Contains(newTree, value)) &&
        (value >= min && value < max ==> !Contains(newTree, value))

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value < min || value >= max ==> Contains(newTree, value)) &&
        (value >= min && value < max ==> Contains(newTree, value))

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value > min &&
    value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < 0 then tree
  else
    match tree
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue
      then Node(Insert(left, value), nodeValue, right)
      else Node(left, nodeValue, Insert(right, value))
}

// (4) Contains element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Leaf => false
  case Node(left, nodeValue, right) =>
    value == nodeValue ||
    (value < nodeValue ==> Contains(left, value)) ||
    (value >= nodeValue ==> Contains(right, value))
}

// (5) Lemma for insert
lemma {:auto} InsertPreservesValue(tree: Tree, value: nat, newTree: Tree)
requires Contains(tree, value) && newTree == Insert(tree, value)
ensures Contains(newTree, value)
{
  // ...
}

// (6) Lemma for insert and BST property
lemma {:auto} InsertMaintainsBST(tree: Tree, value: nat, newTree: Tree, min: nat, max: nat)
requires IsBST(tree, min, max) && newTree == Insert(tree, value)
ensures IsBST(newTree, min, max) &&
        (value < min || value >= max ==> Contains(newTree, value)) &&
        (value >= min && value < max ==> Contains(tree, value))

SCORE
1.0
['        (value >= min && value < max ==> !Contains(newTree, value))\n', '        (value >= min && value < max ==> Contains(newTree, value))\n', '        (value >= min && value < max ==> Contains(newTree, value))\n', '        (value >= min && value < max ==> Contains(tree, value))\n', '        (value >= min && value < max ==> Contains(newTree, value))\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 65
number of gen nodes: 33 (including leaves: 5)
number of back nodes: 32 (including leaves: 28)

expansion count: 41 (including failed: 9)

cache stats {'hit': 389, 'miss': 181}
calls to generate 114
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749]

Trial calls: [165, 600, 570]


Time Statistics:

  Min: 236.00 sec, Max: 749.00 sec, Average: 571.33 sec, Standard Deviation: 237.26 sec

Call Statistics:

  Min: 165 calls, Max: 600 calls, Average: 445.00 calls, Standard Deviation: 198.37 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749]

Trial calls: [600, 570]


Time Statistics:

  Min: 729.00 sec, Max: 749.00 sec, Average: 739.00 sec, Standard Deviation: 10.00 sec

Call Statistics:

  Min: 570 calls, Max: 600 calls, Average: 585.00 calls, Standard Deviation: 15.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

Trial  4
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree =\n', '// (1) Define an ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Leaf

SCORE
1.0
['    | Node(left: Tree, value: nat, right: Tree)\n', '    | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Leaf\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Leaf

SCORE
1.0
['    | Empty\n', '    | Leaf\n', '    | Empty\n', '    | Empty\n', '    | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty


SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

SCORE
1.0
['\n', '```\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(2) The predicate to check if a given tree is a binary search tree is recursive and needs to check at each node that the left subtree is less than or equal to the current node value and the right subtree is greater than or equal to the current node value.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

The tree is defined as an ADT in Dafny.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for a tree of natural numbers is defined above.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

```dafny

SCORE
1.0
['(2) The predicate to check if a given tree is a binary search tree is recursive and needs to check at each node that the left subtree is less than or equal to the current node value and the right subtree is greater than or equal to the current node value.\n', 'The tree is defined as an ADT in Dafny.\n', '(1) The ADT for the tree of natural numbers has been written.\n', '(1) The ADT for a tree of natural numbers is defined above.\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate for checking if a tree is a BST:

SCORE
1.0
['```dafny\n', '```dafny\n', '(2) Here is the predicate for checking if a tree is a BST:\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, lo: nat, hi: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n', 'function IsBST(t: Tree, lo: nat, hi: nat): bool\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat) \n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t 

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t \n', '{\n', '    reads t\n', '    reads t \n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>

  |
9 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(9,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(left, v, right) => 

  |
9 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, v, r) =>\n', '    case Empty => true\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) => \n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= lo && v <= hi &&

   |
10 |         v >= lo && v <= hi &&
   |                              ^

ex.dfy(10,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        IsBST(l, lo, v) &&

   |
10 |         IsBST(l, lo, v) &&
   |                           ^

ex.dfy(10,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v

   |
10 |         l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
   |                                                                      ^

ex.dfy(10,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        v >= lo && v <= hi &&\n', '        IsBST(l, lo, v) &&\n', '        v >= lo && v <= hi &&\n', '        IsBST(l, lo, v) &&\n', '        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
        && IsBST(l, lo, y) && IsBST(r, y, hi)

   |
11 |         && IsBST(l, lo, y) && IsBST(r, y, hi)
   |                                              ^

ex.dfy(11,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
        && IsBST(l, lo, y)

   |
11 |         && IsBST(l, lo, y)
   |                           ^

ex.dfy(11,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        && IsBST(l, lo, y) && IsBST(r, y, hi)\n', '        && IsBST(l, lo, y)\n', '        && IsBST(l, lo, y)\n', '        && IsBST(l, lo, y)\n', '        && IsBST(l, lo, y) && IsBST(r, y, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
        && IsBST(l, lo, y) && IsBST(r, y, hi)
    case Empty => true

   |
12 |     case Empty => true
   |                       ^

ex.dfy(12,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
        && IsBST(l, lo, y) && IsBST(r, y, hi)
        && lo <= y && y <= hi

   |
12 |         && lo <= y && y <= hi
   |                              ^

ex.dfy(12,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '        && lo <= y && y <= hi\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
    match t
    case Node(l, v, r) =>
        l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
        && IsBST(l, lo, y) && IsBST(r, y, hi)
    case Empty => true
}

   |
10 |         l == Empty || exists x, y: nat :: l == Node(x, y, r) && y < v
   |                       ^^^^^^

ex.dfy(10,22): Error: quantifiers in non-ghost contexts must be compilable, but Dafny's heuristics can't figure out how to produce or compile a bounded set of values for 'x'
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['    reads t\n', '    reads t\n', '    reads t\n', '    reads t\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Node(l, v, r) =>

   |
10 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(10,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Node(left, value, right) =>\n', '    case Empty => true\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || IsBST(l, lo, v) &&

   |
12 |         l == Empty || IsBST(l, lo, v) &&
   |                                       ^^

ex.dfy(12,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || IsBST(l, lo, v) &&
   |                                         ^

ex.dfy(12,40): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        v >= lo && v <= hi &&

   |
12 |         v >= lo && v <= hi &&
   |                              ^

ex.dfy(12,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        IsBST(l, lo, v) &&

   |
12 |         IsBST(l, lo, v) &&
   |                           ^

ex.dfy(12,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        l == Empty || v >= l.value && IsBST(l, lo, v)\n', '        l == Empty || IsBST(l, lo, v) &&\n', '        v >= lo && v <= hi &&\n', '        IsBST(l, lo, v) &&\n', '        v >= lo && v <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)
        && v <= r.value && IsBST(r, v, hi)

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && v <= r.value && IsBST(r, v, hi)
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && v <= r.value && IsBST(r, v, hi)
   |                         ^^

ex.dfy(13,24): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && v <= r.value && IsBST(r, v, hi)
   |                                           ^

ex.dfy(13,42): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)
        && (r == Empty || v < r.value && IsBST(r, v, hi))

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |                                       ^^

ex.dfy(13,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |                                                          ^

ex.dfy(13,57): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)
        && r == Empty || v <= r.value && IsBST(r, v, hi)

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && r == Empty || v <= r.value && IsBST(r, v, hi)
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && r == Empty || v <= r.value && IsBST(r, v, hi)
   |                                       ^^

ex.dfy(13,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && r == Empty || v <= r.value && IsBST(r, v, hi)
   |                                                         ^

ex.dfy(13,56): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
['        && v <= r.value && IsBST(r, v, hi)\n', '        && v <= r.value && IsBST(r, v, hi)\n', '        && (r == Empty || v < r.value && IsBST(r, v, hi))\n', '        && v <= r.value && IsBST(r, v, hi)\n', '        && r == Empty || v <= r.value && IsBST(r, v, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)
        && (r == Empty || v < r.value && IsBST(r, v, hi))
        && lo <= v && v <= hi

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |                                       ^^

ex.dfy(13,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && lo <= v && v <= hi
   |         ^^

ex.dfy(14,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && lo <= v && v <= hi
   |                    ^^

ex.dfy(14,19): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && lo <= v && v <= hi
   |                              ^

ex.dfy(14,29): Error: rbrace expected
6 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || v >= l.value && IsBST(l, lo, v)
        && (r == Empty || v < r.value && IsBST(r, v, hi))
}

   |
12 |         l == Empty || v >= l.value && IsBST(l, lo, v)
   |                                    ^^

ex.dfy(12,35): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && (r == Empty || v < r.value && IsBST(r, v, hi))
   |                                       ^^

ex.dfy(13,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
3 parse errors detected in ex.dfy

SCORE
-1.0
['        && lo <= v && v <= hi\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat) \n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '    reads t\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>

  |
9 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(9,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
10 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>
        left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&

   |
10 |         left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
   |                                                                                   ^^

ex.dfy(10,82): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
10 |         left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
   |                                                                                     ^

ex.dfy(10,84): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>
        left == Empty || IsBST(left, min, value)

   |
10 |         left == Empty || IsBST(left, min, value)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&\n', '        left == Empty || IsBST(left, min, value)\n', '        value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>
        left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
        right == Empty || (value < max && IsBST(right, value, max))

   |
10 |         left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
   |                                                                                   ^^

ex.dfy(10,82): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         right == Empty || (value < max && IsBST(right, value, max))
   |                                                                    ^

ex.dfy(11,67): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        right == Empty || (value < max && IsBST(right, value, max))\n', '        right == Empty || (value < max && IsBST(right, value, max))\n', '        right == Empty || (value < max && IsBST(right, value, max))\n', '        right == Empty || (value < max && IsBST(right, value, max))\n', '        right == Empty || (value < max && IsBST(right, value, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>
        left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
        right == Empty || (value < max && IsBST(right, value, max))
    case Empty => true

   |
10 |         left == Empty || (min <= value && value < max && IsBST(left, min, value)) &&
   |                                                                                   ^^

ex.dfy(10,82): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |     case Empty => true
   |                       ^

ex.dfy(12,22): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
['{\n', '    reads t\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
        case Node(left, value, right) =>

   |
10 |         case Node(left, value, right) =>
   |                                         ^

ex.dfy(10,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
        case Empty => true

   |
10 |         case Empty => true
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Empty => true\n', '        case Node(left, value, right) =>\n', '        case Empty => true\n', '        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        l != null && r != null &&

   |
12 |         l != null && r != null &&
   |                                  ^

ex.dfy(12,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max &&

   |
12 |         v >= min && v <= max &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        l != Empty && r != Empty && v > min && v < max &&

   |
12 |         l != Empty && r != Empty && v > min && v < max &&
   |                                                          ^

ex.dfy(12,57): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)

   |
12 |         v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)
   |                                                                             ^

ex.dfy(12,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        l != null && r != null &&\n', '        v >= min && v <= max &&\n', '        l != Empty && r != Empty && v > min && v < max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&

   |
13 |         IsBST(l, min, v) &&
   |                            ^

ex.dfy(13,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v - 1) &&

   |
13 |         IsBST(l, min, v - 1) &&
   |                                ^

ex.dfy(13,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(l, min, v) &&\n', '        IsBST(l, min, v - 1) &&\n', '        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v - 1) &&
        IsBST(r, v + 1, max)

   |
14 |         IsBST(r, v + 1, max)
   |                             ^

ex.dfy(14,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(r, v + 1, max)\n', '        IsBST(r, v + 1, max)\n', '        IsBST(r, v + 1, max)\n', '        IsBST(r, v + 1, max)\n', '        IsBST(r, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v - 1) &&
        IsBST(r, v + 1, max)
}

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Predicate that checks if a given tree is a binary search tree (BST).

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

SCORE
1.0
['```dafny\n', '```dafny\n', '(2) Predicate that checks if a given tree is a binary search tree (BST).\n', '(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(tree: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, lo: int, hi: int)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['function IsBST(tree: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, lo: int, hi: int)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(tree: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '    reads t\n', '    reads t\n', '{\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>

   |
10 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(10,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Empty => true\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&

   |
11 |         v >= min && v <= max &&
   |                                ^

ex.dfy(11,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&

   |
11 |         IsBST(l, min, v) &&
   |                            ^

ex.dfy(11,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v >= min && v <= max &&

   |
12 |         v >= min && v <= max &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v <= max &&

   |
12 |         v <= max &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v <= max &&
        v >= min &&

   |
13 |         v >= min &&
   |                    ^

ex.dfy(13,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min &&\n', '        v >= min &&\n', '        v >= min &&\n', '        v >= min &&\n', '        v >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v <= max &&
        v >= min &&
        IsBST(r, v, max)

   |
14 |         IsBST(r, v, max)
   |                         ^

ex.dfy(14,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v <= max &&
        v >= min &&
        IsBST(r, v, max)
    case Empty => true

   |
15 |     case Empty => true
   |                       ^

ex.dfy(15,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&
        v <= max &&
        v >= min &&
        IsBST(r, v, max)
    case Empty => true
}

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '    reads t\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        IsBST(left, min, value) &&

   |
10 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
10 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value > min && value < max &&

   |
10 |         value > min && value < max &&
   |                                      ^

ex.dfy(10,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value) &&\n', '        value >= min && value <= max &&\n', '        value > min && value < max &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (left == Empty || IsBST(left, min, value - 1)) &&

   |
11 |         (left == Empty || IsBST(left, min, value - 1)) &&
   |                                                          ^

ex.dfy(11,57): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&

   |
11 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value - 1) &&

   |
11 |         IsBST(left, min, value - 1) &&
   |                                       ^

ex.dfy(11,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (min < value ==> IsBST(left, min, value - 1)) &&

   |
11 |         (min < value ==> IsBST(left, min, value - 1)) &&
   |                                                         ^

ex.dfy(11,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (left == Empty || IsBST(left, min, value - 1)) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value - 1) &&\n', '        IsBST(left, min, value) &&\n', '        (min < value ==> IsBST(left, min, value - 1)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (left == Empty || IsBST(left, min, value - 1)) &&
        (right == Empty || IsBST(right, value + 1, max))

   |
12 |         (right == Empty || IsBST(right, value + 1, max))
   |                                                         ^

ex.dfy(12,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        (right == Empty || IsBST(right, value + 1, max))\n', '        (right == Empty || IsBST(right, value + 1, max))\n', '        (right == Empty || IsBST(right, value + 1, max))\n', '        (right == Empty || IsBST(right, value + 1, max))\n', '        (right == Empty || IsBST(right, value + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (left == Empty || IsBST(left, min, value - 1)) &&
        (right == Empty || IsBST(right, value + 1, max))
    case Empty => true

   |
13 |     case Empty => true
   |                       ^

ex.dfy(13,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (left == Empty || IsBST(left, min, value - 1)) &&
        (right == Empty || IsBST(right, value + 1, max))
    case Empty => true
}

ex.dfy(11,49): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |         (left == Empty || IsBST(left, min, value - 1)) &&
   |                                                  ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat) \n', 'predicate IsBST(t: Tree, min: nat, max: nat) \n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '    reads t\n', '{\n', '{\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>

   |
10 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(10,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&

   |
11 |         v >= min && v <= max &&
   |                                ^

ex.dfy(11,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&

   |
12 |         (left == Empty ==> v == min) &&
   |                                        ^

ex.dfy(12,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty || IsBST(left, min, v)) &&

   |
12 |         (left == Empty || IsBST(left, min, v)) &&
   |                                                  ^

ex.dfy(12,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty || IsBST(left, min, v - 1)) &&

   |
12 |         (left == Empty || IsBST(left, min, v - 1)) &&
   |                                                      ^

ex.dfy(12,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        IsBST(left, min, v) &&

   |
12 |         IsBST(left, min, v) &&
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (left == Empty ==> v == min) &&\n', '        (left == Empty || IsBST(left, min, v)) &&\n', '        (left == Empty || IsBST(left, min, v - 1)) &&\n', '        (left == Empty ==> v == min) &&\n', '        IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&

   |
13 |         (right == Empty ==> v == max) &&
   |                                         ^

ex.dfy(13,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (right == Empty ==> v == max) &&\n', '        (right == Empty ==> v == max) &&\n', '        (right == Empty ==> v == max) &&\n', '        (right == Empty ==> v == max) &&\n', '        (right == Empty ==> v == max) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&
        IsBST(left, min, v - 1) &&

   |
14 |         IsBST(left, min, v - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&
        (left != Empty ==> IsBST(left, min, v - 1)) &&

   |
14 |         (left != Empty ==> IsBST(left, min, v - 1)) &&
   |                                                       ^

ex.dfy(14,54): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, v - 1) &&\n', '        (left != Empty ==> IsBST(left, min, v - 1)) &&\n', '        IsBST(left, min, v - 1) &&\n', '        IsBST(left, min, v - 1) &&\n', '        IsBST(left, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&
        (left != Empty ==> IsBST(left, min, v - 1)) &&
        (right != Empty ==> IsBST(right, v + 1, max))

   |
15 |         (right != Empty ==> IsBST(right, v + 1, max))
   |                                                      ^

ex.dfy(15,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        (right != Empty ==> IsBST(right, v + 1, max))\n', '        (right != Empty ==> IsBST(right, v + 1, max))\n', '        (right != Empty ==> IsBST(right, v + 1, max))\n', '        (right != Empty ==> IsBST(right, v + 1, max))\n', '        (right != Empty ==> IsBST(right, v + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&
        (left != Empty ==> IsBST(left, min, v - 1)) &&
        (right != Empty ==> IsBST(right, v + 1, max))
    case Empty => true

   |
16 |     case Empty => true
   |                       ^

ex.dfy(16,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Node(left, v, right) =>
        v >= min && v <= max &&
        (left == Empty ==> v == min) &&
        (right == Empty ==> v == max) &&
        (left != Empty ==> IsBST(left, min, v - 1)) &&
        (right != Empty ==> IsBST(right, v + 1, max))
    case Empty => true
}

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '    reads t\n', '    reads t\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>

  |
9 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(9,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&

   |
10 |         v >= min && v <= max &&
   |                                ^

ex.dfy(10,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        IsBST(l, min, v) &&

   |
10 |         IsBST(l, min, v) &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&

   |
11 |         IsBST(l, min, v) &&
   |                            ^

ex.dfy(11,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (v > min ==> IsBST(l, min, v - 1)) &&

   |
11 |         (v > min ==> IsBST(l, min, v - 1)) &&
   |                                              ^

ex.dfy(11,45): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&

   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                              ^^

ex.dfy(11,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                      ^^

ex.dfy(11,53): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                                                 ^

ex.dfy(11,80): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v - 1) &&

   |
11 |         IsBST(l, min, v - 1) &&
   |                                ^

ex.dfy(11,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n', '        (v > min ==> IsBST(l, min, v - 1)) &&\n', '        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&\n', '        IsBST(l, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
        (r == Empty || v < v && IsBST(r, v + 1, max))

   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                              ^^

ex.dfy(11,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                      ^^

ex.dfy(11,53): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         (r == Empty || v < v && IsBST(r, v + 1, max))
   |                              ^^

ex.dfy(12,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         (r == Empty || v < v && IsBST(r, v + 1, max))
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
        IsBST(r, v + 1, max)

   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                              ^^

ex.dfy(11,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                      ^^

ex.dfy(11,53): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         IsBST(r, v + 1, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
        (r == Empty || v > v && IsBST(r, v + 1, max))

   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                              ^^

ex.dfy(11,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                      ^^

ex.dfy(11,53): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         (r == Empty || v > v && IsBST(r, v + 1, max))
   |                              ^^

ex.dfy(12,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         (r == Empty || v > v && IsBST(r, v + 1, max))
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
None
['        (r == Empty || v < v && IsBST(r, v + 1, max))\n', '        IsBST(r, v + 1, max)\n', '        (r == Empty || v < v && IsBST(r, v + 1, max))\n', '        (r == Empty || v > v && IsBST(r, v + 1, max))\n', '        (r == Empty || v < v && IsBST(r, v + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
        IsBST(r, v + 1, max)
    case Empty => true

   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                              ^^

ex.dfy(11,29): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |         (l == Empty || v > v && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)) &&
   |                                                      ^^

ex.dfy(11,53): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     case Empty => true
   |                       ^

ex.dfy(13,22): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['predicate IsBST(tree: Tree, min: nat, max: nat)\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>

  |
9 |     case Node(l, v, r) =>
  |                          ^

ex.dfy(9,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&

   |
10 |         v >= min && v <= max &&
   |                                ^

ex.dfy(10,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&

   |
11 |         IsBST(l, min, v) &&
   |                            ^

ex.dfy(11,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v - 1) &&

   |
11 |         IsBST(l, min, v - 1) &&
   |                                ^

ex.dfy(11,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(l, min, v) &&\n', '        IsBST(l, min, v - 1) &&\n', '        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n', '        IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)

   |
12 |         IsBST(r, v, max)
   |                         ^

ex.dfy(12,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n', '        IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true

   |
13 |     case Empty => true
   |                       ^

ex.dfy(13,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) Write a function that inserts an element into a binary search tree while preserving the BST property:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) Here is the function that inserts an element into a binary search tree while preserving the BST property:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) This is the function that inserts an element into a binary search tree while preserving the BST property:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is as follows:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

SCORE
1.0
['(3) Write a function that inserts an element into a binary search tree while preserving the BST property:\n', '(3) Here is the function that inserts an element into a binary search tree while preserving the BST property:\n', '(3) This is the function that inserts an element into a binary search tree while preserving the BST property:\n', '(3) The function that inserts an element into a binary search tree while preserving the BST property is as follows:\n', '(3) The function that inserts an element into a binary search tree while preserving the BST property is:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t

   |
19 |     match t
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>

   |
20 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(20,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v {

   |
21 |         if value < v {
   |                      ^

ex.dfy(21,21): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)

   |
21 |         if value < v then Node(Insert(l, value), v, r)
   |                                                       ^

ex.dfy(21,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v {\n', '        if value < v then Node(Insert(l, value), v, r)\n', '        if value < v then Node(Insert(l, value), v, r)\n', '        if value < v then Node(Insert(l, value), v, r)\n', '        if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))

   |
22 |         else if value > v then Node(l, v, Insert(r, value))
   |                                                            ^

ex.dfy(22,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > v then Node(l, v, Insert(r, value))\n', '        else if value > v then Node(l, v, Insert(r, value))\n', '        else if value > v then Node(l, v, Insert(r, value))\n', '        else if value > v then Node(l, v, Insert(r, value))\n', '        else if value > v then Node(l, v, Insert(r, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t

   |
23 |         else t
   |               ^

ex.dfy(23,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else t\n', '        else t\n', '        else t\n', '        else t\n', '        else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)

   |
24 |     case Empty => Node(Empty, value, Empty)
   |                                            ^

ex.dfy(24,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, value, Empty)\n', '    case Empty => Node(Empty, value, Empty)\n', '    case Empty => Node(Empty, value, Empty)\n', '    case Empty => Node(Empty, value, Empty)\n', '    case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element:

SCORE
1.0
['(4) The predicate that checks whether a given tree contains a given element is:\n', '(4) The predicate that checks whether a given tree contains a given element is:\n', '(4) The predicate that checks whether a given tree contains a given element is:\n', '(4) The predicate that checks whether a given tree contains a given element is:\n', '(4) The predicate that checks whether a given tree contains a given element:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny

SCORE
1.0
['```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n', '```dafny\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t

   |
30 |     match t
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>

   |
31 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(31,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)

   |
32 |         if value < v then Contains(l, value)
   |                                             ^

ex.dfy(32,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        value < v ? Contains(l, value)

   |
32 |         value < v ? Contains(l, value)
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        value < v ? Contains(l, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        value < v ? Contains(l, value)
        : (value > v ? Contains(r, value) : true)

   |
32 |         value < v ? Contains(l, value)
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        value < v ? Contains(l, value)
        : value > v ? Contains(r, value)

   |
32 |         value < v ? Contains(l, value)
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        : (value > v ? Contains(r, value) : true)\n', '        : value > v ? Contains(r, value)\n', '        : value > v ? Contains(r, value)\n', '        : (value > v ? Contains(r, value) : true)\n', '        : value > v ? Contains(r, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        value < v ? Contains(l, value)
        : value > v ? Contains(r, value)
        : true

   |
32 |         value < v ? Contains(l, value)
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        : true\n', '        : true\n', '        : true\n', '        : true\n', '        : true\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
['    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n', '    case Node(l, v, r) =>\n']
['        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n', '        if value < v then Contains(l, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)

   |
33 |         else if value > v then Contains(r, value)
   |                                                  ^

ex.dfy(33,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > v then Contains(r, value)\n', '        else if value > v then Contains(r, value)\n', '        else if value > v then Contains(r, value)\n', '        else if value > v then Contains(r, value)\n', '        else if value > v then Contains(r, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true

   |
34 |         else true
   |                  ^

ex.dfy(34,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else true\n', '        else true\n', '        else true\n', '        else true\n', '        else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false

   |
35 |     case Empty => false
   |                        ^

ex.dfy(35,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```

(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element is:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```

(5) The lemma that checks the tree resulting from inserting an element contains that element is:

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```

(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property) is:

SCORE
1.0
['(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element is:\n', '(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element is:\n', '(5) The lemma that checks the tree resulting from inserting an element contains that element is:\n', '(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property) is:\n', '(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element is:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Node(left: Tree, value: nat, right: Tree)
    | Empty
```

(1) The ADT for the tree of natural numbers has been written.

(2) Here is the predicate that checks whether a given tree is a binary search tree (BST):

```dafny
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Node(l, v, r) =>
        v >= min && v <= max &&
        IsBST(l, min, v) &&
        IsBST(r, v, max)
    case Empty => true
}
```

(3) The function that inserts an element into a binary search tree while preserving the BST property is:

```dafny
function Insert(t: Tree, value: nat): Tree
{
    match t
    case Node(l, v, r) =>
        if value < v then Node(Insert(l, value), v, r)
        else if value > v then Node(l, v, Insert(r, value))
        else t
    case Empty => Node(Empty, value, Empty)
}
```

(4) The predicate that checks whether a given tree contains a given element is:

```dafny
function Contains(t: Tree, value: nat): bool
{
    match t
    case Node(l, v, r) =>
        if value < v then Contains(l, value)
        else if value > v then Contains(r, value)
        else true
    case Empty => false
}
```

(5) The lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property) is:


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 69
number of gen nodes: 35 (including leaves: 5)
number of back nodes: 34 (including leaves: 30)

expansion count: 43 (including failed: 9)

cache stats {'hit': 430, 'miss': 215}
calls to generate 129
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720]

Trial calls: [165, 600, 570, 645]


Time Statistics:

  Min: 236.00 sec, Max: 749.00 sec, Average: 608.50 sec, Standard Deviation: 215.32 sec

Call Statistics:

  Min: 165 calls, Max: 645 calls, Average: 495.00 calls, Standard Deviation: 192.39 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720]

Trial calls: [600, 570, 645]


Time Statistics:

  Min: 720.00 sec, Max: 749.00 sec, Average: 732.67 sec, Standard Deviation: 12.12 sec

Call Statistics:

  Min: 570 calls, Max: 645 calls, Average: 605.00 calls, Standard Deviation: 30.82 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

Trial  5
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree ADT

SCORE
1.0
['// (1)\n', '// (1) ADT for tree of natural numbers\n', 'datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', '// (1) Define the tree ADT\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()\n', 'datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)

SCORE
1.0
['// (2)\n', '// (2)\n', '// (2)\n', '// (2)\n', '// (2)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
    match t

  |
7 |     match t
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '    match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) => 

  |
8 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(8,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>

  |
8 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(8,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf() => true

  |
8 |   case Leaf() => true
  |                      ^

ex.dfy(8,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) => \n', '  case Node(left, value, right) =>\n', '  case Leaf() => true\n', '  case Node(left, value, right) =>\n', '  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&

  |
9 |     IsBST(left, lower, value) &&
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)

  |
9 |     IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  |                                                                              ^

ex.dfy(9,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) &&\n', '    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)\n', '    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true

   |
10 |   case Leaf() => true
   |                      ^

ex.dfy(10,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => lower <= upper

   |
10 |   case Leaf() => lower <= upper
   |                                ^

ex.dfy(10,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => true\n', '  case Leaf() => true\n', '  case Leaf() => true\n', '  case Leaf() => lower <= upper\n', '  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)

SCORE
1.0
['// (3)\n', '// (3)\n', '// (3)\n', '// (3)\n', '// (3)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, x: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat, lower: nat, upper: nat): Tree

SCORE
1.0
['function Insert(t: Tree, x: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, value: nat, lower: nat, upper: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{

   |
15 | {
   |  ^

ex.dfy(15,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  requires !Exists(t, value)

   |
15 |   requires !Exists(t, value)
   |             ^^^^^^

ex.dfy(15,12): Error: unresolved identifier: Exists
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)

   |
15 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(15,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t

   |
15 |   reads t
   |         ^

ex.dfy(15,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '  requires !Exists(t, value)\n', '  requires IsBST(t, 0, nat.MaxInt)\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t

   |
17 |   match t
   |          ^

ex.dfy(17,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then Node(Leaf(), value, Leaf())

   |
17 |   if t == Leaf() then Node(Leaf(), value, Leaf())
   |                                                  ^

ex.dfy(17,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then

   |
17 |   if t == Leaf() then
   |                      ^

ex.dfy(17,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())

   |
18 |     Node(Leaf(), value, Leaf())
   |                                ^

ex.dfy(18,31): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Leaf(), value, Leaf())\n', '    Node(Leaf(), value, Leaf())\n', '    Node(Leaf(), value, Leaf())\n', '    Node(Leaf(), value, Leaf())\n', '    Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else

   |
19 |   else
   |       ^

ex.dfy(19,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t

   |
20 |     match t
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>

   |
21 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(21,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, v, right) =>

   |
21 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, x, right) =>

   |
21 |     case Node(left, x, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, x, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then

   |
22 |       if value < nodeValue then
   |                                ^

ex.dfy(22,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)

   |
23 |         Node(Insert(left, value), nodeValue, right)
   |                                                    ^

ex.dfy(23,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then

   |
24 |       else if value > nodeValue then
   |                                     ^

ex.dfy(24,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value == nodeValue then

   |
24 |       else if value == nodeValue then
   |                                      ^

ex.dfy(24,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value == nodeValue then\n', '      else if value == nodeValue then\n', '      else if value == nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value == nodeValue then
        t

   |
25 |         t
   |          ^

ex.dfy(25,9): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        t\n', '        t\n', '        t\n', '        t\n', '        t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value == nodeValue then
        t
      else

   |
26 |       else
   |           ^

ex.dfy(26,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n', '      else\n', '      else\n', '      else\n', '      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value == nodeValue then
        t
      else
        Node(left, nodeValue, Insert(right, value))

   |
27 |         Node(left, nodeValue, Insert(right, value))
   |                                                    ^

ex.dfy(27,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
  reads t
{
  if t == Leaf() then
    Node(Leaf(), value, Leaf())
  else
    match t
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value == nodeValue then
        t
      else
        Node(left, nodeValue, Insert(right, value))
}

   |
15 |   reads t
   |         ^

ex.dfy(15,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())

   |
16 |   if t == Leaf() then Node(Leaf(), value, Leaf())
   |                                                  ^

ex.dfy(16,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n', '  if t == Leaf() then Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 

   |
17 |   else
   |       ^

ex.dfy(17,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else

   |
17 |   else
   |       ^

ex.dfy(17,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else \n', '  else\n', '  else\n', '  else \n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t

   |
18 |     match t
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>

   |
19 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(19,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, t_value, right) =>

   |
19 |     case Node(left, t_value, right) =>
   |                                       ^

ex.dfy(19,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, t_value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)

   |
20 |       if value < v then Node(Insert(left, value), v, right)
   |                                                            ^

ex.dfy(20,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then Node(Insert(left, value), v, right)\n', '      if value < v then Node(Insert(left, value), v, right)\n', '      if value < v then Node(Insert(left, value), v, right)\n', '      if value < v then Node(Insert(left, value), v, right)\n', '      if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))

   |
21 |       else if value > v then Node(left, v, Insert(right, value))
   |                                                                 ^

ex.dfy(21,64): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then Node(left, v, Insert(right, value))\n', '      else if value > v then Node(left, v, Insert(right, value))\n', '      else if value > v then Node(left, v, Insert(right, value))\n', '      else if value > v then Node(left, v, Insert(right, value))\n', '      else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t

   |
22 |       else t
   |             ^

ex.dfy(22,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else t\n', '      else t\n', '      else t\n', '      else t\n', '      else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)

SCORE
1.0
['// (4)\n', '// (4)\n', '// (4)\n', '// (4)\n', '// (4)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat) \n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t

   |
28 |   match t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>

   |
29 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(29,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))

   |
30 |     (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)

   |
30 |     (v == value) || Contains(left, value) || Contains(right, value)
   |                                                                    ^

ex.dfy(30,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) : value > v ? Contains(right, value) : true)

   |
30 |     (value < v ? Contains(left, value) : value > v ? Contains(right, value) : true)
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)

   |
30 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(30,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (v == value) || Contains(left, value) || Contains(right, value)\n', '    (value < v ? Contains(left, value) : value > v ? Contains(right, value) : true)\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (value < v) ? Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)
    : (value > v) ? Contains(right, value)

   |
30 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(30,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    : (value > v) ? Contains(right, value)\n', '    : (value > v) ? Contains(right, value)\n', '    : (value > v) ? Contains(right, value)\n', '    : (value > v) ? Contains(right, value)\n', '    : (value > v) ? Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)
    : (value > v) ? Contains(right, value)
    : true

   |
30 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(30,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    : true\n', '    : true\n', '    : true\n', '    : true\n', '    : true\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :

   |
30 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) : value > v ? Contains(right, value) : true)\n', '    (value < v ? Contains(left, value) :\n', '    (value < v ? Contains(left, value) :\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :

   |
30 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) : true)

   |
30 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     value > v ? Contains(right, value) :\n', '     value > v ? Contains(right, value) : true)\n', '     value > v ? Contains(right, value) : true)\n', '     value > v ? Contains(right, value) : true)\n', '     value > v ? Contains(right, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :
     true)

   |
30 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['     true)\n', '     true)\n', '     true)\n', '     true)\n', '     true)\n']
['predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat)\n', 'predicate Contains(t: Tree, value: nat) \n', 'predicate Contains(t: Tree, value: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t

   |
28 |   match t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>

   |
29 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(29,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))

   |
30 |     (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))
   |                ^

ex.dfy(30,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&

   |
30 |     (value < v ==> Contains(left, value)) &&
   |                                             ^

ex.dfy(30,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (value < v ==> Contains(left, value)) &&\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n', '    (value < v ? Contains(left, value) : (value > v ? Contains(right, value) : true))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))

   |
31 |     (value == v || Contains(right, value))
   |                                           ^

ex.dfy(31,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value == v || Contains(right, value))\n', '    (value == v || Contains(right, value))\n', '    (value == v || Contains(right, value))\n', '    (value == v || Contains(right, value))\n', '    (value == v || Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false

   |
32 |   case Leaf() => false
   |                       ^

ex.dfy(32,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => false\n', '  case Leaf() => false\n', '  case Leaf() => false\n', '  case Leaf() => false\n', '  case Leaf() => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)

SCORE
1.0
['// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:inserts} InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}

   |
36 | lemma {:invariant value <= upper}
   |                                  ^

ex.dfy(36,33): Error: a method must be given a name (expecting identifier)
   |
36 | lemma {:invariant value <= upper}
   |                                  ^

ex.dfy(36,33): Error: invalid MethodDecl
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:induction} Insert_Maintains_Contains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:auto} AfterInsert(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesValue(t: Tree, value: nat)\n', 'lemma {:inserts} InsertEnsuresContains(t: Tree, value: nat)\n', 'lemma {:invariant value <= upper}\n', 'lemma {:induction} Insert_Maintains_Contains(t: Tree, value: nat)\n', 'lemma {:auto} AfterInsert(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
Insert_Maintains_Contains(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
{:induction value}

   |
37 | {:induction value}
   |                   ^

ex.dfy(37,18): Error: a method must be given a name (expecting identifier)
   |
37 | {:induction value}
   |                   ^

ex.dfy(37,18): Error: invalid MethodDecl
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
Insert_MaintainsContainment(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)\n', 'Insert_Maintains_Contains(t: Tree, value: nat, lower: nat, upper: nat)\n', '{:induction value}\n', 'Insert_MaintainsContainment(t: Tree, value: nat, lower: nat, upper: nat)\n', '  InsertLemma(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n', '  requires IsBST(t, lower, upper)\n', '  requires IsBST(t, lower, upper)\n', '  requires IsBST(t, lower, upper)\n', '  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then {} else

   |
41 |   if t == Leaf() then {} else
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() 

   |
41 |   if t == Leaf()
   |                 ^

ex.dfy(41,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then

   |
41 |   if t == Leaf() then
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ... recursive calls to InsertLemma1 ...

   |
41 |   // ... recursive calls to InsertLemma1 ...
   |                                             ^

ex.dfy(41,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then {}

   |
41 |   if t == Leaf() then {}
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf() then {} else\n', '  if t == Leaf() \n', '  if t == Leaf() then\n', '  // ... recursive calls to InsertLemma1 ...\n', '  if t == Leaf() then {}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ... recursive calls to InsertLemma1 ...
}

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,10): Related location: this is the postcondition that could not be proved
   |
39 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,33): Related location
  |
9 |     IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  |                                  ^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ...

   |
41 |   // ...
   |         ^

ex.dfy(41,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases

   |
41 |   // base cases
   |                ^

ex.dfy(41,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() {

   |
41 |   if t == Leaf() {
   |                   ^

ex.dfy(41,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // Base case

   |
41 |   // Base case
   |               ^

ex.dfy(41,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n', '  // base cases\n', '  if t == Leaf() {\n', '  if t == Leaf() then {} else\n', '  // Base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()

   |
42 |   if t == Leaf()
   |                 ^

ex.dfy(42,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf() {

   |
42 |   if t == Leaf() {
   |                   ^

ex.dfy(42,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf() then

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf()\n', '  if t == Leaf() {\n', '  if t == Leaf() then\n', '  if t == Leaf() {\n', '  if t == Leaf() {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {

   |
43 |   {
   |    ^

ex.dfy(43,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
    assert IsBST(Node(Leaf(), value, Leaf()), lower, upper);

   |
44 |     assert IsBST(Node(Leaf(), value, Leaf()), lower, upper);
   |                                                             ^

ex.dfy(44,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }

   |
44 |   }
   |    ^

ex.dfy(44,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert IsBST(Node(Leaf(), value, Leaf()), lower, upper);\n', '  }\n', '    assert IsBST(Node(Leaf(), value, Leaf()), lower, upper);\n', '  }\n', '    assert IsBST(Node(Leaf(), value, Leaf()), lower, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value

   |
45 |   else if value < t.value
   |                          ^

ex.dfy(45,25): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else

   |
45 |   else
   |       ^

ex.dfy(45,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < lower || value > upper

   |
45 |   else if value < lower || value > upper
   |                                         ^

ex.dfy(45,40): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if value < t.value\n', '  else\n', '  else\n', '  else if value < lower || value > upper\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {

   |
46 |   {
   |    ^

ex.dfy(46,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);

   |
47 |     InsertLemma1(t.left, value, lower, t.value);
   |                                                 ^

ex.dfy(47,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertLemma1(t.left, value, lower, t.value);\n', '    InsertLemma1(t.left, value, lower, t.value);\n', '    InsertLemma1(t.left, value, lower, t.value);\n', '    InsertLemma1(t.left, value, lower, t.value);\n', '    InsertLemma1(t.left, value, lower, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }

   |
48 |   }
   |    ^

ex.dfy(48,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value

   |
49 |   else if value > t.value
   |                          ^

ex.dfy(49,25): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if value > t.value\n', '  else if value > t.value\n', '  else if value > t.value\n', '  else if value > t.value\n', '  else if value > t.value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {

   |
50 |   {
   |    ^

ex.dfy(50,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);

   |
51 |     InsertLemma1(t.right, value, t.value, upper);
   |                                                  ^

ex.dfy(51,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertLemma1(t.right, value, t.value, upper);\n', '    InsertLemma1(t.right, value, t.value, upper);\n', '    InsertLemma1(t.right, value, t.value, upper);\n', '    InsertLemma1(t.right, value, t.value, upper);\n', '    InsertLemma1(t.right, value, t.value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }

   |
52 |   }
   |    ^

ex.dfy(52,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }
}

ex.dfy(43,2): Error: a postcondition could not be proved on this return path
   |
43 |   {
   |   ^

ex.dfy(39,10): Related location: this is the postcondition that could not be proved
   |
39 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,33): Related location
  |
9 |     IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  |                                  ^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }
  else

   |
53 |   else
   |       ^

ex.dfy(53,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }
  else
  {

   |
54 |   {
   |    ^

ex.dfy(54,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }
  else
  {
  }

   |
55 |   }
   |    ^

ex.dfy(55,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base cases
  if t == Leaf()
  {
  }
  else if value < t.value
  {
    InsertLemma1(t.left, value, lower, t.value);
  }
  else if value > t.value
  {
    InsertLemma1(t.right, value, t.value, upper);
  }
  else
  {
  }
}

ex.dfy(43,2): Error: a postcondition could not be proved on this return path
   |
43 |   {
   |   ^

ex.dfy(39,10): Related location: this is the postcondition that could not be proved
   |
39 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,33): Related location
  |
9 |     IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  |                                  ^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n', '  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t

   |
41 |   // induction on t
   |                    ^

ex.dfy(41,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf()

   |
41 |   if t == Leaf()
   |                 ^

ex.dfy(41,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // base case

   |
41 |   // base case
   |               ^

ex.dfy(41,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction on t\n', '  // ...\n', '  // base cases\n', '  if t == Leaf()\n', '  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
}

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,10): Related location: this is the postcondition that could not be proved
   |
39 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,33): Related location
  |
9 |     IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  |                                  ^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['  if t == Leaf() then\n', '  if t == Leaf() then\n', '  if t == Leaf() then\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
  else 

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
    assert Insert(t, value) == Node(Leaf(), value, Leaf());

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
    // nothing to prove

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
    assert Insert(t, value) == Node(Leaf(), value, Leaf())

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else \n', '    assert Insert(t, value) == Node(Leaf(), value, Leaf());\n', '    // nothing to prove\n', '  else \n', '    assert Insert(t, value) == Node(Leaf(), value, Leaf())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
    // nothing to prove
  else 

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // induction on t
  if t == Leaf() then
    // nothing to prove
  else

   |
42 |   if t == Leaf() then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else \n', '  else\n', '  else \n', '  else\n', '  else \n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // base case\n', '  // Base case\n', '  if t == Leaf() then {}\n', '  if t == Leaf() then\n', '  // induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then {}
  else

   |
41 |   if t == Leaf() then {}
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then {}
  else 

   |
41 |   if t == Leaf() then {}
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else \n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  if t == Leaf() then {}
  else
    match t

   |
41 |   if t == Leaf() then {}
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '  requires IsBST(t, lower, upper)\n', '{\n', '  requires IsBST(t, lower, upper)\n', '  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(Insert(t, value), value)

   |
39 |   Contains(Insert(t, value), value)
   |                                    ^

ex.dfy(39,35): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)

   |
39 |   Contains(t, value)
   |                     ^

ex.dfy(39,20): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  IsBST(t, lower, upper) && Contains(t, value) ==> Contains(Insert(t, value), value)

   |
39 |   IsBST(t, lower, upper) && Contains(t, value) ==> Contains(Insert(t, value), value)
   |                          ^

ex.dfy(39,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  ensures Contains(Insert(t, value), value)

   |
39 |   ensures Contains(Insert(t, value), value)
   |   ^

ex.dfy(39,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(Insert(t, value), value)\n', '  Contains(Insert(t, value), value)\n', '  Contains(t, value)\n', '  IsBST(t, lower, upper) && Contains(t, value) ==> Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
}

   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
} ensures Contains(Insert(t, value), value)

   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
   |
40 | } ensures Contains(Insert(t, value), value)
   |   ^

ex.dfy(40,2): Error: this symbol not expected in Dafny
2 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '} ensures Contains(Insert(t, value), value)\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
}


   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
}
  requires IsBST(t, lower, upper) && lower <= value <= upper;

   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
   |
41 |   requires IsBST(t, lower, upper) && lower <= value <= upper;
   |   ^

ex.dfy(41,2): Error: this symbol not expected in Dafny
2 parse errors detected in ex.dfy

SCORE
-1.0
['\n', '\n', '\n', '\n', '  requires IsBST(t, lower, upper) && lower <= value <= upper;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
}

lemma {:invariant lower <= value <= upper}

   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
   |
42 | lemma {:invariant lower <= value <= upper}
   |                                           ^

ex.dfy(42,42): Error: a method must be given a name (expecting identifier)
   |
42 | lemma {:invariant lower <= value <= upper}
   |                                           ^

ex.dfy(42,42): Error: invalid MethodDecl
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:invariant value <= upper}
  InsertLemma1(t: Tree, value: nat, lower: nat, upper: nat)
{
  Contains(t, value)
}

// (6)

   |
39 |   Contains(t, value)
   |   ^^^^^^^^

ex.dfy(39,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['lemma {:invariant lower <= value <= upper}\n', 'lemma {:invariant lower <= value <= upper}\n', '// (6)\n', '// (6)\n', 'lemma {:invariant lower <= value <= upper}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesMembership

   |
36 | lemma InsertPreservesMembership
   |                                ^

ex.dfy(36,31): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:verify false} InsertPreservesValue(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:inline} Insert_Preserves_Contains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesMembership\n', 'lemma InsertPreservesValue(t: Tree, value: nat)\n', 'lemma InsertPreservesValue(t: Tree, value: nat)\n', 'lemma {:verify false} InsertPreservesValue(t: Tree, value: nat)\n', 'lemma {:inline} Insert_Preserves_Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesMembership
{

   |
37 | {
   | ^

ex.dfy(37,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesMembership
{
  ensures Contains(Insert(t, value), value)

   |
37 | {
   | ^

ex.dfy(37,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesMembership
{
  requires IsBST(t, lower, upper) && value >= lower && value <= upper

   |
37 | {
   | ^

ex.dfy(37,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  requires IsBST(t, lower, upper) && value >= lower && value <= upper\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesMembership
{
  requires IsBST(t, lower, upper) && value >= lower && value <= upper
  ensures Contains(Insert(t, value), value)

   |
37 | {
   | ^

ex.dfy(37,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
['  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n']
['// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:lemma} InsertPreservesValue(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:induction value} InsertPreservesElement(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma {:auto} Insert_Maintains_Contains(t: Tree, value: nat)

SCORE
1.0
['lemma {:lemma} InsertPreservesValue(t: Tree, value: nat)\n', 'lemma InsertPreservesContains(t: Tree, value: nat)\n', 'lemma {:induction value} InsertPreservesElement(t: Tree, value: nat)\n', 'lemma {:auto} Insert_Maintains_Contains(t: Tree, value: nat)\n', 'lemma InsertPreservesValue(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['requires Contains(t, value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // proof by structural induction on t

   |
39 |   // proof by structural induction on t
   |                                        ^

ex.dfy(39,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...

   |
39 |   // ...
   |         ^

ex.dfy(39,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  if t == Leaf()

   |
39 |   if t == Leaf()
   |                 ^

ex.dfy(39,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // base case

   |
39 |   // base case
   |               ^

ex.dfy(39,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on t\n', '  // ...\n', '  if t == Leaf()\n', '  // base case\n', '  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

ex.dfy(38,0): Error: a postcondition could not be proved on this return path
   |
38 | {
   | ^

ex.dfy(37,10): Related location: this is the postcondition that could not be proved
   |
37 |   ensures Contains(Insert(t, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,5): Related location
   |
31 |     (value == v || Contains(right, value))
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),

   |
39 |   // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
   |                                                                                 ^

ex.dfy(39,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t

   |
39 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(39,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
39 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(39,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),\n', '  // Proof by structural induction on t\n', '  if t == Leaf()\n', '  // Proof by structural induction on t.\n', '  if t == Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.

   |
40 |   // which obviously contains value.
   |                                     ^

ex.dfy(40,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which contains value by definition.

   |
40 |   // which contains value by definition.
   |                                         ^

ex.dfy(40,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // and Contains holds because the new value is the root of the tree.

   |
40 |   // and Contains holds because the new value is the root of the tree.
   |                                                                       ^

ex.dfy(40,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which contains the value.

   |
40 |   // which contains the value.
   |                               ^

ex.dfy(40,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // which obviously contains value.\n', '  // which contains value by definition.\n', '  // which obviously contains value.\n', '  // and Contains holds because the new value is the root of the tree.\n', '  // which contains the value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If t is Node, then Insert either returns t (if value is in t),

   |
41 |   // Recursive case: If t is Node, then Insert either returns t (if value is in t),
   |                                                                                    ^

ex.dfy(41,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the

   |
41 |   // Recursive case: If value is in the left subtree of t, then it is also in the
   |                                                                                  ^

ex.dfy(41,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Inductive case: If value < v, then the inserted value must be in left.

   |
41 |   // Inductive case: If value < v, then the inserted value must be in left.
   |                                                                            ^

ex.dfy(41,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Inductive case: If t is Node(left, v, right), then Insert either returns

   |
41 |   // Inductive case: If t is Node(left, v, right), then Insert either returns
   |                                                                              ^

ex.dfy(41,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is less than the root's value, it's inserted into the left subtree.

   |
41 |   // Recursive case: If value is less than the root's value, it's inserted into the left subtree.
   |                                                                                                  ^

ex.dfy(41,97): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Recursive case: If t is Node, then Insert either returns t (if value is in t),\n', '  // Recursive case: If value is in the left subtree of t, then it is also in the\n', '  // Inductive case: If value < v, then the inserted value must be in left.\n', '  // Inductive case: If t is Node(left, v, right), then Insert either returns\n', "  // Recursive case: If value is less than the root's value, it's inserted into the left subtree.\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the result of Insert(t, value). If value is in the right subtree

   |
42 |   // left subtree of the result of Insert(t, value). If value is in the right subtree
   |                                                                                      ^

ex.dfy(42,85): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right

   |
42 |   // left subtree of the resulting tree. Likewise, if value is in the right
   |                                                                            ^

ex.dfy(42,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the Insert result. If value is in the right subtree of t,

   |
42 |   // left subtree of the Insert result. If value is in the right subtree of t,
   |                                                                               ^

ex.dfy(42,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of Insert(t, value). Similarly for the right subtree.

   |
42 |   // left subtree of Insert(t, value). Similarly for the right subtree.
   |                                                                        ^

ex.dfy(42,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // left subtree of the result of Insert(t, value). If value is in the right subtree\n', '  // left subtree of the resulting tree. Likewise, if value is in the right\n', '  // left subtree of the Insert result. If value is in the right subtree of t,\n', '  // left subtree of Insert(t, value). Similarly for the right subtree.\n', '  // left subtree of Insert(t, value). Similarly for the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right
  // subtree of t, then it is also in the right subtree of the resulting tree.

   |
43 |   // subtree of t, then it is also in the right subtree of the resulting tree.
   |                                                                               ^

ex.dfy(43,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // subtree of t, then it is also in the right subtree of the resulting tree.\n', '  // subtree of t, then it is also in the right subtree of the resulting tree.\n', '  // subtree of t, then it is also in the right subtree of the resulting tree.\n', '  // subtree of t, then it is also in the right subtree of the resulting tree.\n', '  // subtree of t, then it is also in the right subtree of the resulting tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right
  // subtree of t, then it is also in the right subtree of the resulting tree.
}

ex.dfy(38,0): Error: a postcondition could not be proved on this return path
   |
38 | {
   | ^

ex.dfy(37,10): Related location: this is the postcondition that could not be proved
   |
37 |   ensures Contains(Insert(t, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,5): Related location
   |
31 |     (value == v || Contains(right, value))
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right
  // subtree of t, then it is also in the right subtree of the resulting tree.
  // If value is equal to the root of t, then it is in the resulting tree.

   |
44 |   // If value is equal to the root of t, then it is in the resulting tree.
   |                                                                           ^

ex.dfy(44,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right
  // subtree of t, then it is also in the right subtree of the resulting tree.
  // If value is equal to the value of t, then it is in the resulting tree.

   |
44 |   // If value is equal to the value of t, then it is in the resulting tree.
   |                                                                            ^

ex.dfy(44,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '  // If value is equal to the root of t, then it is in the resulting tree.\n', '  // If value is equal to the root of t, then it is in the resulting tree.\n', '}\n', '  // If value is equal to the value of t, then it is in the resulting tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case: If t is Leaf(), then Insert returns Node(Leaf(), value, Leaf()),
  // which obviously contains value.
  // Recursive case: If value is in the left subtree of t, then it is also in the
  // left subtree of the resulting tree. Likewise, if value is in the right
  // subtree of t, then it is also in the right subtree of the resulting tree.
  // If value is equal to the root of t, then it is in the resulting tree.
}

ex.dfy(38,0): Error: a postcondition could not be proved on this return path
   |
38 | {
   | ^

ex.dfy(37,10): Related location: this is the postcondition that could not be proved
   |
37 |   ensures Contains(Insert(t, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,5): Related location
   |
31 |     (value == v || Contains(right, value))
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '{\n', '  ensures Contains(Insert(t, value), value)\n', 'requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n', 'ensures Contains(Insert(t, value), value)\n', 'ensures Contains(Insert(t, value), value)\n', 'ensures Contains(Insert(t, value), value)\n', 'ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
40 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(40,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // base case

   |
40 |   // base case
   |               ^

ex.dfy(40,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // ...

   |
40 |   // ...
   |         ^

ex.dfy(40,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // proof by structural induction on t

   |
40 |   // proof by structural induction on t
   |                                        ^

ex.dfy(40,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n', '  // base case\n', '  // ...\n', '  // proof by structural induction on t\n', '  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Leaf()

   |
41 |   if t == Leaf()
   |                 ^

ex.dfy(41,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

ex.dfy(39,0): Error: a postcondition could not be proved on this return path
   |
39 | {
   | ^

ex.dfy(38,8): Related location: this is the postcondition that could not be proved
   |
38 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,5): Related location
   |
31 |     (value == v || Contains(right, value))
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().

   |
41 |   // Base case: t is Leaf().
   |                             ^

ex.dfy(41,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Leaf() then 

   |
41 |   if t == Leaf() then
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Leaf()\n', '}\n', '  // Base case: t is Leaf().\n', '  if t == Leaf() then \n', '  if t == Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since t' is a new node containing value, Contains(t', value) holds.

   |
42 |   //   Since t' is a new node containing value, Contains(t', value) holds.
   |                                                                           ^

ex.dfy(42,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  if t == Leaf() {

   |
42 |   if t == Leaf() {
   |                   ^

ex.dfy(42,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  if t == Leaf()

   |
42 |   if t == Leaf()
   |                 ^

ex.dfy(42,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).

   |
42 |   //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
   |                                                                                          ^

ex.dfy(42,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   The lemma holds because Insert(Leaf(), value) is Node(Leaf(), value, Leaf()),

   |
42 |   //   The lemma holds because Insert(Leaf(), value) is Node(Leaf(), value, Leaf()),
   |                                                                                     ^

ex.dfy(42,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["  //   Since t' is a new node containing value, Contains(t', value) holds.\n", '  if t == Leaf() {\n', '  if t == Leaf()\n', '  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).\n', '  //   The lemma holds because Insert(Leaf(), value) is Node(Leaf(), value, Leaf()),\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).

   |
43 |   //   Therefore, Contains(Insert(t, value), value).
   |                                                     ^

ex.dfy(43,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Hence Contains(Insert(t, value), value) holds.

   |
43 |   //   Hence Contains(Insert(t, value), value) holds.
   |                                                      ^

ex.dfy(43,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Hence, Contains(Insert(t, value), value).

   |
43 |   //   Hence, Contains(Insert(t, value), value).
   |                                                 ^

ex.dfy(43,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value) holds because value == value.

   |
43 |   //   Therefore, Contains(Insert(t, value), value) holds because value == value.
   |                                                                                  ^

ex.dfy(43,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Hence, Contains(Insert(Leaf(), value), value).

   |
43 |   //   Hence, Contains(Insert(Leaf(), value), value).
   |                                                      ^

ex.dfy(43,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   Therefore, Contains(Insert(t, value), value).\n', '  //   Hence Contains(Insert(t, value), value) holds.\n', '  //   Hence, Contains(Insert(t, value), value).\n', '  //   Therefore, Contains(Insert(t, value), value) holds because value == value.\n', '  //   Hence, Contains(Insert(Leaf(), value), value).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).

   |
44 |   // Inductive case: t is Node(left, v, right).
   |                                                ^

ex.dfy(44,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive step: t is Node(left, v, right).

   |
44 |   // Inductive step: t is Node(left, v, right).
   |                                                ^

ex.dfy(44,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive case: t is Node(left, v, right).\n', '  // Inductive case: t is Node(left, v, right).\n', '  // Inductive step: t is Node(left, v, right).\n', '  // Inductive step: t is Node(left, v, right).\n', '  // Inductive case: t is Node(left, v, right).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Node(Insert(left, value), v, right).

   |
45 |   //   If value < v, then Insert(t, value) = Node(Insert(left, value), v, right).
   |                                                                                  ^

ex.dfy(45,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   Since value != v, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).

   |
45 |   //   Since value != v, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).
   |                                                                                                                                ^

ex.dfy(45,127): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   By the definition of Insert, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).

   |
45 |   //   By the definition of Insert, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).
   |                                                                                                                                           ^

ex.dfy(45,138): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).

   |
45 |   //   If value < v, then Insert(t, value) = Insert(left, value).
   |                                                                  ^

ex.dfy(45,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value < v, then Insert(t, value) = Node(Insert(left, value), v, right).\n', '  //   Since value != v, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).\n', '  //   By the definition of Insert, Insert(t, value) is either Node(Insert(left, value), v, right) or Node(left, v, Insert(right, value)).\n', '  //   If value < v, then Insert(t, value) = Insert(left, value).\n', '  //   If value < v, then Insert(t, value) = Node(Insert(left, value), v, right).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   By the inductive hypothesis, Contains(Insert(left, value), value).

   |
46 |   //   By the inductive hypothesis, Contains(Insert(left, value), value).
   |                                                                          ^

ex.dfy(46,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).

   |
46 |   //   Since Contains(left, value), then Contains(Insert(t, value), value).
   |                                                                            ^

ex.dfy(46,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Insert(left, value) = Node(left', value, right') (by induction hypothesis),

   |
46 |   //   Since Insert(left, value) = Node(left', value, right') (by induction hypothesis),
   |                                                                                         ^

ex.dfy(46,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   If value == v, then Insert(t, value) = t.

   |
46 |   //   If value == v, then Insert(t, value) = t.
   |                                                 ^

ex.dfy(46,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   By the inductive hypothesis, Contains(Insert(left, value), value).\n', '  //   Since Contains(left, value), then Contains(Insert(t, value), value).\n', "  //   Since Insert(left, value) = Node(left', value, right') (by induction hypothesis),\n", '  //   If value == v, then Insert(t, value) = t.\n', '  //   Since Contains(left, value), then Contains(Insert(t, value), value).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value == v or > v, then Insert(t, value) = t.

   |
47 |   //   If value == v or > v, then Insert(t, value) = t.
   |                                                        ^

ex.dfy(47,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value > v, then Insert(t, value) = Insert(right, value).

   |
47 |   //   If value > v, then Insert(t, value) = Insert(right, value).
   |                                                                   ^

ex.dfy(47,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   If value == v or > v, then Insert(t, value) = t.\n', '  //   If value > v, then Insert(t, value) = Insert(right, value).\n', '  //   If value > v, then Insert(t, value) = Insert(right, value).\n', '  //   If value > v, then Insert(t, value) = Insert(right, value).\n', '  //   If value > v, then Insert(t, value) = Insert(right, value).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value == v or > v, then Insert(t, value) = t.
  //   Therefore, Contains(Insert(t, value), value).

   |
48 |   //   Therefore, Contains(Insert(t, value), value).
   |                                                     ^

ex.dfy(48,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value == v or > v, then Insert(t, value) = t.
  //   Since Contains(t, value), then Contains(Insert(t, value), value).

   |
48 |   //   Since Contains(t, value), then Contains(Insert(t, value), value).
   |                                                                         ^

ex.dfy(48,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value == v or > v, then Insert(t, value) = t.
  //   Then Contains(Insert(t, value), value).

   |
48 |   //   Then Contains(Insert(t, value), value).
   |                                               ^

ex.dfy(48,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  //   Therefore, Contains(Insert(t, value), value).\n', '  //   Since Contains(t, value), then Contains(Insert(t, value), value).\n', '  //   Therefore, Contains(Insert(t, value), value).\n', '  //   Since Contains(t, value), then Contains(Insert(t, value), value).\n', '  //   Then Contains(Insert(t, value), value).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1)
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) && value <= upper && IsBST(right, value, upper)
  case Leaf() => true
}

// (3)
function Insert(t: Tree, value: nat): Tree
{
  if t == Leaf() then Node(Leaf(), value, Leaf())
  else 
    match t
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else t
}

// (4)
predicate Contains(t: Tree, value: nat) 
{
  match t
  case Node(left, v, right) =>
    (value < v ==> Contains(left, value)) &&
    (value == v || Contains(right, value))
  case Leaf() => false
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  // Base case: t is Leaf().
  //   Since value != Leaf().value, Insert(Leaf(), value) is Node(Leaf(), value, Leaf()).
  //   Therefore, Contains(Insert(t, value), value).
  // Inductive case: t is Node(left, v, right).
  //   If value < v, then Insert(t, value) = Insert(left, value).
  //   Since Contains(left, value), then Contains(Insert(t, value), value).
  //   If value == v or > v, then Insert(t, value) = t.
  //   Since Contains(t, value), then Contains(Insert(t, value), value).
}

ex.dfy(39,0): Error: a postcondition could not be proved on this return path
   |
39 | {
   | ^

ex.dfy(38,8): Related location: this is the postcondition that could not be proved
   |
38 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(31,5): Related location
   |
31 |     (value == v || Contains(right, value))
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 53
number of gen nodes: 27 (including leaves: 5)
number of back nodes: 26 (including leaves: 22)

expansion count: 38 (including failed: 12)

cache stats {'hit': 423, 'miss': 237}
calls to generate 132
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810]

Trial calls: [165, 600, 570, 645, 660]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 648.80 sec, Standard Deviation: 208.77 sec

Call Statistics:

  Min: 165 calls, Max: 660 calls, Average: 528.00 calls, Standard Deviation: 184.30 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810]

Trial calls: [600, 570, 645, 660]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 752.00 sec, Standard Deviation: 35.09 sec

Call Statistics:

  Min: 570 calls, Max: 660 calls, Average: 618.75 calls, Standard Deviation: 35.77 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236]

Trial calls: [165]


Time Statistics:

  Min: 236.00 sec, Max: 236.00 sec, Average: 236.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 165 calls, Max: 165 calls, Average: 165.00 calls, Standard Deviation: 0.00 calls

Trial  6
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n', 'datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null()\n', '// (1) Write an ADT for a tree of natural numbers\n', '// (1) Define the ADT for a tree\n', '// (1) Write an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = 

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n', 'datatype Tree = \n', 'datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Empty\n', '  | Nil()\n', '  | Empty\n', '  | Leaf()\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(value: nat, left: Tree, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks if a given tree is a binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n', '// (2) Predicate that checks if a given tree is a binary search tree (BST)\n', '// (2) Predicate that checks whether a given tree is a binary search tree\n', '// (2) Predicate that checks whether a given tree is a binary search tree\n', '// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(tree: Tree, min: int, max: int)\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&

   |
12 |     min <= value <= max &&
   |                           ^

ex.dfy(12,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min < value && value < max &&

   |
12 |     min < value && value < max &&
   |                                  ^

ex.dfy(12,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    min <= value <= max &&\n', '    min < value && value < max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&

   |
13 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n', '    IsBST(left, min, value - 1) &&\n', '    IsBST(left, min, value - 1) &&\n', '    IsBST(left, min, value - 1) &&\n', '    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
14 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(14,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Function for inserting element into BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Function for inserting an element into a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Function to insert element into BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Function to insert an element into a BST

SCORE
1.0
['// (3) Function for inserting element into BST\n', '// (3) Function for inserting an element into a BST\n', '// (3) Insert function\n', '// (3) Function to insert element into BST\n', '// (3) Function to insert an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires true

SCORE
1.0
['{\n', '{\n', '  requires true\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then Node(Empty, value, Empty)

   |
20 |   if tree == Empty then Node(Empty, value, Empty)
   |                                                  ^

ex.dfy(20,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if tree == Empty then

   |
20 |   if tree == Empty then
   |                        ^

ex.dfy(20,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value

   |
20 |   if value < tree.value
   |                        ^

ex.dfy(20,23): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  match tree

   |
20 |   match tree
   |             ^

ex.dfy(20,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == Empty then Node(Empty, value, Empty)\n', '  if tree == Empty then\n', '  if value < tree.value\n', '  match tree\n', '  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value
  then Node(Insert(tree.left, value), tree.value, tree.right)

   |
21 |   then Node(Insert(tree.left, value), tree.value, tree.right)
   |                                                              ^

ex.dfy(21,61): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  then Node(Insert(tree.left, value), tree.value, tree.right)\n', '  then Node(Insert(tree.left, value), tree.value, tree.right)\n', '  then Node(Insert(tree.left, value), tree.value, tree.right)\n', '  then Node(Insert(tree.left, value), tree.value, tree.right)\n', '  then Node(Insert(tree.left, value), tree.value, tree.right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value
  then Node(Insert(tree.left, value), tree.value, tree.right)
  else if value > tree.value

   |
22 |   else if value > tree.value
   |                             ^

ex.dfy(22,28): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['  else if value > tree.value\n', '  else if value > tree.value\n', '  else if value > tree.value\n', '  else if value > tree.value\n', '  else if value > tree.value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value
  then Node(Insert(tree.left, value), tree.value, tree.right)
  else if value > tree.value
       then Node(tree.left, tree.value, Insert(tree.right, value))

   |
23 |        then Node(tree.left, tree.value, Insert(tree.right, value))
   |                                                                   ^

ex.dfy(23,66): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then Node(tree.left, tree.value, Insert(tree.right, value))\n', '       then Node(tree.left, tree.value, Insert(tree.right, value))\n', '       then Node(tree.left, tree.value, Insert(tree.right, value))\n', '       then Node(tree.left, tree.value, Insert(tree.right, value))\n', '       then Node(tree.left, tree.value, Insert(tree.right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value
  then Node(Insert(tree.left, value), tree.value, tree.right)
  else if value > tree.value
       then Node(tree.left, tree.value, Insert(tree.right, value))
       else tree

   |
24 |        else tree
   |                 ^

ex.dfy(24,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['       else tree\n', '       else tree\n', '       else tree\n', '       else tree\n', '       else tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
{
  if value < tree.value
  then Node(Insert(tree.left, value), tree.value, tree.right)
  else if value > tree.value
       then Node(tree.left, tree.value, Insert(tree.right, value))
       else tree
}

ex.dfy(20,13): Error: destructor 'value' can only be applied to datatype values constructed by 'Node'
   |
20 |   if value < tree.value
   |              ^^^^^^^^^^


Dafny program verifier finished with 1 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value

SCORE
1.0
['{\n', '{\n', '  requires 0 <= value\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  match tree

   |
21 |   match tree
   |             ^

ex.dfy(21,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if value < 0 then tree

   |
21 |   if value < 0 then tree
   |                         ^

ex.dfy(21,24): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then Node(Empty, value, Empty)

   |
21 |   if tree == Empty then Node(Empty, value, Empty)
   |                                                  ^

ex.dfy(21,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then

   |
21 |   if tree == Empty then
   |                        ^

ex.dfy(21,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  if value < 0 then tree\n', '  match tree\n', '  if tree == Empty then Node(Empty, value, Empty)\n', '  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)

   |
22 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(22,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n', '    Node(Empty, value, Empty)\n', '    Node(Empty, value, Empty)\n', '    Node(Empty, value, Empty)\n', '    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else

   |
23 |   else
   |       ^

ex.dfy(23,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree

   |
24 |     match tree
   |               ^

ex.dfy(24,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, treeValue, right) =>

   |
25 |     case Node(left, treeValue, right) =>
   |                                         ^

ex.dfy(25,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>

   |
25 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(25,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, tvalue, right) =>

   |
25 |     case Node(left, tvalue, right) =>
   |                                      ^

ex.dfy(25,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, treeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, tvalue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then

   |
26 |       if value < nodeValue then
   |                                ^

ex.dfy(26,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)

   |
27 |         Node(Insert(left, value), nodeValue, right)
   |                                                    ^

ex.dfy(27,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n', '        Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then

   |
28 |       else if value > nodeValue then
   |                                     ^

ex.dfy(28,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))

   |
29 |         Node(left, nodeValue, Insert(right, value))
   |                                                    ^

ex.dfy(29,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n', '        Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else

   |
30 |       else
   |           ^

ex.dfy(30,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n', '      else\n', '      else\n', '      else\n', '      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree

   |
31 |         tree
   |             ^

ex.dfy(31,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        tree\n', '        tree\n', '        tree\n', '        tree\n', '        tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function

SCORE
1.0
['// (4) Contains function\n', '// (4) Contains function\n', '// (4) Contains function\n', '// (4) Contains function\n', '// (4) Contains function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool

SCORE
1.0
['function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n', 'function Contains(tree: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  requires 0 <= value

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{

   |
36 | {
   |  ^

ex.dfy(36,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree

   |
36 |   reads tree
   |         ^^^^

ex.dfy(36,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  requires 0 <= value\n', '{\n', '  requires 0 <= value\n', '  reads tree\n', '  requires 0 <= value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{

   |
37 | {
   |  ^

ex.dfy(37,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  match tree

   |
38 |   match tree
   |             ^

ex.dfy(38,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then

   |
38 |   if tree == Empty then
   |                        ^

ex.dfy(38,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  match tree\n', '  if tree == Empty then\n', '  match tree\n', '  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false

   |
39 |     false
   |          ^

ex.dfy(39,9): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    false\n', '    false\n', '    false\n', '    false\n', '    false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else

   |
40 |   else
   |       ^

ex.dfy(40,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree

   |
41 |     match tree
   |               ^

ex.dfy(41,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>

   |
42 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(42,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then

   |
43 |       if value < nodeValue then
   |                                ^

ex.dfy(43,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n', '      if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)

   |
44 |         Contains(left, value)
   |                              ^

ex.dfy(44,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Contains(left, value)\n', '        Contains(left, value)\n', '        Contains(left, value)\n', '        Contains(left, value)\n', '        Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)
      else if value > nodeValue then

   |
45 |       else if value > nodeValue then
   |                                     ^

ex.dfy(45,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n', '      else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)
      else if value > nodeValue then
        Contains(right, value)

   |
46 |         Contains(right, value)
   |                               ^

ex.dfy(46,30): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Contains(right, value)\n', '        Contains(right, value)\n', '        Contains(right, value)\n', '        Contains(right, value)\n', '        Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)
      else if value > nodeValue then
        Contains(right, value)
      else

   |
47 |       else
   |           ^

ex.dfy(47,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n', '      else\n', '      else\n', '      else\n', '      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)
      else if value > nodeValue then
        Contains(right, value)
      else
        true

   |
48 |         true
   |             ^

ex.dfy(48,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        true\n', '        true\n', '        true\n', '        true\n', '        true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
  reads tree
{
  if tree == Empty then
    false
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Contains(left, value)
      else if value > nodeValue then
        Contains(right, value)
      else
        true
}

   |
36 |   reads tree
   |         ^^^^

ex.dfy(36,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '  reads tree\n', '  reads tree\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree

   |
37 |   match tree
   |             ^

ex.dfy(37,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  if tree == Empty then

   |
37 |   if tree == Empty then
   |                        ^

ex.dfy(37,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n', '  match tree\n', '  match tree\n', '  match tree\n', '  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false

   |
38 |   case Empty => false
   |                      ^

ex.dfy(38,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>

   |
39 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(39,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n', '  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then

   |
40 |     if value < nodeValue then
   |                              ^

ex.dfy(40,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue then\n', '    if value < nodeValue then\n', '    if value < nodeValue then\n', '    if value < nodeValue then\n', '    if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)

   |
41 |       Contains(left, value)
   |                            ^

ex.dfy(41,27): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Contains(left, value)\n', '      Contains(left, value)\n', '      Contains(left, value)\n', '      Contains(left, value)\n', '      Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then

   |
42 |     else if value > nodeValue then
   |                                   ^

ex.dfy(42,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue then\n', '    else if value > nodeValue then\n', '    else if value > nodeValue then\n', '    else if value > nodeValue then\n', '    else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)

   |
43 |       Contains(right, value)
   |                             ^

ex.dfy(43,28): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Contains(right, value)\n', '      Contains(right, value)\n', '      Contains(right, value)\n', '      Contains(right, value)\n', '      Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else

   |
44 |     else
   |         ^

ex.dfy(44,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else\n', '    else\n', '    else\n', '    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true

   |
45 |       true
   |           ^

ex.dfy(45,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      true\n', '      true\n', '      true\n', '      true\n', '      true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma about the insert function preserving membership

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma about Insert function preserving containment

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma about insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma about Insert function

SCORE
1.0
['// (5) Lemma about the insert function preserving membership\n', '// (5) Lemma about Insert function preserving containment\n', '// (5) Lemma about insert function that ensures the tree resulting from inserting an element contains that element\n', '// (5) Lemma for Insert function\n', '// (5) Lemma about Insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, x: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesValue(tree: Tree, value: nat, oldValue: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertMaintainsContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, x: nat)\n', 'lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)\n', 'lemma InsertPreservesValue(tree: Tree, value: nat, oldValue: nat)\n', 'lemma InsertMaintainsContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(newTree, value)

   |
51 |   Contains(newTree, value)
   |                           ^

ex.dfy(51,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == true

   |
51 |   ensures Contains(newTree, value) == true
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(newTree, value)\n', '  ensures Contains(newTree, value)\n', '  ensures Contains(newTree, value) == true\n', '  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)\n', '  ensures Contains(newTree, value) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)
  // proof here

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)
  // The proof of this lemma will be skipped for brevity.

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)
  ensures newTree == Insert(tree, value)

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)
  decreases tree

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof here\n', '  // The proof of this lemma will be skipped for brevity.\n', '  ensures newTree == Insert(tree, value)\n', '  ensures newTree == Insert(tree, value)\n', '  decreases tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value)
  // The proof of this lemma will be skipped for brevity.
}

   |
51 |   ensures Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Ensures Contains(newTree, value) == true

   |
51 |   Ensures Contains(newTree, value) == true
   |   ^^^^^^^

ex.dfy(51,2): Error: missing semicolon at end of statement
   |
51 |   Ensures Contains(newTree, value) == true
   |                                    ^

ex.dfy(51,35): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Ensures Contains(newTree, value)

   |
51 |   Ensures Contains(newTree, value)
   |   ^^^^^^^

ex.dfy(51,2): Error: missing semicolon at end of statement
   |
51 |   Ensures Contains(newTree, value)
   |                                   ^

ex.dfy(51,34): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(Insert(tree, value), value) == true

   |
51 |   Contains(Insert(tree, value), value) == true
   |                                        ^

ex.dfy(51,39): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Ensures Contains(newTree, value) == true\n', '  Ensures Contains(newTree, value)\n', '  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)\n', '  Contains(Insert(tree, value), value) == true\n', '  Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
  ensures Contains(newTree, value) ==> value <= tree.value

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
  ensures Contains(newTree, value) == true

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(newTree, value) ==> value <= tree.value\n', '}\n', '  ensures Contains(newTree, value) == true\n', '  ensures Contains(newTree, value) == true\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}


   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}

lemma InsertEnsuresBST(tree: Tree, value: nat, newTree: Tree, min: int, max: int)

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}

lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}

// (6) Lemma for Insert function

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
}

// (6) Lemma for BST property

   |
51 |   ensures Contains(newTree, value) == Contains(tree, value) || Contains(newTree, value)
   |   ^

ex.dfy(51,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['lemma InsertEnsuresBST(tree: Tree, value: nat, newTree: Tree, min: int, max: int)\n', 'lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)\n', '// (6) Lemma for Insert function\n', '// (6) Lemma for Insert function\n', '// (6) Lemma for BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertEnsuresContains(tree: Tree, value: nat, result: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma Insert_Maintains_Contains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n', 'lemma InsertEnsuresContains(tree: Tree, value: nat)\n', 'lemma InsertEnsuresContains(tree: Tree, value: nat, result: Tree)\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)\n', 'lemma Insert_Maintains_Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  requires 0 <= value && 0 <= v

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value

SCORE
1.0
['  requires 0 <= value && 0 <= v\n', '  requires 0 <= value && 0 <= v\n', '{\n', '  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{

   |
51 | {
   |  ^

ex.dfy(51,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // induction based on structure of tree

   |
52 |   // induction based on structure of tree
   |                                          ^

ex.dfy(52,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree

   |
52 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(52,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  if tree == Empty then

   |
52 |   if tree == Empty then
   |                    ^

ex.dfy(52,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // base case: tree is empty

   |
52 |   // base case: tree is empty
   |                              ^

ex.dfy(52,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction based on structure of tree\n', '  // Proof by structural induction on tree\n', '  if tree == Empty then\n', '  // base case: tree is empty\n', '  if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
}

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '  if tree == Empty then\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
  {

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Empty, v) == false;

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Insert(tree, value), v) == Contains(Node(Empty, value, Empty), v);

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Insert(tree, value), v) == Contains(Empty, v);

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Empty, value) == false;

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '    assert Contains(Empty, v) == false;\n', '    assert Contains(Insert(tree, value), v) == Contains(Node(Empty, value, Empty), v);\n', '    assert Contains(Insert(tree, value), v) == Contains(Empty, v);\n', '    assert Contains(Empty, value) == false;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Insert(tree, value), v) == Contains(Node(Empty, value, Empty), v);
    assert Contains(tree, v) == Contains(Empty, v);

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Insert(tree, value), v) == Contains(Node(Empty, value, Empty), v);
    assert Contains(tree, v) == false;

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // Proof by structural induction on tree
  if tree == Empty then
    assert Contains(Insert(tree, value), v) == Contains(Node(Empty, value, Empty), v);
    assert Contains(Node(Empty, value, Empty), v) == (v == value);

   |
53 |   if tree == Empty then
   |                    ^

ex.dfy(53,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Contains(tree, v) == Contains(Empty, v);\n', '    assert Contains(tree, v) == Contains(Empty, v);\n', '    assert Contains(tree, v) == false;\n', '    assert Contains(tree, v) == Contains(Empty, v);\n', '    assert Contains(Node(Empty, value, Empty), v) == (v == value);\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // induction on tree

   |
52 |   // induction on tree
   |                       ^

ex.dfy(52,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // base case

   |
52 |   // base case
   |               ^

ex.dfy(52,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // proof by structural induction on tree

   |
52 |   // proof by structural induction on tree
   |                                           ^

ex.dfy(52,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...

   |
52 |   // ...
   |         ^

ex.dfy(52,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction on tree\n', '  // base case\n', '  // Proof by structural induction on tree\n', '  // proof by structural induction on tree\n', '  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property

SCORE
1.0
['// (6) Lemma for Insert function\n', '// (6) Lemma for Insert function\n', '// (6) Lemma for Insert function\n', '// (6) Lemma for Insert function preserving BST property\n', '// (6) Lemma for Insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesIsBST(tree: Tree, value: nat, min: int, max: int)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertMaintainsBST(tree: Tree, value: nat, min: int, max: int)

SCORE
1.0
['lemma InsertPreservesIsBST(tree: Tree, value: nat, min: int, max: int)\n', 'lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)\n', 'lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)\n', 'lemma InsertMaintainsBST(tree: Tree, value: nat, min: int, max: int)\n', 'lemma InsertPreservesIsBST(tree: Tree, value: nat, min: int, max: int)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max + 1

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= value && min <= max

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= value

SCORE
1.0
['  requires 0 <= min <= max + 1\n', '  requires 0 <= value && min <= max\n', '  requires 0 <= min <= max\n', '  requires 0 <= value && min <= max\n', '  requires 0 <= value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)

SCORE
1.0
['  requires IsBST(tree, min, max)\n', '  requires IsBST(tree, min, max)\n', '  requires IsBST(tree, min, max)\n', '  requires IsBST(tree, min, max)\n', '  requires IsBST(tree, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n', '  requires min <= value <= max\n', '  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n', '  ensures IsBST(Insert(tree, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{

   |
61 | {
   |  ^

ex.dfy(61,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // ...

   |
62 |   // ...
   |         ^

ex.dfy(62,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // ...
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // ...
}
``` import {Injectable} from '@angular/core';

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // ...
}
```

SCORE
1.0
["``` import {Injectable} from '@angular/core';\n", '```\n', '```\n', '```\n', '```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: int, max: int)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    min <= value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

// (3) Insert function
function Insert(tree: Tree, value: nat): Tree
  requires 0 <= value
{
  if tree == Empty then
    Node(Empty, value, Empty)
  else
    match tree
    case Node(left, nodeValue, right) =>
      if value < nodeValue then
        Node(Insert(left, value), nodeValue, right)
      else if value > nodeValue then
        Node(left, nodeValue, Insert(right, value))
      else
        tree
}

// (4) Contains function
function Contains(tree: Tree, value: nat): bool
{
  match tree
  case Empty => false
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Contains(left, value)
    else if value > nodeValue then
      Contains(right, value)
    else
      true
}

// (5) Lemma for Insert function
lemma InsertPreservesContains(tree: Tree, value: nat, v: nat)
  ensures Contains(Insert(tree, value), v) == Contains(tree, v) || v == value
{
  // ...
}

// (6) Lemma for Insert function preserving BST property
lemma InsertPreservesBST(tree: Tree, value: nat, min: int, max: int)
  requires 0 <= min <= max
  requires IsBST(tree, min, max)
  requires min <= value <= max
  ensures IsBST(Insert(tree, value), min, max)
{
  // ...
}
```


STATS

number of nodes: 63
number of gen nodes: 32 (including leaves: 2)
number of back nodes: 31 (including leaves: 30)

expansion count: 36 (including failed: 5)

cache stats {'hit': 324, 'miss': 176}
calls to generate 100
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810, 619]

Trial calls: [165, 600, 570, 645, 660, 500]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 643.83 sec, Standard Deviation: 190.91 sec

Call Statistics:

  Min: 165 calls, Max: 660 calls, Average: 523.33 calls, Standard Deviation: 168.56 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810]

Trial calls: [600, 570, 645, 660]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 752.00 sec, Standard Deviation: 35.09 sec

Call Statistics:

  Min: 570 calls, Max: 660 calls, Average: 618.75 calls, Standard Deviation: 35.77 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 619]

Trial calls: [165, 500]


Time Statistics:

  Min: 236.00 sec, Max: 619.00 sec, Average: 427.50 sec, Standard Deviation: 191.50 sec

Call Statistics:

  Min: 165 calls, Max: 500 calls, Average: 332.50 calls, Standard Deviation: 167.50 calls

Trial  7
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['// (1) ADT for a tree\n', '// (1) Define an ADT for a tree\n', '// ADT for a tree of natural numbers\n', '// (1) ADT for a tree\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree =\n', 'datatype Tree =\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
    Empty |

  |
3 |     Empty |
  |            ^

ex.dfy(3,11): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['  | Empty\n', '  | Empty\n', '  | Nil\n', '  | Nil\n', '    Empty |\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(value: nat, left: Tree, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(value: nat, left: Tree, right: Tree)\n', '  | Node(value: nat, left: Tree, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for BST\n', '// (2) Predicate for checking BST\n', '// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '  reads t\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true

   |
11 |   case Nil => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(left, x, right) =>

   |
12 |   case Node(left, x, right) =>
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(l, v, r) =>

   |
12 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(12,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, x, right) =>\n', '  case Node(l, v, r) =>\n', '  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&

   |
13 |     v >= min && v <= max &&
   |                            ^

ex.dfy(13,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&

   |
14 |     IsBST(l, min, v) &&
   |                        ^

ex.dfy(14,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)

   |
15 |     IsBST(r, v, max)
   |                     ^

ex.dfy(15,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '  reads t\n', '{\n', '  reads t\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true

   |
10 |   case Nil => true
   |                   ^

ex.dfy(10,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n', '  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, v, right) =>

   |
11 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&

   |
12 |     value >= min && value < max &&
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value < max &&\n', '    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&

   |
13 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
14 |     IsBST(right, value, max)
   |                             ^

ex.dfy(14,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n', '    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert element into BST

SCORE
1.0
['// (3) Insert function\n', '// (3) Function to insert an element\n', '// (3) Insert element into BST\n', '// (3) Insert function\n', '// (3) Insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n', 'function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else

   |
20 |   if t == Nil then Node(Nil, value, Nil) else
   |                                              ^

ex.dfy(20,45): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then

   |
20 |   if t == Nil then
   |                   ^

ex.dfy(20,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
20 |   match t
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then Node(Nil, value, Nil) else\n', '  if t == Nil then\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
    match t

   |
21 |     match t
   |            ^

ex.dfy(21,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t

   |
21 |   match t
   |          ^

ex.dfy(21,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tValue, right) =>

   |
22 |   case Node(left, tValue, right) =>
   |                                    ^

ex.dfy(22,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>

   |
22 |   case Node(left, tvalue, right) =>
   |                                    ^

ex.dfy(22,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, v, right) =>

   |
22 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(22,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, t_value, right) =>

   |
22 |   case Node(left, t_value, right) =>
   |                                     ^

ex.dfy(22,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tValue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, t_value, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)

   |
23 |     if value < tvalue then Node(Insert(left, value), tvalue, right)
   |                                                                    ^

ex.dfy(23,67): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right) else

   |
23 |     if value < tvalue then Node(Insert(left, value), tvalue, right) else
   |                                                                         ^

ex.dfy(23,72): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then

   |
23 |     if value < tvalue then
   |                           ^

ex.dfy(23,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tvalue then Node(Insert(left, value), tvalue, right)\n', '    if value < tvalue then Node(Insert(left, value), tvalue, right) else\n', '    if value < tvalue then Node(Insert(left, value), tvalue, right)\n', '    if value < tvalue then Node(Insert(left, value), tvalue, right) else\n', '    if value < tvalue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))

   |
24 |     else if value > tvalue then Node(left, tvalue, Insert(right, value))
   |                                                                         ^

ex.dfy(24,72): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > tvalue then Node(left, tvalue, Insert(right, value))\n', '    else if value > tvalue then Node(left, tvalue, Insert(right, value))\n', '    else if value > tvalue then Node(left, tvalue, Insert(right, value))\n', '    else if value > tvalue then Node(left, tvalue, Insert(right, value))\n', '    else if value > tvalue then Node(left, tvalue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t

   |
25 |     else t
   |           ^

ex.dfy(25,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n', '    else t\n', '    else t\n', '    else t\n', '    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Contains element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Contains function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for containment

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains

SCORE
1.0
['// (4) Contains element\n', '// (4) Contains function\n', '// (4) Predicate for containment\n', '// (4) Predicate for contains\n', '// (4) Contains function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n', 'function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{

   |
30 | {
   |  ^

ex.dfy(30,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t

   |
31 |   match t
   |          ^

ex.dfy(31,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false

   |
32 |   case Nil => false
   |                    ^

ex.dfy(32,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>

   |
33 |   case Node(left, tvalue, right) =>
   |                                    ^

ex.dfy(33,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)

   |
34 |     if value < tvalue then Contains(left, value)
   |                                                 ^

ex.dfy(34,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||

   |
34 |     value == tvalue ||
   |                       ^

ex.dfy(34,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue || Contains(left, value) || Contains(right, value)

   |
34 |     value == tvalue || Contains(left, value) || Contains(right, value)
   |                                                                       ^

ex.dfy(34,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value < tvalue ? Contains(left, value) :

   |
34 |     value < tvalue ? Contains(left, value) :
   |                    ^

ex.dfy(34,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tvalue then Contains(left, value)\n', '    value == tvalue ||\n', '    value == tvalue ||\n', '    value == tvalue || Contains(left, value) || Contains(right, value)\n', '    value < tvalue ? Contains(left, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < tvalue ? Contains(left, value) : Contains(right, value))\n', '    (value < tvalue ? Contains(left, value) : Contains(right, value))\n', '    (value < tvalue ? Contains(left, value) : Contains(right, value))\n', '    (value < tvalue ? Contains(left, value) : Contains(right, value))\n', '    (value < tvalue ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}


   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

// (5) Lemma about insertion

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

// (5) Lemma for insert function without BST property

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

// (5) Lemma about insert preserving containment

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

// (5) Lemma for insert

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    value == tvalue ||
    (value < tvalue ? Contains(left, value) : Contains(right, value))
}

// (5) Lemma about insertion preserving containership

   |
35 |     (value < tvalue ? Contains(left, value) : Contains(right, value))
   |                     ^

ex.dfy(35,20): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (5) Lemma about insertion\n', '// (5) Lemma for insert function without BST property\n', '// (5) Lemma about insert preserving containment\n', '// (5) Lemma for insert\n', '// (5) Lemma about insertion preserving containership\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
['  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n', '  case Nil => false\n']
['  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n', '  case Node(left, tvalue, right) =>\n']
['    if value < tvalue then Contains(left, value)\n', '    if value < tvalue then Contains(left, value)\n', '    if value < tvalue then Contains(left, value)\n', '    if value < tvalue then Contains(left, value)\n', '    if value < tvalue then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)

   |
35 |     else if value > tvalue then Contains(right, value)
   |                                                       ^

ex.dfy(35,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > tvalue then Contains(right, value)\n', '    else if value > tvalue then Contains(right, value)\n', '    else if value > tvalue then Contains(right, value)\n', '    else if value > tvalue then Contains(right, value)\n', '    else if value > tvalue then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true

   |
36 |     else true
   |              ^

ex.dfy(36,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n', '    else true\n', '    else true\n', '    else true\n', '    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma for insertion preserving Contains

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma for insertion preserving contains

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insert

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma for insert function without BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property

SCORE
1.0
['// (5) Lemma for insertion preserving Contains\n', '// (5) Lemma for insertion preserving contains\n', '// (5) Lemma about insert\n', '// (5) Lemma for insert function without BST property\n', '// (5) Lemma about insertion without BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertPreservesContains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:verify false} InsertPreservesMembership(t: Tree, value: nat, old_t: Tree)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, value: nat)\n', 'lemma InsertPreservesContains(t: Tree, value: nat)\n', 'lemma InsertPreservesContains(t: Tree, value: nat)\n', 'lemma InsertMaintainsContains {\n', 'lemma {:verify false} InsertPreservesMembership(t: Tree, value: nat, old_t: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires t != Nil;

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires t != Nil && value != tvalue;

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires Contains(t, value);

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires t != Nil && tvalue == Insert(t, value) && min <= value < max;

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['  requires t != Nil;\n', '  requires t != Nil && value != tvalue;\n', '  requires Contains(t, value);\n', '  requires Contains(t, value);\n', '  requires t != Nil && tvalue == Insert(t, value) && min <= value < max;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires Contains(t, value);
  ensures Contains(Insert(t, value'), value) && Contains(t, value');

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires Contains(t, value);
  ensures Contains(Insert(t, newValue), value);

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires Contains(t, value);
  ensures Contains(Insert(t, value'), value) && Contains(Insert(t, value'), value');

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertMaintainsContains {
  requires Contains(t, value);
  ensures Contains(Insert(t, value'), value);

   |
40 | lemma InsertMaintainsContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
["  ensures Contains(Insert(t, value'), value) && Contains(t, value');\n", '  ensures Contains(Insert(t, newValue), value);\n', "  ensures Contains(Insert(t, value'), value) && Contains(Insert(t, value'), value');\n", "  ensures Contains(Insert(t, value'), value);\n", "  ensures Contains(Insert(t, value'), value) && Contains(Insert(t, value'), value');\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertNoBST(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma Insert_Preserves_Contains(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma InsertPreservesContains {

   |
40 | lemma InsertPreservesContains {
   |                               ^

ex.dfy(40,30): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['lemma InsertPreservesContains(t: Tree, value: nat)\n', 'lemma InsertNoBST(t: Tree, value: nat)\n', 'lemma Insert_Preserves_Contains(t: Tree, value: nat)\n', 'lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)\n', 'lemma InsertPreservesContains {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n', '  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
42 | {
   |  ^

ex.dfy(42,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  if t == Nil then

   |
43 |   if t == Nil then
   |               ^

ex.dfy(43,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t

   |
43 |   // Proof by induction on t
   |                             ^

ex.dfy(43,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case:

   |
43 |   // Base case:
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then\n', '  if t == Nil then\n', '  // Proof by induction on t\n', '  if t == Nil then\n', '  // Base case:\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case:
  if t == Nil then

   |
44 |   if t == Nil then
   |               ^

ex.dfy(44,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Nil then\n', '  if t == Nil then\n', '  if t == Nil then\n', '  if t == Nil then\n', '  if t == Nil then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case:
  if t == Nil then
  {

   |
44 |   if t == Nil then
   |               ^

ex.dfy(44,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case:
  if t == Nil then
    assert Contains(Node(Nil, value, Nil), value);

   |
44 |   if t == Nil then
   |               ^

ex.dfy(44,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '    assert Contains(Node(Nil, value, Nil), value);\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base case:
  if t == Nil then
    assert Contains(Node(Nil, value, Nil), value);
  else

   |
44 |   if t == Nil then
   |               ^

ex.dfy(44,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ... proof ...

   |
43 |   // ... proof ...
   |                   ^

ex.dfy(43,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  if t == Nil {

   |
43 |   if t == Nil {
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases

   |
43 |   // Base cases
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // base case

   |
43 |   // base case
   |               ^

ex.dfy(43,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ... proof ...\n', '  if t == Nil {\n', '  // Proof by induction on t\n', '  // Base cases\n', '  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
  match t

   |
44 |   match t
   |          ^

ex.dfy(44,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
  if t == Nil then

   |
44 |   if t == Nil then
   |               ^

ex.dfy(44,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

SCORE
1.0
['  match t\n', '  if t == Nil then\n', '}\n', '  match t\n', '  if t == Nil then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion maintaining BST

SCORE
1.0
['// (6) Lemma about insertion with BST property\n', '// (6) Lemma about BST property after insertion\n', '// (6) Lemma about insertion maintaining BST\n', '// (6) Lemma about insertion with BST property\n', '// (6) Lemma about insertion with BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t

   |
51 |   // Proof by induction on t
   |                             ^

ex.dfy(51,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t
}

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value < max &&
   |     ^^^^^^^^^^^^

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value < max &&
   |                     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t

   |
51 |   // Proof by induction on t
   |                             ^

ex.dfy(51,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property after insertion
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t
}

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value < max &&
   |     ^^^^^^^^^^^^

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value < max &&
   |                     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion maintaining BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about BST property preservation after insertion

SCORE
1.0
['// (6) Lemma about insertion maintaining BST property\n', '// (6) Lemma about insertion with BST property\n', '// (6) Lemma about BST property preservation after insertion\n', '// (6) Lemma about insertion with BST property\n', '// (6) Lemma about BST property after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_IsBST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
50 | {
   |  ^

ex.dfy(50,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t

   |
51 |   // Proof by induction on t
   |                             ^

ex.dfy(51,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Nil => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Insert function
function Insert(t: Tree, value: nat): Tree
{
  if t == Nil then Node(Nil, value, Nil) else
  match t
  case Node(left, tvalue, right) =>
    if value < tvalue then Node(Insert(left, value), tvalue, right)
    else if value > tvalue then Node(left, tvalue, Insert(right, value))
    else t
}

// (4) Predicate for contains
function Contains(t: Tree, value: nat): bool
{
  match t
  case Nil => false
  case Node(left, tvalue, right) =>
    if value < tvalue then Contains(left, value)
    else if value > tvalue then Contains(right, value)
    else true
}

// (5) Lemma about insertion without BST property
lemma {:autocontracts} Insert_NoBST(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by induction on t
}

// (6) Lemma about insertion with BST property
lemma {:autocontracts} Insert_BST(t: Tree, value: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by induction on t
}

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     value >= min && value < max &&
   |     ^^^^^^^^^^^^

ex.dfy(50,0): Error: a postcondition could not be proved on this return path
   |
50 | {
   | ^

ex.dfy(49,10): Related location: this is the postcondition that could not be proved
   |
49 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,20): Related location
   |
12 |     value >= min && value < max &&
   |                     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
['  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n', '  ensures IsBST(Insert(t, value), min, max)\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n', '  // Proof by induction on t\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 83
number of gen nodes: 42 (including leaves: 9)
number of back nodes: 41 (including leaves: 33)

expansion count: 65 (including failed: 24)

cache stats {'hit': 607, 'miss': 148}
calls to generate 151
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810, 619, 721]

Trial calls: [165, 600, 570, 645, 660, 500, 755]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 654.86 sec, Standard Deviation: 178.80 sec

Call Statistics:

  Min: 165 calls, Max: 755 calls, Average: 556.43 calls, Standard Deviation: 175.86 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810, 721]

Trial calls: [600, 570, 645, 660, 755]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 745.80 sec, Standard Deviation: 33.75 sec

Call Statistics:

  Min: 570 calls, Max: 755 calls, Average: 646.00 calls, Standard Deviation: 63.20 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 619]

Trial calls: [165, 500]


Time Statistics:

  Min: 236.00 sec, Max: 619.00 sec, Average: 427.50 sec, Standard Deviation: 191.50 sec

Call Statistics:

  Min: 165 calls, Max: 500 calls, Average: 332.50 calls, Standard Deviation: 167.50 calls

Trial  8
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree =\n', '// ADT for a tree of natural numbers\n', 'datatype Tree =\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
    | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Empty

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '    | Empty\n', '  | Empty\n', '  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

SCORE
1.0
['  | Leaf\n', '  | Empty\n', '  | Leaf\n', '  | Leaf()\n', '  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(t: Tree, lo: int, hi: int)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['function IsBST(t: Tree): bool\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lo: int, hi: int)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>

  |
8 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(8,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(left, v, right) =>

  |
8 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(8,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n', '  case Node(left, v, right) =>\n', '  case Node(l, v, r) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) &&

  |
9 |     IsBST(l) &&
  |                ^

ex.dfy(9,15): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&

  |
9 |     IsBST(l) && IsBST(r) &&
  |                            ^

ex.dfy(9,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l) &&\n', '    IsBST(l) && IsBST(r) &&\n', '    IsBST(l) &&\n', '    IsBST(l) &&\n', '    IsBST(l) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (

   |
10 |     (
   |      ^

ex.dfy(10,5): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (l == Empty || MaxValue(l) < v) &&

   |
10 |     (l == Empty || MaxValue(l) < v) &&
   |                                       ^

ex.dfy(10,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (l == Empty || l.value <= v) &&

   |
10 |     (l == Empty || l.value <= v) &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (\n', '    (\n', '    (l == Empty || MaxValue(l) < v) &&\n', '    (l == Empty || MaxValue(l) < v) &&\n', '    (l == Empty || l.value <= v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) ||

   |
11 |       (l == Empty) ||
   |                      ^

ex.dfy(11,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || (v > Max(l))

   |
11 |       (l == Empty) || (v > Max(l))
   |                                   ^

ex.dfy(11,34): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || TreeMax(l) < v

   |
11 |       (l == Empty) || TreeMax(l) < v
   |                                     ^

ex.dfy(11,36): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v

   |
11 |       (l == Empty) || BSTMax(l) < v
   |                                    ^

ex.dfy(11,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty && v <= r.minValue()) ||

   |
11 |       (l == Empty && v <= r.minValue()) ||
   |                                           ^

ex.dfy(11,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      (l == Empty) ||\n', '      (l == Empty) || (v > Max(l))\n', '      (l == Empty) || TreeMax(l) < v\n', '      (l == Empty) || BSTMax(l) < v\n', '      (l == Empty && v <= r.minValue()) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) && (

   |
12 |     ) && (
   |           ^

ex.dfy(12,10): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) &&

   |
12 |     ) &&
   |         ^

ex.dfy(12,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    ) && (\n', '    ) && (\n', '    ) && (\n', '    ) && (\n', '    ) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) && (
      (r == Empty) || v < BSTMin(r)

   |
13 |       (r == Empty) || v < BSTMin(r)
   |                                    ^

ex.dfy(13,35): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['      (r == Empty) || v < BSTMin(r)\n', '      (r == Empty) || v < BSTMin(r)\n', '      (r == Empty) || v < BSTMin(r)\n', '      (r == Empty) || v < BSTMin(r)\n', '      (r == Empty) || v < BSTMin(r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) && (
      (r == Empty) || v < BSTMin(r)
    )

   |
14 |     )
   |      ^

ex.dfy(14,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    )\n', '    )\n', '    )\n', '    )\n', '    )\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) && (
      (r == Empty) || v < BSTMin(r)
    )
  case Empty => true

   |
15 |   case Empty => true
   |                     ^

ex.dfy(15,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(l, v, r) =>
    IsBST(l) && IsBST(r) &&
    (
      (l == Empty) || BSTMax(l) < v
    ) && (
      (r == Empty) || v < BSTMin(r)
    )
  case Empty => true
}

   |
11 |       (l == Empty) || BSTMax(l) < v
   |                       ^^^^^^

ex.dfy(11,22): Error: unresolved identifier: BSTMax
   |
13 |       (r == Empty) || v < BSTMin(r)
   |                           ^^^^^^

ex.dfy(13,26): Error: unresolved identifier: BSTMin
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Node(left, value, right) =>

  |
8 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(8,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(l, v, r) =>

  |
9 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(9,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&

   |
10 |     IsBST(left) &&
   |                   ^

ex.dfy(10,18): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left) &&\n', '    IsBST(left) &&\n', '    IsBST(left) &&\n', '    IsBST(left) &&\n', '    IsBST(left) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left

   |
11 |     (match left
   |                ^

ex.dfy(11,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || Node?left && left.value < value) &&

   |
11 |     (left == Empty || Node?left && left.value < value) &&
   |                                 ^^

ex.dfy(11,32): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
11 |     (left == Empty || Node?left && left.value < value) &&
   |                                                          ^

ex.dfy(11,57): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (

   |
11 |     (
   |      ^

ex.dfy(11,5): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    IsBST(right) &&

   |
11 |     IsBST(right) &&
   |                    ^

ex.dfy(11,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (left == Empty || left.max <= value) &&

   |
11 |     (left == Empty || left.max <= value) &&
   |                                            ^

ex.dfy(11,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (match left\n', '    (left == Empty || Node?left && left.value < value) &&\n', '    (\n', '    IsBST(right) &&\n', '    (left == Empty || left.max <= value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true

   |
12 |      case Empty => true
   |                        ^

ex.dfy(12,23): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
      case Empty => true

   |
12 |       case Empty => true
   |                         ^

ex.dfy(12,24): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     case Empty => true\n', '      case Empty => true\n', '     case Empty => true\n', '      case Empty => true\n', '     case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, left_value, _) => left_value < value

   |
13 |      case Node(_, left_value, _) => left_value < value
   |                                                       ^

ex.dfy(13,54): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, leftValue, _) => leftValue < value

   |
13 |      case Node(_, leftValue, _) => leftValue < value
   |                                                     ^

ex.dfy(13,52): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, v, _) => v < value) &&

   |
13 |      case Node(_, v, _) => v < value) &&
   |                                         ^

ex.dfy(13,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(lleft, lvalue, lright) => lvalue < value

   |
13 |      case Node(lleft, lvalue, lright) => lvalue < value
   |                                                        ^

ex.dfy(13,55): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     case Node(_, left_value, _) => left_value < value\n', '     case Node(_, leftValue, _) => leftValue < value\n', '     case Node(_, v, _) => v < value) &&\n', '     case Node(_, leftValue, _) => leftValue < value\n', '     case Node(lleft, lvalue, lright) => lvalue < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, leftValue, _) => leftValue < value
    end) &&

   |
14 |     end) &&
   |     ^

ex.dfy(14,4): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    end) &&\n', '    end) &&\n', '    end) &&\n', '    end) &&\n', '    end) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, leftValue, _) => leftValue < value
    end) &&
    (match right

   |
14 |     end) &&
   |     ^

ex.dfy(14,4): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (match right\n', '    (match right\n', '    (match right\n', '    (match right\n', '    (match right\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    IsBST(left) &&
    (match left
     case Empty => true
     case Node(_, leftValue, _) => leftValue < value
    end) &&
    (match right
     case Empty => true

   |
14 |     end) &&
   |     ^

ex.dfy(14,4): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['     case Empty => true\n', '     case Empty => true\n', '     case Empty => true\n', '     case Empty => true\n', '     case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(tree: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['// (2)\n', 'predicate IsBST(tree: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t

  |
6 | predicate IsBST(t: Tree, min: nat, max: nat) reads t
  |                                                    ^

ex.dfy(6,51): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat) reads t\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(l, v, r) =>

  |
9 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(9,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(l, v, r) =>\n', '  case Node(left, v, right) =>\n', '  case Empty => true\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    IsBST(left, min, value) &&

   |
10 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(10,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
11 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    (left == Empty || IsBST(left, min, value - 1)) &&

   |
11 |     (left == Empty || IsBST(left, min, value - 1)) &&
   |                                                      ^

ex.dfy(11,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    (min <= value - 1 => IsBST(left, min, value - 1)) &&

   |
11 |     (min <= value - 1 => IsBST(left, min, value - 1)) &&
   |                       ^

ex.dfy(11,22): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value - 1) &&\n', '    IsBST(left, min, value) &&\n', '    (left == Empty || IsBST(left, min, value - 1)) &&\n', '    (min <= value - 1 => IsBST(left, min, value - 1)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    (min <= value - 1 => IsBST(left, min, value - 1)) &&
    (value + 1 <= max => IsBST(right, value + 1, max))

   |
11 |     (min <= value - 1 => IsBST(left, min, value - 1)) &&
   |                       ^

ex.dfy(11,22): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value + 1 <= max => IsBST(right, value + 1, max))\n', '    (value + 1 <= max => IsBST(right, value + 1, max))\n', '    (value + 1 <= max => IsBST(right, value + 1, max))\n', '    (value + 1 <= max => IsBST(right, value + 1, max))\n', '    (value + 1 <= max => IsBST(right, value + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat) reads t
{
  match t
  case Node(left, value, right) =>
    value >= min && value <= max &&
    (min <= value - 1 => IsBST(left, min, value - 1)) &&
    (value + 1 <= max => IsBST(right, value + 1, max))
  case Empty => true

   |
11 |     (min <= value - 1 => IsBST(left, min, value - 1)) &&
   |                       ^

ex.dfy(11,22): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n', '  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
function IsBST(t: Tree, min: nat, max: nat): bool {

  |
6 | function IsBST(t: Tree, min: nat, max: nat): bool {
  |                                                    ^

ex.dfy(6,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool {\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(l, v, r) =>

  |
9 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(9,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(l, v, r) =>\n', '  case Empty => true\n', '  case Empty => true\n', '  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>

   |
10 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(10,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&

   |
11 |     min <= v && v <= max &&
   |                            ^

ex.dfy(11,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
11 |     v >= min && v <= max &&
   |                            ^

ex.dfy(11,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    min <= v && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v - 1) &&

   |
12 |     IsBST(left, min, v - 1) &&
   |                               ^

ex.dfy(12,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&

   |
12 |     IsBST(left, min, v) &&
   |                           ^

ex.dfy(12,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v - 1) &&\n', '    IsBST(left, min, v) &&\n', '    IsBST(left, min, v) &&\n', '    IsBST(left, min, v - 1) &&\n', '    IsBST(left, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)

   |
13 |     IsBST(right, v, max)
   |                         ^

ex.dfy(13,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v, max)\n', '    IsBST(right, v, max)\n', '    IsBST(right, v, max)\n', '    IsBST(right, v, max)\n', '    IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)

SCORE
1.0
['// (3)\n', '// (3)\n', '// (3)\n', '// (3)\n', '// (3)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, x: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat, min: nat, max: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, x: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)

SCORE
1.0
['{\n', '  requires IsBST(t, min, max)\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)

SCORE
1.0
['{\n', '{\n', '  ensures IsBST(t, min, max)\n', '  ensures IsBST(t, min, max)\n', '  ensures IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min || max < v then t

   |
20 |   if v < min || max < v then t
   |                               ^

ex.dfy(20,30): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min || v > max then

   |
20 |   if v < min || v > max then
   |                             ^

ex.dfy(20,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if v < min || max < v then t\n', '  if v < min {\n', '  if v < min || v > max then\n', '  if v < min {\n', '  if v < min {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    Node(t, v, Empty)

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
   |
21 |     Node(t, v, Empty)
   |                      ^

ex.dfy(21,21): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    Insert(t, v, v, max)

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
   |
21 |     Insert(t, v, v, max)
   |                         ^

ex.dfy(21,24): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    // v is too small, so we increase the minimum bound

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    t

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
   |
21 |     t
   |      ^

ex.dfy(21,5): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    Node(t, v, Empty)\n', '    Insert(t, v, v, max)\n', '    // v is too small, so we increase the minimum bound\n', '    t\n', '    Insert(t, v, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    // v is too small, so we increase the minimum bound
    Insert(t, v, v, max)

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
   |
22 |     Insert(t, v, v, max)
   |                         ^

ex.dfy(22,24): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
{
  if v < min {
    // v is too small, so we increase the minimum bound
    var newMin := min

   |
20 |   if v < min {
   |              ^

ex.dfy(20,13): Error: then expected
   |
22 |     var newMin := min
   |                      ^

ex.dfy(22,21): Error: semicolon expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    Insert(t, v, v, max)\n', '    Insert(t, v, v, max)\n', '    var newMin := min\n', '    Insert(t, v, v, max)\n', '    Insert(t, v, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max) && IsBST(result, min, max)

   |
19 |   ensures IsBST(t, min, max) && IsBST(result, min, max)
   |                                       ^^^^^^

ex.dfy(19,38): Error: unresolved identifier: result
1 resolution/type errors detected in ex.dfy

SCORE
None
['  ensures IsBST(t, min, max)\n', '  ensures IsBST(t, min, max)\n', '  ensures IsBST(t, min, max) && IsBST(result, min, max)\n', '{\n', '  ensures IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if v < min {

   |
21 |   if v < min {
   |              ^

ex.dfy(21,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then

   |
21 |   if t == Empty then
   |                     ^

ex.dfy(21,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)

   |
21 |   if t == Empty then Node(Empty, v, Empty)
   |                                           ^

ex.dfy(21,42): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if v < min {\n', '  if v < min {\n', '  if v < min {\n', '  if t == Empty then\n', '  if t == Empty then Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else

   |
22 |   else
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t

   |
23 |     match t
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>

   |
24 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(24,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, value, right) =>

   |
24 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(24,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then Node(Insert(left, v, min, w), w, right)

   |
25 |       if v < w then Node(Insert(left, v, min, w), w, right)
   |                                                            ^

ex.dfy(25,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then

   |
25 |       if v < w then
   |                    ^

ex.dfy(25,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w then Node(Insert(left, v, min, w), w, right)\n', '      if v < w then Node(Insert(left, v, min, w), w, right)\n', '      if v < w then Node(Insert(left, v, min, w), w, right)\n', '      if v < w then\n', '      if v < w then Node(Insert(left, v, min, w), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)

   |
26 |         Node(Insert(left, v, min, w), w, right)
   |                                                ^

ex.dfy(26,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        if IsBST(left, min, w) then

   |
26 |         if IsBST(left, min, w) then
   |                                    ^

ex.dfy(26,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v, min, w), w, right)\n', '        if IsBST(left, min, w) then\n', '        Node(Insert(left, v, min, w), w, right)\n', '        Node(Insert(left, v, min, w), w, right)\n', '        Node(Insert(left, v, min, w), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if v > w then

   |
27 |       else if v > w then
   |                         ^

ex.dfy(27,24): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then

   |
27 |       else if w < v then
   |                         ^

ex.dfy(27,24): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if v > w then\n', '      else if v > w then\n', '      else if w < v then\n', '      else if v > w then\n', '      else if w < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))

   |
28 |         Node(left, w, Insert(right, v, w, max))
   |                                                ^

ex.dfy(28,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, w, Insert(right, v, w, max))\n', '        Node(left, w, Insert(right, v, w, max))\n', '        Node(left, w, Insert(right, v, w, max))\n', '        Node(left, w, Insert(right, v, w, max))\n', '        Node(left, w, Insert(right, v, w, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else

   |
29 |       else
   |           ^

ex.dfy(29,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n', '      else\n', '      else\n', '      else\n', '      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t

   |
30 |         t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        t\n', '        t\n', '        t\n', '        t\n', '        t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)

SCORE
1.0
['// (4)\n', '// (4)\n', '// (4)\n', '// (4)\n', '// (4)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n', 'predicate Contains(t: Tree, v: nat)\n', 'predicate Contains(t: Tree, v: nat)\n', 'predicate Contains(t: Tree, v: nat)\n', 'predicate Contains(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{

   |
35 | {
   |  ^

ex.dfy(35,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t

   |
36 |   match t
   |          ^

ex.dfy(36,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false

   |
37 |   case Empty => false
   |                      ^

ex.dfy(37,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>

   |
38 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(38,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max) &&

   |
39 |     (min <= v && v <= max) &&
   |                              ^

ex.dfy(39,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&

   |
39 |     (min <= v && v <= max &&
   |                             ^

ex.dfy(39,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max && w == v) ||

   |
39 |     (min <= v && v <= max && w == v) ||
   |                                        ^

ex.dfy(39,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max && w == v) || Contains(left, v, min, w) || Contains(right, v, w, max)

   |
39 |     (min <= v && v <= max && w == v) || Contains(left, v, min, w) || Contains(right, v, w, max)
   |                                                                                                ^

ex.dfy(39,95): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (min <= v && v <= max) &&\n', '    (min <= v && v <= max &&\n', '    (min <= v && v <= max && w == v) ||\n', '    (min <= v && v <= max && w == v) || Contains(left, v, min, w) || Contains(right, v, w, max)\n', '    (min <= v && v <= max && w == v) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
      (v < w ? Contains(left, v, min, w) :

   |
40 |       (v < w ? Contains(left, v, min, w) :
   |              ^

ex.dfy(40,13): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w) :

   |
40 |      (v < w ? Contains(left, v, min, w) :
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v == w || Contains(left, v, min, w) || Contains(right, v, w, max)))

   |
40 |      (v == w || Contains(left, v, min, w) || Contains(right, v, w, max)))
   |                                                                          ^

ex.dfy(40,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['     (v < w ? Contains(left, v, min, w)\n', '      (v < w ? Contains(left, v, min, w) :\n', '     (v < w ? Contains(left, v, min, w) :\n', '     (v < w ? Contains(left, v, min, w) :\n', '     (v == w || Contains(left, v, min, w) || Contains(right, v, w, max)))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
            : (w < v ? Contains(right, v, w, max)

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
      : v > w ? Contains(right, v, w, max)

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
           : (v > w ? Contains(right, v, w, max)

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
           : v > w ? Contains(right, v, w, max)

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['            : (w < v ? Contains(right, v, w, max)\n', '      : v > w ? Contains(right, v, w, max)\n', '           : (v > w ? Contains(right, v, w, max)\n', '           : v > w ? Contains(right, v, w, max)\n', '           : v > w ? Contains(right, v, w, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
           : (v > w ? Contains(right, v, w, max)
                   : true)))

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    (min <= v && v <= max &&
     (v < w ? Contains(left, v, min, w)
           : (v > w ? Contains(right, v, w, max)
                    : true)))

   |
40 |      (v < w ? Contains(left, v, min, w)
   |             ^

ex.dfy(40,12): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                   : true)))\n', '                   : true)))\n', '                   : true)))\n', '                   : true)))\n', '                    : true)))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
['  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n', '  case Empty => false\n']
['  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n', '  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)

   |
39 |     if v < w then Contains(left, v, min, w)
   |                                            ^

ex.dfy(39,43): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    (min <= v && v <= max) &&\n', '    (min <= v && v <= max) &&\n', '    (min <= v && v <= max && w == v) ||\n', '    (min <= v && v <= max) &&\n', '    if v < w then Contains(left, v, min, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if w < v then Contains(right, v, w, max)

   |
40 |     else if w < v then Contains(right, v, w, max)
   |                                                  ^

ex.dfy(40,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)

   |
40 |     else if v > w then Contains(right, v, w, max)
   |                                                  ^

ex.dfy(40,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if w < v then Contains(right, v, w, max)\n', '    else if w < v then Contains(right, v, w, max)\n', '    else if v > w then Contains(right, v, w, max)\n', '    else if v > w then Contains(right, v, w, max)\n', '    else if w < v then Contains(right, v, w, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true

   |
41 |     else true
   |              ^

ex.dfy(41,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n', '    else true\n', '    else true\n', '    else true\n', '    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)

SCORE
1.0
['// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n', '// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma InsertPreservesContains(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma InsertPreservesElement(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma InsertPreservesContains(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma InsertPreservesElement(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma InsertPreservesContains(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) == Contains(Insert(t, v, min, max), v, min, max)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)

SCORE
1.0
['  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(t, v, min, max) == Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(Insert(t, v, min, max), v, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n', '  if t == Empty then\n', '  if t == Empty then\n', '  if t == Empty then\n', '  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
    Contains(t, v, min, max) == false

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
    Contains(Empty, v, min, max) == false

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
  else

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
    Insert_Contains(Empty, v, min, max)

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
    assert v == v;

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Contains(t, v, min, max) == false\n', '    Contains(Empty, v, min, max) == false\n', '  else\n', '    Insert_Contains(Empty, v, min, max)\n', '    assert v == v;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then
    Contains(t, v, min, max) == false
  else

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty

   |
49 |   // base case: t is Empty
   |                           ^

ex.dfy(49,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n', '  // base case: t is Empty\n', '  if t == Empty then\n', '  if t == Empty then\n', '  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty then

   |
50 |   if t == Empty then
   |                 ^

ex.dfy(50,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty

   |
50 |   if t == Empty
   |                ^

ex.dfy(50,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty {

   |
50 |   if t == Empty {
   |                  ^

ex.dfy(50,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n', '  if t == Empty\n', '  if t == Empty\n', '  if t == Empty {\n', '  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {

   |
51 |   {
   |    ^

ex.dfy(51,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);

   |
52 |     assert t == Node(Empty, v, Empty);
   |                                       ^

ex.dfy(52,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert Insert(t, v, min, max) == Node(Empty, v, Empty);

   |
52 |     assert Insert(t, v, min, max) == Node(Empty, v, Empty);
   |                                                            ^

ex.dfy(52,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert Contains(Empty, v, min, max) == false;

   |
52 |     assert Contains(Empty, v, min, max) == false;
   |                                                  ^

ex.dfy(52,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert t == Node(Empty, v, Empty);\n', '    assert Insert(t, v, min, max) == Node(Empty, v, Empty);\n', '    assert Contains(Empty, v, min, max) == false;\n', '    assert Insert(t, v, min, max) == Node(Empty, v, Empty);\n', '    assert t == Node(Empty, v, Empty);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
    assert Contains(t, v, min, max) == true;

   |
53 |     assert Contains(t, v, min, max) == true;
   |                                             ^

ex.dfy(53,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
    assert Insert(t, v, min, max) == Node(Empty, v, Empty);

   |
53 |     assert Insert(t, v, min, max) == Node(Empty, v, Empty);
   |                                                            ^

ex.dfy(53,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }

   |
53 |   }
   |    ^

ex.dfy(53,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
    assert Contains(Node(Empty, v, Empty), v, min, max);

   |
53 |     assert Contains(Node(Empty, v, Empty), v, min, max);
   |                                                         ^

ex.dfy(53,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
    assert Contains(t, v, min, max) == false;

   |
53 |     assert Contains(t, v, min, max) == false;
   |                                              ^

ex.dfy(53,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(t, v, min, max) == true;\n', '    assert Insert(t, v, min, max) == Node(Empty, v, Empty);\n', '  }\n', '    assert Contains(Node(Empty, v, Empty), v, min, max);\n', '    assert Contains(t, v, min, max) == false;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else

   |
54 |   else
   |       ^

ex.dfy(54,6): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
['  else\n', '  else\n', '  else\n', '  else\n', '  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {

   |
55 |   {
   |    ^

ex.dfy(55,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n', '  {\n', '  {\n', '  {\n', '  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t

   |
56 |     match t
   |            ^

ex.dfy(56,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>

   |
57 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(57,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w

   |
58 |       if v < w
   |               ^

ex.dfy(58,14): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w then

   |
58 |       if v < w then
   |                ^

ex.dfy(58,15): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w\n', '      if v < w then\n', '      if v < w then\n', '      if v < w\n', '      if v < w\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {

   |
59 |       {
   |        ^

ex.dfy(59,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n', '      {\n', '      {\n', '      {\n', '      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);

   |
60 |         Insert_Contains(left, v, min, w);
   |                                          ^

ex.dfy(60,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        assert Contains(left, v, min, w);

   |
60 |         assert Contains(left, v, min, w);
   |                                          ^

ex.dfy(60,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n', '        assert Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }

   |
61 |       }
   |        ^

ex.dfy(61,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n', '      }\n', '      }\n', '      }\n', '      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w

   |
62 |       else if v > w
   |                    ^

ex.dfy(62,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if v > w\n', '      else if v > w\n', '      else if v > w\n', '      else if v > w\n', '      else if v > w\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w
      {

   |
63 |       {
   |        ^

ex.dfy(63,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      {\n', '      {\n', '      {\n', '      {\n', '      {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w
      {
        Insert_Contains(right, v, w, max);

   |
64 |         Insert_Contains(right, v, w, max);
   |                                           ^

ex.dfy(64,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Insert_Contains(right, v, w, max);\n', '        Insert_Contains(right, v, w, max);\n', '        Insert_Contains(right, v, w, max);\n', '        Insert_Contains(right, v, w, max);\n', '        Insert_Contains(right, v, w, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w
      {
        Insert_Contains(right, v, w, max);
      }

   |
65 |       }
   |        ^

ex.dfy(65,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n', '      }\n', '      }\n', '      }\n', '      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w
      {
        Insert_Contains(right, v, w, max);
      }
  }

   |
66 |   }
   |    ^

ex.dfy(66,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) ==> Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: t is Empty
  if t == Empty
  {
    assert t == Node(Empty, v, Empty);
  }
  else
  {
    match t
    case Node(left, w, right) =>
      if v < w
      {
        Insert_Contains(left, v, min, w);
      }
      else if v > w
      {
        Insert_Contains(right, v, w, max);
      }
  }
}

ex.dfy(52,11): Error: assertion might not hold
   |
52 |     assert t == Node(Empty, v, Empty);
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(t, v, min, max) <==> Contains(Insert(t, v, min, max), v, min, max)

SCORE
1.0
['  ensures Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(t, v, min, max) == Contains(Insert(t, v, min, max), v, min, max)\n', '  ensures Contains(t, v, min, max) <==> Contains(Insert(t, v, min, max), v, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases

   |
49 |   // Base cases
   |                ^

ex.dfy(49,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // base case: v is in the empty tree

   |
49 |   // base case: v is in the empty tree
   |                                       ^

ex.dfy(49,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  if t == Empty then

   |
49 |   if t == Empty then
   |                 ^

ex.dfy(49,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ... (to be filled)

   |
49 |   // ... (to be filled)
   |                        ^

ex.dfy(49,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n', '  // Base cases\n', '  // base case: v is in the empty tree\n', '  if t == Empty then\n', '  // ... (to be filled)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty then

   |
50 |   if t == Empty then
   |                 ^

ex.dfy(50,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {

   |
50 |   if t == Empty {
   |                  ^

ex.dfy(50,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n', '  if t == Empty {\n', '  if t == Empty {\n', '  if t == Empty {\n', '  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    assert Contains(Node(Empty, v, Empty), v, min, max);

   |
51 |     assert Contains(Node(Empty, v, Empty), v, min, max);
   |                                                         ^

ex.dfy(51,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
  } else {

   |
51 |   } else {
   |           ^

ex.dfy(51,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove

   |
51 |     // nothing to prove
   |                        ^

ex.dfy(51,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, v, Empty), v, min, max);\n', '  } else {\n', '  } else {\n', '  } else {\n', '    // nothing to prove\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else

   |
52 |   } else
   |         ^

ex.dfy(52,8): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {

   |
52 |   } else {
   |           ^

ex.dfy(52,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else\n', '  } else\n', '  } else\n', '  } else {\n', '  } else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {
    match t

   |
53 |     match t
   |            ^

ex.dfy(53,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {
    match t
    case Node(left, w, right) {

   |
54 |     case Node(left, w, right) {
   |                               ^

ex.dfy(54,30): Error: darrow expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {
    match t
    case Node(left, w, right) =>

   |
54 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(54,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) {\n', '    case Node(left, w, right) {\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {
    match t
    case Node(left, w, right) {
      if v < w {

   |
54 |     case Node(left, w, right) {
   |                               ^

ex.dfy(54,30): Error: darrow expected
   |
55 |       if v < w {
   |                 ^

ex.dfy(55,16): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n', '      if v < w {\n', '      if v < w {\n', '      if v < w {\n', '      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Base cases
  if t == Empty {
    // nothing to prove
  } else {
    match t
    case Node(left, w, right) {
      if v < w {
        Insert_Contains(left, v, min, w);

   |
54 |     case Node(left, w, right) {
   |                               ^

ex.dfy(54,30): Error: darrow expected
   |
56 |         Insert_Contains(left, v, min, w);
   |                                          ^

ex.dfy(56,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n', '        Insert_Contains(left, v, min, w);\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // base cases

   |
49 |   // base cases
   |                ^

ex.dfy(49,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // Proof by structural induction on t.

   |
49 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(49,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...

   |
49 |   // ...
   |         ^

ex.dfy(49,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // base case

   |
49 |   // base case
   |               ^

ex.dfy(49,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base cases\n', '  // Proof by structural induction on t.\n', '  // ...\n', '  // base case\n', '  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)

SCORE
1.0
['// (6)\n', '// (6)\n', '// (6)\n', '// (6)\n', '// (6)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:autocontracts} Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)\n', 'lemma {:autocontracts} Insert_IsBST(t: Tree, v: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max) && min <= v && v <= max\n', '  requires IsBST(t, min, max) && min <= v && v <= max\n', '  requires IsBST(t, min, max) && min <= v && v <= max\n', '  requires IsBST(t, min, max) && min <= v && v <= max\n', '  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, v, min, max), min, max)\n', '  ensures IsBST(Insert(t, v, min, max), min, max)\n', '  ensures IsBST(Insert(t, v, min, max), min, max)\n', '  ensures IsBST(Insert(t, v, min, max), min, max)\n', '  ensures IsBST(Insert(t, v, min, max), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{

   |
56 | {
   |  ^

ex.dfy(56,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{
  // ...

   |
57 |   // ...
   |         ^

ex.dfy(57,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n', '  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{
  // ...
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{
  // ...
}
```

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{
  // ...
}
``` #include <stdlib.h>

SCORE
1.0
['```\n', '```\n', '```\n', '```\n', '``` #include <stdlib.h>\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Empty

// (2)
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    min <= v && v <= max &&
    IsBST(left, min, v) &&
    IsBST(right, v, max)
}

// (3)
function Insert(t: Tree, v: nat, min: nat, max: nat): Tree
  requires IsBST(t, min, max)
  ensures IsBST(t, min, max)
{
  if t == Empty then Node(Empty, v, Empty)
  else
    match t
    case Node(left, w, right) =>
      if v < w then
        Node(Insert(left, v, min, w), w, right)
      else if w < v then
        Node(left, w, Insert(right, v, w, max))
      else
        t
}

// (4)
predicate Contains(t: Tree, v: nat, min: nat, max: nat)
{
  match t
  case Empty => false
  case Node(left, w, right) =>
    if v < w then Contains(left, v, min, w)
    else if v > w then Contains(right, v, w, max)
    else true
}

// (5)
lemma {:autocontracts} Insert_Contains(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max)
  ensures Contains(Insert(t, v, min, max), v, min, max)
{
  // ...
}

// (6)
lemma {:autocontracts} Insert_BST(t: Tree, v: nat, min: nat, max: nat)
  requires IsBST(t, min, max) && min <= v && v <= max
  ensures IsBST(Insert(t, v, min, max), min, max)
{
  // ...
}
```


STATS

number of nodes: 61
number of gen nodes: 31 (including leaves: 3)
number of back nodes: 30 (including leaves: 28)

expansion count: 38 (including failed: 8)

cache stats {'hit': 443, 'miss': 237}
calls to generate 136
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810, 619, 721, 712]

Trial calls: [165, 600, 570, 645, 660, 500, 755, 680]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 662.00 sec, Standard Deviation: 168.31 sec

Call Statistics:

  Min: 165 calls, Max: 755 calls, Average: 571.88 calls, Standard Deviation: 169.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810, 721]

Trial calls: [600, 570, 645, 660, 755]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 745.80 sec, Standard Deviation: 33.75 sec

Call Statistics:

  Min: 570 calls, Max: 755 calls, Average: 646.00 calls, Standard Deviation: 63.20 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 619, 712]

Trial calls: [165, 500, 680]


Time Statistics:

  Min: 236.00 sec, Max: 712.00 sec, Average: 522.33 sec, Standard Deviation: 206.00 sec

Call Statistics:

  Min: 165 calls, Max: 680 calls, Average: 448.33 calls, Standard Deviation: 213.40 calls

Trial  9
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Write an ADT for a tree of natural numbers.

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n', '// (1) Define the tree\n', '// (1) Define the ADT for a tree of natural numbers.\n', '// ADT for a tree of natural numbers\n', '// (1) Write an ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', 'datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', 'datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil()

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Nil()\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '    | Empty\n', '  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(value: nat, left: Tree, right: Tree)

SCORE
1.0
['    | Node(left: Tree, value: nat, right: Tree)\n', '    | Node(value: nat, left: Tree, right: Tree)\n', '    | Node(left: Tree, value: nat, right: Tree)\n', '    | Node(value: nat, left: Tree, right: Tree)\n', '    | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks if a tree is a BST

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n', '// (2) Predicate that checks whether a given tree is a BST\n', '// (2) Predicate for checking if a tree is a BST\n', '// (2) Predicate that checks if a tree is a BST\n', '// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, lo: nat, hi: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(tree: Tree, lo: nat, hi: nat): bool\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n', 'function IsBST(tree: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree

  |
8 |     reads tree
  |           ^^^^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '    reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree

   |
10 |     match tree
   |               ^

ex.dfy(10,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
13 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&

   |
13 |         value >= min && value < max &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&
        IsBST(left, min, value) &&

   |
14 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)

   |
15 |         IsBST(right, value, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

  |
8 |     reads tree
  |           ^^^^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max

  |
8 |     reads tree, min, max
  |           ^^^^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
8 |     reads tree, min, max
  |                 ^^^

ex.dfy(8,16): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
8 |     reads tree, min, max
  |                      ^^^

ex.dfy(8,21): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['    reads tree\n', '{\n', '    reads tree, min, max\n', '{\n', '    reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree

   |
10 |     match tree
   |               ^

ex.dfy(10,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&

   |
13 |         value >= min && value < max &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
13 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&

   |
13 |         value >= min &&
   |                        ^

ex.dfy(13,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value < max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value < max &&\n', '        value >= min && value < max &&\n', '        value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&
        value <= max &&

   |
14 |         value <= max &&
   |                        ^

ex.dfy(14,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&
        value < max &&

   |
14 |         value < max &&
   |                       ^

ex.dfy(14,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value <= max &&\n', '        value < max &&\n', '        value <= max &&\n', '        value <= max &&\n', '        value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&
        value < max &&
        IsBST(left, min, value) &&

   |
15 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&
        value < max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)

   |
16 |         IsBST(right, value, max)
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
    reads tree, min, max
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min &&
        value < max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

  |
8 |     reads tree, min, max
  |           ^^^^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
8 |     reads tree, min, max
  |                 ^^^

ex.dfy(8,16): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
8 |     reads tree, min, max
  |                      ^^^

ex.dfy(8,21): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: int, max: int): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree, lo: nat, hi: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n', 'function IsBST(t: Tree): bool\n', 'function IsBST(tree: Tree, min: int, max: int): bool\n', 'function IsBST(tree: Tree, lo: nat, hi: nat): bool\n', 'function IsBST(t: Tree, lo: nat, hi: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        l == Empty || MaxValue(l) < v && IsBST(l) &&

   |
12 |         l == Empty || MaxValue(l) < v && IsBST(l) &&
   |                                       ^^

ex.dfy(12,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || MaxValue(l) < v && IsBST(l) &&
   |                                                   ^^

ex.dfy(12,50): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || MaxValue(l) < v && IsBST(l) &&
   |                                                     ^

ex.dfy(12,52): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        IsBST(l) &&

   |
12 |         IsBST(l) &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= MaxValue(l) &&

   |
12 |         v >= MaxValue(l) &&
   |                            ^

ex.dfy(12,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        l == Empty || v >= Max(l) && IsBST(l) &&

   |
12 |         l == Empty || v >= Max(l) && IsBST(l) &&
   |                                   ^^

ex.dfy(12,34): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || v >= Max(l) && IsBST(l) &&
   |                                               ^^

ex.dfy(12,46): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || v >= Max(l) && IsBST(l) &&
   |                                                 ^

ex.dfy(12,48): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        l == Empty || MaxValue(l) < v &&

   |
12 |         l == Empty || MaxValue(l) < v &&
   |                                       ^^

ex.dfy(12,38): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |         l == Empty || MaxValue(l) < v &&
   |                                         ^

ex.dfy(12,40): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['        l == Empty || MaxValue(l) < v && IsBST(l) &&\n', '        IsBST(l) &&\n', '        v >= MaxValue(l) &&\n', '        l == Empty || v >= Max(l) && IsBST(l) &&\n', '        l == Empty || MaxValue(l) < v &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= MaxValue(l) &&
        v <= MinValue(r) &&

   |
13 |         v <= MinValue(r) &&
   |                            ^

ex.dfy(13,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v <= MinValue(r) &&\n', '        v <= MinValue(r) &&\n', '        v <= MinValue(r) &&\n', '        v <= MinValue(r) &&\n', '        v <= MinValue(r) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= MaxValue(l) &&
        v <= MinValue(r) &&
        IsBST(l) &&

   |
14 |         IsBST(l) &&
   |                    ^

ex.dfy(14,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(l) &&\n', '        IsBST(l) &&\n', '        IsBST(l) &&\n', '        IsBST(l) &&\n', '        IsBST(l) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= MaxValue(l) &&
        v <= MinValue(r) &&
        IsBST(l) &&
        IsBST(r)

   |
15 |         IsBST(r)
   |                 ^

ex.dfy(15,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(r)\n', '        IsBST(r)\n', '        IsBST(r)\n', '        IsBST(r)\n', '        IsBST(r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= MaxValue(l) &&
        v <= MinValue(r) &&
        IsBST(l) &&
        IsBST(r)
}

   |
12 |         v >= MaxValue(l) &&
   |              ^^^^^^^^

ex.dfy(12,13): Error: unresolved identifier: MaxValue
   |
13 |         v <= MinValue(r) &&
   |              ^^^^^^^^

ex.dfy(13,13): Error: unresolved identifier: MinValue
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t

  |
8 |     reads t
  |           ^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t

   |
10 |     match t
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true

   |
11 |         case Empty => true
   |                           ^

ex.dfy(11,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '        case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(l, v, r) =>

   |
12 |         case Node(l, v, r) =>
   |                              ^

ex.dfy(12,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, v, right) =>

   |
12 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>

   |
12 |         case Node(left, value, right) =>
   |                                         ^

ex.dfy(12,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(l, v, r) =>\n', '        case Node(left, v, right) =>\n', '        case Node(left, value, right) =>\n', '        case Node(left, value, right) =>\n', '        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            left == Empty || Node_value(left) <= value && IsBST(left) &&

   |
13 |             left == Empty || Node_value(left) <= value && IsBST(left) &&
   |                                                        ^^

ex.dfy(13,55): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |             left == Empty || Node_value(left) <= value && IsBST(left) &&
   |                                                                       ^^

ex.dfy(13,70): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |             left == Empty || Node_value(left) <= value && IsBST(left) &&
   |                                                                         ^

ex.dfy(13,72): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&

   |
13 |             IsBST(left) &&
   |                           ^

ex.dfy(13,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            left == Empty || Node_value(left) <= value && IsBST(left) &&\n', '            IsBST(left) &&\n', '            IsBST(left) &&\n', '            IsBST(left) &&\n', '            IsBST(left) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            (forall x | x in left :: value in right && x < value) &&

   |
14 |             (forall x | x in left :: value in right && x < value) &&
   |                                                                     ^

ex.dfy(14,68): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&

   |
14 |             IsBST(right) &&
   |                            ^

ex.dfy(14,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            (left == Empty || MaxValue(left) < value) &&

   |
14 |             (left == Empty || MaxValue(left) < value) &&
   |                                                         ^

ex.dfy(14,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            (forall x | x in left :: value in right) &&

   |
14 |             (forall x | x in left :: value in right) &&
   |                                                        ^

ex.dfy(14,55): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            (left == Empty || max(left) < value) &&

   |
14 |             (left == Empty || max(left) < value) &&
   |                                                    ^

ex.dfy(14,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            (forall x | x in left :: value in right && x < value) &&\n', '            IsBST(right) &&\n', '            (left == Empty || MaxValue(left) < value) &&\n', '            (forall x | x in left :: value in right) &&\n', '            (left == Empty || max(left) < value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (forall x, y | x in left && y in right :: x < value < y)

   |
15 |             (forall x, y | x in left && y in right :: x < value < y)
   |                                                                     ^

ex.dfy(15,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (

   |
15 |             (
   |              ^

ex.dfy(15,13): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (left == Empty || MaxValue(left) < value) &&

   |
15 |             (left == Empty || MaxValue(left) < value) &&
   |                                                         ^

ex.dfy(15,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (left == Empty || Node.left.value <= value) &&

   |
15 |             (left == Empty || Node.left.value <= value) &&
   |                                                           ^

ex.dfy(15,58): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            // All elements in left subtree are less than 'value'.

   |
15 |             // All elements in left subtree are less than 'value'.
   |                                                                   ^

ex.dfy(15,66): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            (forall x, y | x in left && y in right :: x < value < y)\n', '            (\n', '            (left == Empty || MaxValue(left) < value) &&\n', '            (left == Empty || Node.left.value <= value) &&\n', "            // All elements in left subtree are less than 'value'.\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) ||

   |
16 |                 (left == Empty) ||
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty && value <= right.MinValue()) ||

   |
16 |                 (left == Empty && value <= right.MinValue()) ||
   |                                                                ^

ex.dfy(16,63): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value

   |
16 |                 (left == Empty) || BST_Max(left) < value
   |                                                         ^

ex.dfy(16,56): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['                (left == Empty) ||\n', '                (left == Empty) ||\n', '                (left == Empty && value <= right.MinValue()) ||\n', '                (left == Empty) || BST_Max(left) < value\n', '                (left == Empty && value <= right.MinValue()) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value
            ) && (

   |
17 |             ) && (
   |                   ^

ex.dfy(17,18): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value
            ) &&

   |
17 |             ) &&
   |                 ^

ex.dfy(17,16): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            ) && (\n', '            ) &&\n', '            ) && (\n', '            ) &&\n', '            ) && (\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value
            ) && (
                (right == Empty) || value < BST_Min(right)

   |
18 |                 (right == Empty) || value < BST_Min(right)
   |                                                           ^

ex.dfy(18,58): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['                (right == Empty) || value < BST_Min(right)\n', '                (right == Empty) || value < BST_Min(right)\n', '                (right == Empty) || value < BST_Min(right)\n', '                (right == Empty) || value < BST_Min(right)\n', '                (right == Empty) || value < BST_Min(right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value
            ) && (
                (right == Empty) || value < BST_Min(right)
            )

   |
19 |             )
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            )\n', '            )\n', '            )\n', '            )\n', '            )\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(t: Tree): bool
    reads t
{
    match t
        case Empty => true
        case Node(left, value, right) =>
            IsBST(left) &&
            IsBST(right) &&
            (
                (left == Empty) || BST_Max(left) < value
            ) && (
                (right == Empty) || value < BST_Min(right)
            )
}

  |
8 |     reads t
  |           ^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
   |
16 |                 (left == Empty) || BST_Max(left) < value
   |                                    ^^^^^^^

ex.dfy(16,35): Error: unresolved identifier: BST_Max
   |
18 |                 (right == Empty) || value < BST_Min(right)
   |                                             ^^^^^^^

ex.dfy(18,44): Error: unresolved identifier: BST_Min
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate to check whether a given tree is a binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate to check if a given tree is a binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for binary search tree (BST)\n', '// (2) Predicate to check whether a given tree is a binary search tree (BST)\n', '// (2) Predicate to check if a given tree is a binary search tree (BST)\n', '// (2) Predicate for BST\n', '// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t

  |
8 |     reads t
  |           ^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '    reads t\n', '{\n', '    reads t\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)

   |
11 |     case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)
   |                                                                                       ^

ex.dfy(11,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(l, v, r) => \n', '    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || IsBST(l, min, v)

   |
12 |         l == Empty || IsBST(l, min, v)
   |                                       ^

ex.dfy(12,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        v >= min && v <= max &&

   |
12 |         v >= min && v <= max &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        l == Empty || IsBST(l, min, v)\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || IsBST(l, min, v)
        && v <= max

   |
13 |         && v <= max
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |         && v <= max
   |                    ^

ex.dfy(13,19): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        && v <= max\n', '        && v <= max\n', '        && v <= max\n', '        && v <= max\n', '        && v <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || IsBST(l, min, v)
        && v <= max
        && r == Empty || IsBST(r, v, max)

   |
13 |         && v <= max
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && r == Empty || IsBST(r, v, max)
   |         ^^

ex.dfy(14,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && r == Empty || IsBST(r, v, max)
   |                                          ^

ex.dfy(14,41): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['        && r == Empty || IsBST(r, v, max)\n', '        && r == Empty || IsBST(r, v, max)\n', '        && r == Empty || IsBST(r, v, max)\n', '        && r == Empty || IsBST(r, v, max)\n', '        && r == Empty || IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
    match t
    case Empty => true
    case Node(l, v, r) => 
        l == Empty || IsBST(l, min, v)
        && v <= max
        && r == Empty || IsBST(r, v, max)
}

   |
13 |         && v <= max
   |         ^^

ex.dfy(13,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |         && r == Empty || IsBST(r, v, max)
   |         ^^

ex.dfy(14,8): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
2 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['    reads t\n', '{\n', '    reads t\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t

   |
10 |     match t
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, v, right) => 

   |
12 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        value >= min && value <= max &&

   |
13 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        min <= value <= max &&

   |
13 |         min <= value <= max &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        min <= value <= max &&\n', '        min <= value <= max &&\n', '        value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        min <= value <= max &&
        IsBST(left, min, value - 1) &&

   |
14 |         IsBST(left, min, value - 1) &&
   |                                       ^

ex.dfy(14,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        min <= value <= max &&
        IsBST(left, min, value) &&

   |
14 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value - 1) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value - 1) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        min <= value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)

   |
15 |         IsBST(right, value, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n', '        IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) => 
        min <= value <= max &&
        IsBST(left, min, value) &&
        IsBST(right, value, max)
}

  |
8 |     reads t
  |           ^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '    reads tree\n', '    reads tree\n', '{\n', '    reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree

  |
9 |     match tree
  |               ^

ex.dfy(9,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
12 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(12,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value < max &&

   |
12 |         value >= min && value < max &&
   |                                       ^

ex.dfy(12,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= min && value <= max &&\n', '        value >= min && value < max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value < max &&\n', '        value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value - 1) &&

   |
13 |         IsBST(left, min, value - 1) &&
   |                                       ^

ex.dfy(13,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&

   |
13 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, min, value - 1) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value - 1) &&
        IsBST(right, value + 1, max)

   |
14 |         IsBST(right, value + 1, max)
   |                                     ^

ex.dfy(14,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value + 1, max)\n', '        IsBST(right, value + 1, max)\n', '        IsBST(right, value + 1, max)\n', '        IsBST(right, value + 1, max)\n', '        IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)
function IsBST(tree: Tree, min: nat, max: nat): bool
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value - 1) &&
        IsBST(right, value + 1, max)
}

ex.dfy(13,31): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |         IsBST(left, min, value - 1) &&
   |                                ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n', '// (2) Predicate to check if a given tree is a binary search tree (BST)\n', '// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n', '// (2) Predicate for checking if a given tree is a BST\n', '// (2) Predicate to check whether a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
function IsBST(tree: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(tree: Tree, lower: nat, upper: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t

  |
8 |     reads t
  |           ^

ex.dfy(8,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '    reads t\n', '{\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min && v <= max &&

   |
12 |         v >= min && v <= max &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&

   |
12 |         v >= min &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&

   |
13 |         v <= max &&
   |                    ^

ex.dfy(13,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v > min)) &&

   |
14 |         (left == Empty || (IsBST(left, min, v - 1) && v > min)) &&
   |                                                                   ^

ex.dfy(14,66): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v <= max)) &&

   |
14 |         (left == Empty || (IsBST(left, min, v - 1) && v <= max)) &&
   |                                                                    ^

ex.dfy(14,67): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v - 1 >= min)) &&

   |
14 |         (left == Empty || (IsBST(left, min, v - 1) && v - 1 >= min)) &&
   |                                                                        ^

ex.dfy(14,71): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&

   |
14 |         (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&
   |                                                                              ^

ex.dfy(14,77): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        IsBST(left, min, v - 1) &&

   |
14 |         IsBST(left, min, v - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (left == Empty || (IsBST(left, min, v - 1) && v > min)) &&\n', '        (left == Empty || (IsBST(left, min, v - 1) && v <= max)) &&\n', '        (left == Empty || (IsBST(left, min, v - 1) && v - 1 >= min)) &&\n', '        (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&\n', '        IsBST(left, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&
        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))

   |
15 |         (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))
   |                                                                              ^

ex.dfy(15,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))\n', '        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))\n', '        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))\n', '        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))\n', '        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Empty => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&
        (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))
}

   |
14 |         (left == Empty || (IsBST(left, min, v - 1) && v > MinValue(left))) &&
   |                                                           ^^^^^^^^

ex.dfy(14,58): Error: unresolved identifier: MinValue
   |
15 |         (right == Empty || (IsBST(right, v + 1, max) && v < MaxValue(right)))
   |                                                             ^^^^^^^^

ex.dfy(15,60): Error: unresolved identifier: MaxValue
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['    reads t\n', '{\n', '{\n', '    reads t\n', '    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t

   |
10 |     match t
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(l, v, r) =>

   |
12 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(12,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, v, right) =>

   |
12 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        min <= value <= max &&

   |
13 |         min <= value <= max &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&

   |
13 |         value >= min && value <= max &&
   |                                        ^

ex.dfy(13,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        min <= value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n', '        value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (forall x | x in left :: nat => x <= value) &&

   |
14 |         (forall x | x in left :: nat => x <= value) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value - 1) &&

   |
14 |         IsBST(left, min, value - 1) &&
   |                                       ^

ex.dfy(14,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (left == Empty || IsBST(left, min, value - 1)) &&

   |
14 |         (left == Empty || IsBST(left, min, value - 1)) &&
   |                                                          ^

ex.dfy(14,57): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        IsBST(left, min, value) &&

   |
14 |         IsBST(left, min, value) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (forall x | x in left :: nat => x <= value) &&\n', '        IsBST(left, min, value - 1) &&\n', '        IsBST(left, min, value - 1) &&\n', '        (left == Empty || IsBST(left, min, value - 1)) &&\n', '        IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (forall x | x in left :: nat => x <= value) &&
        (forall x | x in right :: nat => x >= value) &&

   |
14 |         (forall x | x in left :: nat => x <= value) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (forall x | x in right :: nat => x >= value) &&\n', '        (forall x | x in right :: nat => x >= value) &&\n', '        (forall x | x in right :: nat => x >= value) &&\n', '        (forall x | x in right :: nat => x >= value) &&\n', '        (forall x | x in right :: nat => x >= value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (forall x | x in left :: nat => x <= value) &&
        (forall x | x in right :: nat => x >= value) &&
        IsBST(left, min, value) && IsBST(right, value, max)

   |
14 |         (forall x | x in left :: nat => x <= value) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (forall x | x in left :: nat => x <= value) &&
        (forall x | x in right :: nat => x >= value) &&
        IsBST(left, min, value) &&

   |
14 |         (forall x | x in left :: nat => x <= value) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
    reads t
{
    match t
    case Empty => true
    case Node(left, value, right) =>
        value >= min && value <= max &&
        (forall x | x in left :: nat => x <= value) &&
        (forall x | x in right :: nat => x >= value) &&
        IsBST(left, min, value - 1) &&

   |
14 |         (forall x | x in left :: nat => x <= value) &&
   |                                  ^

ex.dfy(14,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['        IsBST(left, min, value) && IsBST(right, value, max)\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) &&\n', '        IsBST(left, min, value) && IsBST(right, value, max)\n', '        IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int)

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(tree: Tree, min: nat, max: nat) \n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'predicate IsBST(t: Tree, min: int, max: int)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree

  |
9 |     match tree
  |               ^

ex.dfy(9,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n', '    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= lower && value <= upper &&

   |
12 |         value >= lower && value <= upper &&
   |                                            ^

ex.dfy(12,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        lower <= value && value < upper &&

   |
12 |         lower <= value && value < upper &&
   |                                           ^

ex.dfy(12,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= lower &&

   |
12 |         value >= lower &&
   |                          ^

ex.dfy(12,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&

   |
12 |         IsBST(left, lower, value) &&
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        value >= lower && value < upper &&

   |
12 |         value >= lower && value < upper &&
   |                                           ^

ex.dfy(12,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= lower && value <= upper &&\n', '        lower <= value && value < upper &&\n', '        value >= lower &&\n', '        IsBST(left, lower, value) &&\n', '        value >= lower && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&

   |
13 |         value <= upper &&
   |                          ^

ex.dfy(13,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        lower <= value && value < upper &&

   |
13 |         lower <= value && value < upper &&
   |                                           ^

ex.dfy(13,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value <= upper &&\n', '        value <= upper &&\n', '        lower <= value && value < upper &&\n', '        value <= upper &&\n', '        value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&

   |
14 |         value >= lower &&
   |                          ^

ex.dfy(14,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value >= lower &&\n', '        value >= lower &&\n', '        value >= lower &&\n', '        value >= lower &&\n', '        value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)

   |
15 |         IsBST(right, value, upper)
   |                                   ^

ex.dfy(15,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(right, value, upper)\n', '        IsBST(right, value, upper)\n', '        IsBST(right, value, upper)\n', '        IsBST(right, value, upper)\n', '        IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST while preserving the BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST while preserving the BST property\n', '// (3) Function for inserting an element into a BST while preserving the BST property\n', '// (3) Function for inserting an element into a BST\n', '// (3) Function for inserting an element into a BST\n', '// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n', 'function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)

   |
21 |     if tree == Empty then Node(Empty, value, Empty)
   |                                                    ^

ex.dfy(21,51): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else

   |
21 |     if tree == Empty then Node(Empty, value, Empty) else
   |                                                         ^

ex.dfy(21,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then

   |
21 |     if tree == Empty then
   |                          ^

ex.dfy(21,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    match tree

   |
21 |     match tree
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if tree == Empty then Node(Empty, value, Empty)\n', '    if tree == Empty then Node(Empty, value, Empty)\n', '    if tree == Empty then Node(Empty, value, Empty) else\n', '    if tree == Empty then\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    if value < tree.value then Node(Insert(tree.left, value), tree.value, tree.right) else

   |
22 |     if value < tree.value then Node(Insert(tree.left, value), tree.value, tree.right) else
   |                                                                                           ^

ex.dfy(22,90): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    match tree

   |
22 |     match tree
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {

   |
22 |     {
   |      ^

ex.dfy(22,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tree.value then Node(Insert(tree.left, value), tree.value, tree.right) else\n', '    match tree\n', '    match tree\n', '    {\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var left := tree.left;

   |
23 |         var left := tree.left;
   |                               ^

ex.dfy(23,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lower := tree.value;

   |
23 |         var lower := tree.value;
   |                                 ^

ex.dfy(23,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lower := match tree

   |
23 |         var lower := match tree
   |                                ^

ex.dfy(23,31): Error: semicolon expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        match tree

   |
23 |         match tree
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        var left := tree.left;\n', '        var lower := tree.value;\n', '        var lower := match tree\n', '        var lb, ub: nat;\n', '        match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;
        lb, ub := tree.value, tree.value;

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
   |
24 |         lb, ub := tree.value, tree.value;
   |                ^

ex.dfy(24,15): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;
        lb, ub := LowerUpper(tree);

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
   |
24 |         lb, ub := LowerUpper(tree);
   |                ^

ex.dfy(24,15): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;
        match tree

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
   |
24 |         match tree
   |                   ^

ex.dfy(24,18): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        lb, ub := tree.value, tree.value;\n', '        lb, ub := LowerUpper(tree);\n', '        match tree\n', '        match tree\n', '        match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;
        lb, ub := LowerUpper(tree);
        if value < lb then

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
   |
24 |         lb, ub := LowerUpper(tree);
   |                ^

ex.dfy(24,15): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty) else
    {
        var lb, ub: nat;
        lb, ub := LowerUpper(tree);
        if value < lb then Node(Insert(tree.left, value), lb, tree.right)

   |
23 |         var lb, ub: nat;
   |                        ^

ex.dfy(23,23): Error: invalid LetExprWithLHS
   |
24 |         lb, ub := LowerUpper(tree);
   |                ^

ex.dfy(24,15): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        if value < lb then\n', '        if value < lb then Node(Insert(tree.left, value), lb, tree.right)\n', '        if value < lb then\n', '        if value < lb then Node(Insert(tree.left, value), lb, tree.right)\n', '        if value < lb then\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['    if tree == Empty then\n', '    if tree == Empty then\n', '    if tree == Empty then Node(Empty, value, Empty)\n', '    if tree == Empty then\n', '    if tree == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else

   |
22 |     else
   |         ^

ex.dfy(22,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else\n', '    else\n', '    else\n', '    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree

   |
23 |         match tree
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match tree\n', '        match tree\n', '        match tree\n', '        match tree\n', '        match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>

   |
24 |         case Node(left, nodeValue, right) =>
   |                                             ^

ex.dfy(24,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, nodeValue, right) =>\n', '        case Node(left, nodeValue, right) =>\n', '        case Node(left, nodeValue, right) =>\n', '        case Node(left, nodeValue, right) =>\n', '        case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then Node(Insert(left, value), nodeValue, right)

   |
25 |             if value < nodeValue then Node(Insert(left, value), nodeValue, right)
   |                                                                                  ^

ex.dfy(25,81): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then

   |
25 |             if value < nodeValue then
   |                                      ^

ex.dfy(25,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n', '            if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n', '            if value < nodeValue then\n', '            if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n', '            if value < nodeValue then Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)

   |
26 |                 Node(Insert(left, value), nodeValue, right)
   |                                                            ^

ex.dfy(26,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['                Node(Insert(left, value), nodeValue, right)\n', '                Node(Insert(left, value), nodeValue, right)\n', '                Node(Insert(left, value), nodeValue, right)\n', '                Node(Insert(left, value), nodeValue, right)\n', '                Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then

   |
27 |             else if value > nodeValue then
   |                                           ^

ex.dfy(27,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            else if value > nodeValue then\n', '            else if value > nodeValue then\n', '            else if value > nodeValue then\n', '            else if value > nodeValue then\n', '            else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))

   |
28 |                 Node(left, nodeValue, Insert(right, value))
   |                                                            ^

ex.dfy(28,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['                Node(left, nodeValue, Insert(right, value))\n', '                Node(left, nodeValue, Insert(right, value))\n', '                Node(left, nodeValue, Insert(right, value))\n', '                Node(left, nodeValue, Insert(right, value))\n', '                Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else

   |
29 |             else
   |                 ^

ex.dfy(29,16): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree

   |
29 |             else tree
   |                      ^

ex.dfy(29,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else\n', '            else\n', '            else\n', '            else\n', '            else tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a given tree contains a given element

SCORE
1.0
['// (4) Predicate for checking if a tree contains a given element\n', '// (4) Predicate for checking if a given tree contains a given element\n', '// (4) Predicate for checking if a given tree contains a given element\n', '// (4) Predicate for checking if a tree contains a given element\n', '// (4) Predicate for checking if a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n', 'predicate Contains(tree: Tree, value: nat)\n', 'predicate Contains(tree: Tree, value: nat)\n', 'predicate Contains(tree: Tree, value: nat)\n', 'predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree

   |
35 |     match tree
   |               ^

ex.dfy(35,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false

   |
36 |     case Empty => false
   |                        ^

ex.dfy(36,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n', '    case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>

   |
37 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(37,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n', '    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        value == nodeValue || Contains(left, value) || Contains(right, value)

   |
38 |         value == nodeValue || Contains(left, value) || Contains(right, value)
   |                                                                              ^

ex.dfy(38,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)

   |
38 |         if value < nodeValue then Contains(left, value)
   |                                                        ^

ex.dfy(38,55): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        (value == nodeValue) || Contains(left, value) || Contains(right, value)

   |
38 |         (value == nodeValue) || Contains(left, value) || Contains(right, value)
   |                                                                                ^

ex.dfy(38,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        (nodeValue == value) || Contains(left, value) || Contains(right, value)

   |
38 |         (nodeValue == value) || Contains(left, value) || Contains(right, value)
   |                                                                                ^

ex.dfy(38,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        value == nodeValue || Contains(left, value) || Contains(right, value)\n', '        if value < nodeValue then Contains(left, value)\n', '        (value == nodeValue) || Contains(left, value) || Contains(right, value)\n', '        (nodeValue == value) || Contains(left, value) || Contains(right, value)\n', '        value == nodeValue || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)

   |
39 |         else if value > nodeValue then Contains(right, value)
   |                                                              ^

ex.dfy(39,61): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if value > nodeValue then Contains(right, value)\n', '        else if value > nodeValue then Contains(right, value)\n', '        else if value > nodeValue then Contains(right, value)\n', '        else if value > nodeValue then Contains(right, value)\n', '        else if value > nodeValue then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true

   |
40 |         else true
   |                  ^

ex.dfy(40,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else true\n', '        else true\n', '        else true\n', '        else true\n', '        else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma about the insert function for preserving the element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma about the Insert function that ensures the tree resulting from

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function for preserving the element\n', '// (5) Lemma about the Insert function that ensures the tree resulting from\n', '// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n', '// (5) Lemma for insert function without BST property\n', '// (5) Lemma for insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership

   |
44 | lemma InsertMaintainsMembership
   |                                ^

ex.dfy(44,31): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsContains(tree: Tree, value: nat, newValue: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesMembership

   |
44 | lemma InsertPreservesMembership
   |                                ^

ex.dfy(44,31): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertLemma1(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertMaintainsMembership\n', 'lemma InsertMaintainsContains(tree: Tree, value: nat, newValue: nat)\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)\n', 'lemma InsertPreservesMembership\n', 'lemma InsertLemma1(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership
{

   |
45 | {
   | ^

ex.dfy(45,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership
{
    ensures Contains(Insert(tree, value), value)

   |
45 | {
   | ^

ex.dfy(45,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership
{
    ensures Contains(Insert(tree, value), value) == true

   |
45 | {
   | ^

ex.dfy(45,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership
{
    ensures Contains(Insert(tree, value), value) == true;

   |
45 | {
   | ^

ex.dfy(45,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['    ensures Contains(Insert(tree, value), value)\n', '    ensures Contains(Insert(tree, value), value) == true\n', '    ensures Contains(Insert(tree, value), value) == true;\n', '    ensures Contains(Insert(tree, value), value)\n', '    ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertMaintainsMembership
{
    ensures Contains(Insert(tree, value), value)
}

   |
45 | {
   | ^

ex.dfy(45,0): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma {:verify false} InsertPreservesContains(tree: Tree, value: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma Insert_Preserves_Contains(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
['lemma {:verify false} InsertPreservesContains(tree: Tree, value: nat)\n', 'lemma InsertLemma1(tree: Tree, value: nat)\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)\n', 'lemma Insert_Preserves_Contains(tree: Tree, value: nat, newTree: Tree)\n', 'lemma InsertMaintainsMembership\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) == Contains(newTree, value)

   |
46 |     Contains(tree, value) == Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    Contains(tree, value) == Contains(newTree, value)\n', '    Contains(tree, value) <==> Contains(newTree, value)\n', '    Contains(tree, value) == Contains(newTree, value)\n', '    Contains(tree, value) == Contains(newTree, value)\n', '    Contains(tree, value) == Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}


   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}

// (6) Lemma for insert function with BST property

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}

lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}

// (6) Lemma for insert function preserving BST property

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
    | Empty
    | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Empty => true
    case Node(left, value, right) =>
        IsBST(left, lower, value) &&
        value <= upper &&
        value >= lower &&
        IsBST(right, value, upper)
}

// (3) Function for inserting an element into a BST
function Insert(tree: Tree, value: nat): Tree
{
    if tree == Empty then Node(Empty, value, Empty)
    else
        match tree
        case Node(left, nodeValue, right) =>
            if value < nodeValue then
                Node(Insert(left, value), nodeValue, right)
            else if value > nodeValue then
                Node(left, nodeValue, Insert(right, value))
            else tree
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
    match tree
    case Empty => false
    case Node(left, nodeValue, right) =>
        if value < nodeValue then Contains(left, value)
        else if value > nodeValue then Contains(right, value)
        else true
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)
{
    Contains(tree, value) <==> Contains(newTree, value)
}

// (6) Lemma for insert function maintaining the BST property

   |
46 |     Contains(tree, value) <==> Contains(newTree, value)
   |                           ^

ex.dfy(46,26): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma for insert function with BST property\n', 'lemma InsertPreservesContains(tree: Tree, value: nat, newTree: Tree)\n', '// (6) Lemma for insert function with BST property\n', '// (6) Lemma for insert function preserving BST property\n', '// (6) Lemma for insert function maintaining the BST property\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 5)
number of back nodes: 25 (including leaves: 21)

expansion count: 37 (including failed: 12)

cache stats {'hit': 485, 'miss': 265}
calls to generate 150
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810, 619, 721, 712, 726]

Trial calls: [165, 600, 570, 645, 660, 500, 755, 680, 750]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 669.11 sec, Standard Deviation: 159.96 sec

Call Statistics:

  Min: 165 calls, Max: 755 calls, Average: 591.67 calls, Standard Deviation: 169.33 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810, 721, 726]

Trial calls: [600, 570, 645, 660, 755, 750]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 742.50 sec, Standard Deviation: 31.68 sec

Call Statistics:

  Min: 570 calls, Max: 755 calls, Average: 663.33 calls, Standard Deviation: 69.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 619, 712]

Trial calls: [165, 500, 680]


Time Statistics:

  Min: 236.00 sec, Max: 712.00 sec, Average: 522.33 sec, Standard Deviation: 206.00 sec

Call Statistics:

  Min: 165 calls, Max: 680 calls, Average: 448.33 calls, Standard Deviation: 213.40 calls

Trial  10
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers.

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers\n', '// (1) ADT for a tree of natural numbers\n', '// (1) Define an ADT for a tree of natural numbers.\n', 'datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)\n', '// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree =\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n', 'datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(value: nat, left: Tree, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['    Leaf\n', '  | Empty\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Empty\n', '  | Node(value: nat, left: Tree, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n', '  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for binary search tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check whether a given tree is a binary search tree

SCORE
1.0
['// (2) Define a predicate IsBST\n', '// (2) Define a predicate for binary search tree\n', '// (2) Define a predicate to check whether a given tree is a binary search tree\n', '// (2) Define a predicate IsBST\n', '// (2) Define a predicate to check whether a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(tree: Tree, min: nat, max: nat): bool

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(tree: Tree, min: nat, max: nat): bool\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '  reads t\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
    case Leaf => true

   |
11 |     case Leaf => true
   |                      ^

ex.dfy(11,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true

   |
11 |   case Leaf => true
   |                    ^

ex.dfy(11,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>

   |
12 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(12,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(l, v, r) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&

   |
13 |     v >= min && v <= max &&
   |                            ^

ex.dfy(13,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n', '    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&

   |
14 |     IsBST(l, min, v) &&
   |                        ^

ex.dfy(14,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n', '    IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)

   |
15 |     IsBST(r, v, max)
   |                     ^

ex.dfy(15,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n', '    IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false

   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '  else false\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false
}

   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false
}


   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false
}

// (3) Define a function Insert

   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false
}

// (3) Define a function Insert that inserts an element into a binary search tree

   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Leaf => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
  else false
}

// (3) Define an Insert function

   |
16 |   else false
   |   ^

ex.dfy(16,2): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (3) Define a function Insert\n', '// (3) Define a function Insert\n', '// (3) Define a function Insert that inserts an element into a binary search tree\n', '// (3) Define an Insert function\n', '// (3) Define a function Insert\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n', '  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)

   |
11 |   case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)
   |                                                                                     ^

ex.dfy(11,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

   |
11 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)\n', '  case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v) && IsBST(r, v, max)\n', '  case Node(left, v, right) =>\n', '  case Node(left, value, right) =>\n', '  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n', '    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
13 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(13,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
13 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value) &&\n', '    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
14 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(14,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n', '    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

ex.dfy(13,27): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(tree: Tree, lo: nat, hi: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['predicate IsBST(tree: Tree, lo: nat, hi: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree, lower: nat, upper: nat): bool\n', 'function IsBST(tree: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true

   |
10 |     case Leaf => true
   |                      ^

ex.dfy(10,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min && v <= max &&

   |
12 |         v >= min && v <= max &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&

   |
12 |         v >= min &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min && v <= max &&\n', '        v >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&

   |
13 |         v <= max &&
   |                    ^

ex.dfy(13,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n', '        v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || (IsBST(left, min, v - 1) && v < max)) &&

   |
14 |         (left == Leaf || (IsBST(left, min, v - 1) && v < max)) &&
   |                                                                  ^

ex.dfy(14,65): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || (IsBST(left, min, v) && v < max)) &&

   |
14 |         (left == Leaf || (IsBST(left, min, v) && v < max)) &&
   |                                                              ^

ex.dfy(14,61): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        IsBST(left, min, v) &&

   |
14 |         IsBST(left, min, v) &&
   |                               ^

ex.dfy(14,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || IsBST(left, min, v - 1)) &&

   |
14 |         (left == Leaf || IsBST(left, min, v - 1)) &&
   |                                                     ^

ex.dfy(14,52): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&

   |
14 |         (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&
   |                                                                  ^

ex.dfy(14,65): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (left == Leaf || (IsBST(left, min, v - 1) && v < max)) &&\n', '        (left == Leaf || (IsBST(left, min, v) && v < max)) &&\n', '        IsBST(left, min, v) &&\n', '        (left == Leaf || IsBST(left, min, v - 1)) &&\n', '        (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&
        (right == Leaf || (IsBST(right, v + 1, max) && v < max))

   |
15 |         (right == Leaf || (IsBST(right, v + 1, max) && v < max))
   |                                                                 ^

ex.dfy(15,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        (right == Leaf || (IsBST(right, v + 1, max) && v < max))\n', '        (right == Leaf || (IsBST(right, v + 1, max) && v < max))\n', '        (right == Leaf || (IsBST(right, v + 1, max) && v < max))\n', '        (right == Leaf || (IsBST(right, v + 1, max) && v < max))\n', '        (right == Leaf || (IsBST(right, v + 1, max) && v < max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
{
    match t
    case Leaf => true
    case Node(left, v, right) =>
        v >= min &&
        v <= max &&
        (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&
        (right == Leaf || (IsBST(right, v + 1, max) && v < max))
}

ex.dfy(14,45): Error: value does not satisfy the subset constraints of 'nat'
   |
14 |         (left == Leaf || (IsBST(left, min, v - 1) && v > min)) &&
   |                                              ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads min, max
  |         ^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads min, max
  |              ^^^

ex.dfy(9,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  reads min, max\n', '{\n', '  reads min, max\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t

   |
11 |   match t
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true

   |
12 |   case Leaf => true
   |                    ^

ex.dfy(12,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true

   |
12 |     case Leaf => true
   |                      ^

ex.dfy(12,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>

   |
13 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(13,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(l, v, r) =>

   |
13 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(13,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, v, right) =>

   |
13 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(13,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(l, v, r) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&

   |
14 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(14,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      value >= min &&

   |
14 |       value >= min &&
   |                      ^

ex.dfy(14,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      min <= value && value <= max &&

   |
14 |       min <= value && value <= max &&
   |                                      ^

ex.dfy(14,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      value >= min && value <= max &&

   |
14 |       value >= min && value <= max &&
   |                                      ^

ex.dfy(14,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n', '      value >= min &&\n', '      min <= value && value <= max &&\n', '      value >= min && value <= max &&\n', '      value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      min <= value && value <= max &&

   |
15 |       min <= value && value <= max &&
   |                                      ^

ex.dfy(15,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      min <= value <= max &&

   |
15 |       min <= value <= max &&
   |                             ^

ex.dfy(15,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min && value <= max &&

   |
15 |       value >= min && value <= max &&
   |                                      ^

ex.dfy(15,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min &&

   |
15 |       value >= min &&
   |                      ^

ex.dfy(15,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      min <= value && value <= max &&\n', '      min <= value <= max &&\n', '      min <= value <= max &&\n', '      value >= min && value <= max &&\n', '      value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min &&
      value <= max &&

   |
16 |       value <= max &&
   |                      ^

ex.dfy(16,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min &&
      value < max &&

   |
16 |       value < max &&
   |                     ^

ex.dfy(16,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value <= max &&\n', '      value <= max &&\n', '      value <= max &&\n', '      value <= max &&\n', '      value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min &&
      value < max &&
      IsBST(right, value, max)

   |
17 |       IsBST(right, value, max)
   |                               ^

ex.dfy(17,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n', '      IsBST(right, value, max)\n', '      IsBST(right, value, max)\n', '      IsBST(right, value, max)\n', '      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
    case Leaf => true
    case Node(left, value, right) =>
      IsBST(left, min, value) &&
      value >= min &&
      value < max &&
      IsBST(right, value, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads min, max
  |         ^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads min, max
  |              ^^^

ex.dfy(9,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check whether a given tree is a BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a binary search tree

SCORE
1.0
['// (2) Write a predicate to check whether a given tree is a BST\n', '// (2) Define a predicate that checks whether a given tree is a binary search tree (BST)\n', '// (2) Define a predicate for BST\n', '// (2) Define a predicate IsBST for the tree\n', '// (2) Define a predicate to check if a tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {

  |
7 | function IsBST(t: Tree): bool {
  |                                ^

ex.dfy(7,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(tree: Tree, min: nat, max: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'function IsBST(t: Tree): bool {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t

  |
8 |     match t
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '  match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true

  |
9 |     case Leaf => true
  |                      ^

ex.dfy(9,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, v, right) =>

   |
10 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(10,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, v, right) =>\n', '    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&

   |
11 |         IsBST(left) &&
   |                       ^

ex.dfy(11,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left) &&\n', '        IsBST(left) &&\n', '        IsBST(left) &&\n', '        IsBST(left) &&\n', '        IsBST(left) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        (left == Leaf || max(left) < value) &&

   |
12 |         (left == Leaf || max(left) < value) &&
   |                                               ^

ex.dfy(12,46): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&

   |
12 |         IsBST(right) &&
   |                        ^

ex.dfy(12,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        (left == Leaf || GetMax(left) < value) &&

   |
12 |         (left == Leaf || GetMax(left) < value) &&
   |                                                  ^

ex.dfy(12,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        (left == Leaf || max(left) < value) &&\n', '        IsBST(right) &&\n', '        IsBST(right) &&\n', '        (left == Leaf || GetMax(left) < value) &&\n', '        IsBST(right) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (

   |
13 |         (
   |          ^

ex.dfy(13,9): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (left == Leaf || MaxValue(left) < value) &&

   |
13 |         (left == Leaf || MaxValue(left) < value) &&
   |                                                    ^

ex.dfy(13,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (left == Leaf || Select(left).value < value) &&

   |
13 |         (left == Leaf || Select(left).value < value) &&
   |                                                        ^

ex.dfy(13,55): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (forall x, y. x in left && y in right => x < value < y)

   |
13 |         (forall x, y. x in left && y in right => x < value < y)
   |                     ^

ex.dfy(13,20): Error: doublecolon expected
   |
13 |         (forall x, y. x in left && y in right => x < value < y)
   |                                                               ^

ex.dfy(13,62): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        forall v. v in left ==> v < value &&

   |
13 |         forall v. v in left ==> v < value &&
   |                 ^

ex.dfy(13,16): Error: doublecolon expected
1 parse errors detected in ex.dfy

SCORE
None
['        (\n', '        (left == Leaf || MaxValue(left) < value) &&\n', '        (left == Leaf || Select(left).value < value) &&\n', '        (forall x, y. x in left && y in right => x < value < y)\n', '        forall v. v in left ==> v < value &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
          (left == Leaf ==> value == 0) ||

   |
14 |           (left == Leaf ==> value == 0) ||
   |                                           ^

ex.dfy(14,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf || Node?left.value < value) &&

   |
14 |             (left == Leaf || Node?left.value < value) &&
   |                                                         ^

ex.dfy(14,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf || TreeMax(left) < value) &&

   |
14 |             (left == Leaf || TreeMax(left) < value) &&
   |                                                       ^

ex.dfy(14,54): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||

   |
14 |             (left == Leaf) ||
   |                              ^

ex.dfy(14,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf || left.value < value) &&

   |
14 |             (left == Leaf || left.value < value) &&
   |                                                    ^

ex.dfy(14,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['          (left == Leaf ==> value == 0) ||\n', '            (left == Leaf || Node?left.value < value) &&\n', '            (left == Leaf || TreeMax(left) < value) &&\n', '            (left == Leaf) ||\n', '            (left == Leaf || left.value < value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (MaxVal(left) < value)

   |
15 |             (MaxVal(left) < value)
   |                                   ^

ex.dfy(15,34): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (MaxValue(left) < value)

   |
15 |             (MaxValue(left) < value)
   |                                     ^

ex.dfy(15,36): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (forall x :: left.(Node(_, x, _)): value > x)

   |
15 |             (forall x :: left.(Node(_, x, _)): value > x)
   |                                    ^

ex.dfy(15,35): Error: gets expected
   |
15 |             (forall x :: left.(Node(_, x, _)): value > x)
   |                                              ^

ex.dfy(15,45): Error: closeparen expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value

   |
15 |             (left as Node).value < value
   |                                         ^

ex.dfy(15,40): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (match left

   |
15 |             (match left
   |                        ^

ex.dfy(15,23): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['            (MaxVal(left) < value)\n', '            (MaxValue(left) < value)\n', '            (forall x :: left.(Node(_, x, _)): value > x)\n', '            (left as Node).value < value\n', '            (match left\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&

   |
16 |         ) &&
   |             ^

ex.dfy(16,12): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        ) &&\n', '        ) &&\n', '        ) &&\n', '        ) &&\n', '        ) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (

   |
17 |         (
   |          ^

ex.dfy(17,9): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['        (\n', '        (\n', '        (\n', '        (\n', '        (\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (
            (right == Leaf) ||

   |
18 |             (right == Leaf) ||
   |                               ^

ex.dfy(18,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            (right == Leaf) ||\n', '            (right == Leaf) ||\n', '            (right == Leaf) ||\n', '            (right == Leaf) ||\n', '            (right == Leaf) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (
            (right == Leaf) ||
            value < (right as Node).value

   |
19 |             value < (right as Node).value
   |                                          ^

ex.dfy(19,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (
            (right == Leaf) ||
            (right as Node).value > value

   |
19 |             (right as Node).value > value
   |                                          ^

ex.dfy(19,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['            value < (right as Node).value\n', '            (right as Node).value > value\n', '            value < (right as Node).value\n', '            value < (right as Node).value\n', '            value < (right as Node).value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (
            (right == Leaf) ||
            (right as Node).value > value
        )

   |
20 |         )
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        )\n', '        )\n', '        )\n', '        )\n', '        )\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree): bool {
    match t
    case Leaf => true
    case Node(left, value, right) =>
        IsBST(left) &&
        IsBST(right) &&
        (
            (left == Leaf) ||
            (left as Node).value < value
        ) &&
        (
            (right == Leaf) ||
            (right as Node).value > value
        )
}

   |
15 |             (left as Node).value < value
   |                      ^^^^

ex.dfy(15,21): Error: Type or type parameter is not declared in this scope: Node (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
15 |             (left as Node).value < value
   |                            ^^^^^

ex.dfy(15,27): Error: type of the receiver is not fully determined at this program point
   |
19 |             (right as Node).value > value
   |                       ^^^^

ex.dfy(19,22): Error: Type or type parameter is not declared in this scope: Node (did you forget to qualify a name or declare a module import 'opened'?) (note that names in outer modules are not visible in contained modules)
   |
19 |             (right as Node).value > value
   |                             ^^^^^

ex.dfy(19,28): Error: type of the receiver is not fully determined at this program point
4 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(tree: Tree, lower: nat, upper: nat)\n', 'predicate IsBST(t: Tree, min: nat, max: nat)\n', 'function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree

  |
9 |     match tree
  |               ^

ex.dfy(9,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n', '  match tree\n', '    match tree\n', '  match tree\n', '    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true

   |
10 |     case Leaf => true
   |                      ^

ex.dfy(10,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value > lower && value < upper &&

   |
12 |         value > lower && value < upper &&
   |                                          ^

ex.dfy(12,41): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&

   |
12 |         value <= upper && value >= lower &&
   |                                            ^

ex.dfy(12,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value >= lower && value <= upper &&

   |
12 |         value >= lower && value <= upper &&
   |                                            ^

ex.dfy(12,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        lower <= value && value < upper &&

   |
12 |         lower <= value && value < upper &&
   |                                           ^

ex.dfy(12,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        value > lower && value < upper &&\n', '        value <= upper && value >= lower &&\n', '        value >= lower && value <= upper &&\n', '        value > lower && value < upper &&\n', '        lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        IsBST(left, lower, value - 1) &&

   |
13 |         IsBST(left, lower, value - 1) &&
   |                                         ^

ex.dfy(13,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        IsBST(left, lower, value) &&

   |
13 |         IsBST(left, lower, value) &&
   |                                     ^

ex.dfy(13,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        (forall v. In(v, left) ==> v < value) &&

   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                  ^

ex.dfy(13,17): Error: doublecolon expected
   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                                             ^

ex.dfy(13,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        IsBST(left, lower, value - 1) &&\n', '        IsBST(left, lower, value) &&\n', '        (forall v. In(v, left) ==> v < value) &&\n', '        IsBST(left, lower, value) &&\n', '        IsBST(left, lower, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        (forall v. In(v, left) ==> v < value) &&
        (forall v. In(v, right) ==> v > value) &&

   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                  ^

ex.dfy(13,17): Error: doublecolon expected
   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                                             ^

ex.dfy(13,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        (forall v. In(v, right) ==> v > value) &&\n', '        (forall v. In(v, right) ==> v > value) &&\n', '        (forall v. In(v, right) ==> v > value) &&\n', '        (forall v. In(v, right) ==> v > value) &&\n', '        (forall v. In(v, right) ==> v > value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        (forall v. In(v, left) ==> v < value) &&
        (forall v. In(v, right) ==> v > value) &&
        IsBST(left, lower, value) &&

   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                  ^

ex.dfy(13,17): Error: doublecolon expected
   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                                             ^

ex.dfy(13,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST for the tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
    match tree
    case Leaf => true
    case Node(left, value, right) =>
        value <= upper && value >= lower &&
        (forall v. In(v, left) ==> v < value) &&
        (forall v. In(v, right) ==> v > value) &&
        IsBST(left, lower, value - 1) &&

   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                  ^

ex.dfy(13,17): Error: doublecolon expected
   |
13 |         (forall v. In(v, left) ==> v < value) &&
   |                                             ^

ex.dfy(13,44): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['        IsBST(left, lower, value) &&\n', '        IsBST(left, lower, value - 1) &&\n', '        IsBST(left, lower, value - 1) &&\n', '        IsBST(left, lower, value) &&\n', '        IsBST(left, lower, value - 1) &&\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n', '  match t\n', '  match t\n', '  match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true

   |
10 |     case Leaf => true
   |                      ^

ex.dfy(10,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n', '    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)

   |
11 |     case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
   |                                                                                                     ^

ex.dfy(11,100): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) =>

   |
11 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)\n', '    case Node(left, v, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n', '    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define Insert function

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert that inserts an element into a binary search tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define an insert function

SCORE
1.0
['// (3) Define Insert function\n', '// (3) Define a function Insert that inserts an element into a binary search tree\n', '// (3) Define a function Insert\n', '// (3) Define an insert function\n', '// (3) Define a function Insert that inserts an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, x: nat): Tree

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, x: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n', 'function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then

   |
17 |     if t == Leaf then
   |                      ^

ex.dfy(17,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    match t

   |
17 |     match t
   |            ^

ex.dfy(17,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)

   |
17 |     if t == Leaf then Node(Leaf, v, Leaf)
   |                                          ^

ex.dfy(17,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf then\n', '    match t\n', '    if t == Leaf then Node(Leaf, v, Leaf)\n', '    if t == Leaf then Node(Leaf, v, Leaf)\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else

   |
18 |     else
   |         ^

ex.dfy(18,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else\n', '    else\n', '    else\n', '    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t

   |
19 |         match t
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match t\n', '        match t\n', '        match t\n', '        match t\n', '        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>

   |
20 |         case Node(left, w, right) =>
   |                                     ^

ex.dfy(20,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, value, right) =>

   |
20 |         case Node(left, value, right) =>
   |                                         ^

ex.dfy(20,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n', '        case Node(left, value, right) =>\n', '        case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)

   |
21 |             if v < w then Node(Insert(left, v), w, right)
   |                                                          ^

ex.dfy(21,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            if v < w then Node(Insert(left, v), w, right)\n', '            if v < w then Node(Insert(left, v), w, right)\n', '            if v < w then Node(Insert(left, v), w, right)\n', '            if v < w then Node(Insert(left, v), w, right)\n', '            if v < w then Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))

   |
22 |             else if v > w then Node(left, w, Insert(right, v))
   |                                                               ^

ex.dfy(22,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            else if v > w then Node(left, w, Insert(right, v))\n', '            else if v > w then Node(left, w, Insert(right, v))\n', '            else if v > w then Node(left, w, Insert(right, v))\n', '            else if v > w then Node(left, w, Insert(right, v))\n', '            else if v > w then Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t

   |
23 |             else t
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else t\n', '            else t\n', '            else t\n', '            else t\n', '            else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains

SCORE
1.0
['// (4) Define a predicate Contains\n', '// (4) Define a predicate Contains\n', '// (4) Define a predicate Contains\n', '// (4) Define a predicate Contains\n', '// (4) Define a predicate Contains\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool

SCORE
1.0
['function Contains(t: Tree, v: nat): bool\n', 'function Contains(t: Tree, v: nat): bool\n', 'function Contains(t: Tree, v: nat): bool\n', 'function Contains(t: Tree, v: nat): bool\n', 'function Contains(t: Tree, v: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t

   |
29 |     match t
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '    match t\n', '    match t\n', '    match t\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false

   |
30 |     case Leaf => false
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => false\n', '    case Leaf => false\n', '    case Leaf => false\n', '    case Leaf => false\n', '    case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>

   |
31 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(31,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) => v == w || Contains(left, v) || Contains(right, v)

   |
31 |     case Node(left, w, right) => v == w || Contains(left, v) || Contains(right, v)
   |                                                                                   ^

ex.dfy(31,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) => v == w || Contains(left, v) || Contains(right, v)\n', '    case Node(left, w, right) =>\n', '    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v < w then Contains(left, v)

   |
32 |         if v < w then Contains(left, v)
   |                                        ^

ex.dfy(32,39): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true

   |
32 |         if v == w then true
   |                            ^

ex.dfy(32,27): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        if v < w then Contains(left, v)\n', '        if v == w then true\n', '        if v < w then Contains(left, v)\n', '        if v < w then Contains(left, v)\n', '        if v < w then Contains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)

   |
33 |         else if v < w then Contains(left, v)
   |                                             ^

ex.dfy(33,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        else if v < w then Contains(left, v)\n', '        else if v < w then Contains(left, v)\n', '        else if v < w then Contains(left, v)\n', '        else if v < w then Contains(left, v)\n', '        else if v < w then Contains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)

   |
34 |         else Contains(right, v)
   |                                ^

ex.dfy(34,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        else Contains(right, v)\n', '        else Contains(right, v)\n', '        else Contains(right, v)\n', '        else Contains(right, v)\n', '        else Contains(right, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Define a lemma InsertPreservesContains

SCORE
1.0
['// (5) Lemma about Insert\n', '// (5) Lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element\n', '// (5) Define a lemma InsertPreservesContains\n', '// (5) Define a lemma InsertPreservesContains\n', '// (5) Define a lemma InsertPreservesContains\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat, w: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma {:verify false} InsertPreservesContains(t: Tree, v: nat)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertPreservesContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, v: nat)\n', 'lemma InsertEnsuresContains(t: Tree, v: nat, w: nat)\n', 'lemma {:verify false} InsertPreservesContains(t: Tree, v: nat)\n', 'lemma InsertPreservesContains(t: Tree, v: nat)\n', 'lemma InsertEnsuresContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires Contains(t, v) == false

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v) = true

   |
39 |     ensures Contains(Insert(t, v), v) = true
   |                                       ^

ex.dfy(39,38): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v) = true

   |
39 |   ensures Contains(Insert(t, v), v) = true
   |                                     ^

ex.dfy(39,36): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['requires IsBST(t, 0, 100)\n', '    ensures Contains(Insert(t, v), v)\n', 'requires Contains(t, v) == false\n', '    ensures Contains(Insert(t, v), v) = true\n', '  ensures Contains(Insert(t, v), v) = true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t

   |
41 |     // proof by structural induction on t
   |                                          ^

ex.dfy(41,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Proof by structural induction on t

   |
41 |     // Proof by structural induction on t
   |                                          ^

ex.dfy(41,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:

   |
41 |     // Base cases:
   |                   ^

ex.dfy(41,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // prove by structural induction on t

   |
41 |     // prove by structural induction on t
   |                                          ^

ex.dfy(41,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
}

SCORE
1.0
['    // proof by structural induction on t\n', '    // Proof by structural induction on t\n', '    // Base cases:\n', '    // prove by structural induction on t\n', '}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf then

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf {

   |
42 |     if t == Leaf {
   |                   ^

ex.dfy(42,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf then\n', '    if t == Leaf then\n', '    if t == Leaf then\n', '    if t == Leaf then\n', '    if t == Leaf {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf then
        assert Contains(Node(Leaf, v, Leaf), v);

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf then
        assert Insert(t, v) == Node(Leaf, v, Leaf);

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        assert Contains(Node(Leaf, v, Leaf), v);\n', '        assert Insert(t, v) == Node(Leaf, v, Leaf);\n', '        assert Insert(t, v) == Node(Leaf, v, Leaf);\n', '        assert Insert(t, v) == Node(Leaf, v, Leaf);\n', '        assert Contains(Node(Leaf, v, Leaf), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf then
        assert Insert(t, v) == Node(Leaf, v, Leaf);
        assert Contains(Insert(t, v), v) == true;

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base cases:
    if t == Leaf then
        assert Insert(t, v) == Node(Leaf, v, Leaf);
        assert Contains(Insert(t, v), v);

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        assert Contains(Insert(t, v), v) == true;\n', '        assert Contains(Insert(t, v), v) == true;\n', '        assert Contains(Insert(t, v), v) == true;\n', '        assert Contains(Insert(t, v), v);\n', '        assert Contains(Insert(t, v), v) == true;\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Base case

   |
41 |     // Base case
   |                 ^

ex.dfy(41,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // ... prove this lemma ...

   |
41 |     // ... prove this lemma ...
   |                                ^

ex.dfy(41,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // Proof by structural recursion on t

   |
41 |     // Proof by structural recursion on t
   |                                          ^

ex.dfy(41,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case\n', '    // proof by structural induction on t\n', '    // Proof by structural induction on t\n', '    // ... prove this lemma ...\n', '    // Proof by structural recursion on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    match t

   |
42 |     match t
   |            ^

ex.dfy(42,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
}

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf then

   |
42 |     if t == Leaf then
   |                  ^

ex.dfy(42,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf

   |
42 |     if t == Leaf
   |                 ^

ex.dfy(42,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n', '}\n', '    if t == Leaf then\n', '    if t == Leaf\n', '    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)

   |
43 |         // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
   |                                                                             ^

ex.dfy(43,76): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
    {

   |
43 |     {
   |      ^

ex.dfy(43,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)\n', '    {\n', '    {\n', '    {\n', '    {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in Contains(Node(Leaf, v, Leaf), v)

   |
44 |         // and v is in Contains(Node(Leaf, v, Leaf), v)
   |                                                        ^

ex.dfy(44,55): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in this new tree

   |
44 |         // and v is in this new tree
   |                                     ^

ex.dfy(44,36): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree

   |
44 |         // and v is in the new tree
   |                                    ^

ex.dfy(44,35): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // since v is in this new tree

   |
44 |         // since v is in this new tree
   |                                       ^

ex.dfy(44,38): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        assert Contains(Node(Leaf, v, Leaf), v);

   |
44 |         assert Contains(Node(Leaf, v, Leaf), v);
   |         ^

ex.dfy(44,8): Error: lbrace expected
   |
44 |         assert Contains(Node(Leaf, v, Leaf), v);
   |                                                 ^

ex.dfy(44,48): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        // and v is in Contains(Node(Leaf, v, Leaf), v)\n', '        // and v is in this new tree\n', '        // and v is in the new tree\n', '        // since v is in this new tree\n', '        assert Contains(Node(Leaf, v, Leaf), v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree
    else

   |
45 |     else
   |     ^

ex.dfy(45,4): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else\n', '    else\n', '    else\n', '    else\n', '    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree
    else
        match t

   |
45 |     else
   |     ^

ex.dfy(45,4): Error: lbrace expected
   |
46 |         match t
   |                ^

ex.dfy(46,15): Error: invalid MatchStmt
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree
    else
        // recursive case: consider the recursive calls

   |
45 |     else
   |     ^

ex.dfy(45,4): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree
    else
        // recursive case: by definition of Insert, either v < w or v > w or v == w

   |
45 |     else
   |     ^

ex.dfy(45,4): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        match t\n', '        match t\n', '        // recursive case: consider the recursive calls\n', '        // recursive case: by definition of Insert, either v < w or v > w or v == w\n', '        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
    ensures Contains(Insert(t, v), v)
{
    // proof by structural induction on t
    if t == Leaf
        // base case: if t is Leaf, then Insert(t, v) is Node(Leaf, v, Leaf)
        // and v is in the new tree
    else
        // recursive case: consider the recursive calls
        match t

   |
45 |     else
   |     ^

ex.dfy(45,4): Error: lbrace expected
   |
47 |         match t
   |                ^

ex.dfy(47,15): Error: invalid MatchStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['        match t\n', '        match t\n', '        match t\n', '        match t\n', '        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, nat.MaxInt)

   |
39 | requires IsBST(t, 0, nat.MaxInt)
   |                      ^

ex.dfy(39,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true

SCORE
1.0
['requires IsBST(t, 0, 100)\n', '  ensures Contains(Insert(t, v), v)\n', '    ensures Contains(Insert(t, v), v)\n', 'requires IsBST(t, 0, nat.MaxInt)\n', 'requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)

SCORE
1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)

SCORE
1.0
['ensures Contains(Insert(t, v), v)\n', 'ensures Contains(Insert(t, v), v)\n', 'ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)\n', 'ensures Contains(Insert(t, v), v)\n', 'ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // Proof by induction on t

   |
42 |     // Proof by induction on t
   |                               ^

ex.dfy(42,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // ... proof ...

   |
42 |     // ... proof ...
   |                     ^

ex.dfy(42,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base case: if t is Leaf

   |
42 |     // base case: if t is Leaf
   |                               ^

ex.dfy(42,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // Proof by structural induction on t

   |
42 |     // Proof by structural induction on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // Proof here...

   |
42 |     // Proof here...
   |                     ^

ex.dfy(42,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Proof by induction on t\n', '    // ... proof ...\n', '    // base case: if t is Leaf\n', '    // Proof by structural induction on t\n', '    // Proof here...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // Proof here...
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,45): Related location
   |
11 |     case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
   |                                              ^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,39): Related location: this is the postcondition that could not be proved
   |
40 | ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,80): Related location
   |
11 |     case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
   |                                                                                 ^^^^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,39): Related location: this is the postcondition that could not be proved
   |
40 | ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,57): Related location
   |
11 |     case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
   |                                                          ^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases

   |
42 |     // base cases
   |                  ^

ex.dfy(42,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    if t == Leaf

   |
42 |     if t == Leaf
   |                 ^

ex.dfy(42,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // Proof omitted

   |
42 |     // Proof omitted
   |                     ^

ex.dfy(42,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // base cases\n', '    // Proof by structural induction on t\n', '    if t == Leaf\n', '    // Proof by induction on t\n', '    // Proof omitted\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {

   |
43 |     if t == Leaf {
   |                   ^

ex.dfy(43,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf then

   |
43 |     if t == Leaf then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if t == Leaf {\n', '    if t == Leaf {\n', '    if t == Leaf {\n', '    if t == Leaf then\n', '    if t == Leaf then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
    } else

   |
44 |     } else
   |           ^

ex.dfy(44,10): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
    } else if v < t.value {

   |
44 |     } else if v < t.value {
   |                            ^

ex.dfy(44,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        assert Insert(t, v) == Node(Leaf, v, Leaf);

   |
44 |         assert Insert(t, v) == Node(Leaf, v, Leaf);
   |                                                    ^

ex.dfy(44,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove

   |
44 |         // nothing to prove
   |                            ^

ex.dfy(44,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else\n', '    } else if v < t.value {\n', '    } else if v < t.value {\n', '        assert Insert(t, v) == Node(Leaf, v, Leaf);\n', '        // nothing to prove\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else

   |
45 |     } else
   |           ^

ex.dfy(45,10): Error: invalid IfStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {

   |
45 |     } else {
   |             ^

ex.dfy(45,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else\n', '    } else {\n', '    } else {\n', '    } else\n', '    } else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive cases

   |
46 |         // recursive cases
   |                           ^

ex.dfy(46,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls

   |
46 |         // recursive calls
   |                           ^

ex.dfy(46,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        match t

   |
46 |         match t
   |                ^

ex.dfy(46,15): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['        // recursive cases\n', '        // recursive calls\n', '        match t\n', '        match t\n', '        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t

   |
47 |         match t
   |                ^

ex.dfy(47,15): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['        match t\n', '        match t\n', '        match t\n', '        match t\n', '        match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>

   |
48 |         case Node(left, w, right) =>
   |                                     ^

ex.dfy(48,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n', '        case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>
            if v < w {

   |
49 |             if v < w {
   |                       ^

ex.dfy(49,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            if v < w {\n', '            if v < w {\n', '            if v < w {\n', '            if v < w {\n', '            if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>
            if v < w {
                InsertEnsuresContains(left, v)

   |
50 |                 InsertEnsuresContains(left, v)
   |                                               ^

ex.dfy(50,46): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>
            if v < w {
                InsertEnsuresContains(left, v);

   |
50 |                 InsertEnsuresContains(left, v);
   |                                                ^

ex.dfy(50,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                InsertEnsuresContains(left, v)\n', '                InsertEnsuresContains(left, v)\n', '                InsertEnsuresContains(left, v)\n', '                InsertEnsuresContains(left, v)\n', '                InsertEnsuresContains(left, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>
            if v < w {
                InsertEnsuresContains(left, v)
            } else if v > w {

   |
50 |                 InsertEnsuresContains(left, v)
   |                 ^^^^^^^^^^^^^^^^^^^^^

ex.dfy(50,16): Error: missing semicolon at end of statement
   |
51 |             } else if v > w {
   |                              ^

ex.dfy(51,29): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['            } else if v > w {\n', '            } else if v > w {\n', '            } else if v > w {\n', '            } else if v > w {\n', '            } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)
{
    // base cases
    if t == Leaf {
        // nothing to prove
    } else {
        // recursive calls
        match t
        case Node(left, w, right) =>
            if v < w {
                InsertEnsuresContains(left, v)
            } else if v > w {
                InsertEnsuresContains(right, v)

   |
50 |                 InsertEnsuresContains(left, v)
   |                 ^^^^^^^^^^^^^^^^^^^^^

ex.dfy(50,16): Error: missing semicolon at end of statement
   |
52 |                 InsertEnsuresContains(right, v)
   |                                                ^

ex.dfy(52,47): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['                InsertEnsuresContains(right, v)\n', '                InsertEnsuresContains(right, v)\n', '                InsertEnsuresContains(right, v)\n', '                InsertEnsuresContains(right, v)\n', '                InsertEnsuresContains(right, v)\n']
['ensures Contains(Insert(t, v), v)\n', 'ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)\n', 'ensures Contains(Insert(t, v), v)\n', 'ensures IsBST(Insert(t, v), 0, 100) && Contains(Insert(t, v), v)\n', 'ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
    // prove this lemma using the structure of Insert and Contains, and recursively calling the lemma

   |
42 |     // prove this lemma using the structure of Insert and Contains, and recursively calling the lemma
   |                                                                                                      ^

ex.dfy(42,101): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
    // proof goes here

   |
42 |     // proof goes here
   |                       ^

ex.dfy(42,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
    // Proof by induction on the structure of t

   |
42 |     // Proof by induction on the structure of t
   |                                                ^

ex.dfy(42,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
    // Proof by structural induction on t

   |
42 |     // Proof by structural induction on t
   |                                          ^

ex.dfy(42,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '    // prove this lemma using the structure of Insert and Contains, and recursively calling the lemma\n', '    // proof goes here\n', '    // Proof by induction on the structure of t\n', '    // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}


ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the BST property holding after Insert

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about Insert preserving BST

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about Insert maintaining BST property

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
    Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate IsBST
function IsBST(t: Tree, min: nat, max: nat): bool
{
    match t
    case Leaf => true
    case Node(left, v, right) => v >= min && v <= max && IsBST(left, min, v) && IsBST(right, v, max)
}

// (3) Define a function Insert
function Insert(t: Tree, v: nat): Tree
{
    if t == Leaf then Node(Leaf, v, Leaf)
    else
        match t
        case Node(left, w, right) =>
            if v < w then Node(Insert(left, v), w, right)
            else if v > w then Node(left, w, Insert(right, v))
            else t
}

// (4) Define a predicate Contains
function Contains(t: Tree, v: nat): bool
{
    match t
    case Leaf => false
    case Node(left, w, right) =>
        if v == w then true
        else if v < w then Contains(left, v)
        else Contains(right, v)
}

// (5) Lemma about Insert
lemma InsertEnsuresContains(t: Tree, v: nat)
requires IsBST(t, 0, 100)
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about IsBST after Insert

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,27): Related location
   |
33 |         else if v < w then Contains(left, v)
   |                            ^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, v), v)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(34,13): Related location
   |
34 |         else Contains(right, v)
   |              ^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['// (6) Lemma about the BST property holding after Insert\n', '// (6) Lemma about Insert preserving BST\n', '// (6) Lemma about Insert maintaining BST property\n', '// (6) Lemma about IsBST after Insert\n', '// (6) Lemma about Insert maintaining BST property\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 5)
number of back nodes: 25 (including leaves: 21)

expansion count: 36 (including failed: 11)

cache stats {'hit': 430, 'miss': 270}
calls to generate 140
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 729, 749, 720, 810, 619, 721, 712, 726, 747]

Trial calls: [165, 600, 570, 645, 660, 500, 755, 680, 750, 700]


Time Statistics:

  Min: 236.00 sec, Max: 810.00 sec, Average: 676.90 sec, Standard Deviation: 153.54 sec

Call Statistics:

  Min: 165 calls, Max: 755 calls, Average: 602.50 calls, Standard Deviation: 163.89 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [729, 749, 720, 810, 721, 726, 747]

Trial calls: [600, 570, 645, 660, 755, 750, 700]


Time Statistics:

  Min: 720.00 sec, Max: 810.00 sec, Average: 743.14 sec, Standard Deviation: 29.37 sec

Call Statistics:

  Min: 570 calls, Max: 755 calls, Average: 668.57 calls, Standard Deviation: 65.61 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [236, 619, 712]

Trial calls: [165, 500, 680]


Time Statistics:

  Min: 236.00 sec, Max: 712.00 sec, Average: 522.33 sec, Standard Deviation: 206.00 sec

Call Statistics:

  Min: 165 calls, Max: 680 calls, Average: 448.33 calls, Standard Deviation: 213.40 calls

To complete all experiments, 113 minutes and 31 seconds elapsed.


