TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:


SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)


SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(i) => i

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(i) => i
    case Var(x) => env(x)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(i) => i
    case Var(x) => env(x)
    case Add(l, r) => Eval(l, env) + Eval(r, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: string -> int): int
{
    match e
    case Const(i) => i
    case Var(x) => env(x)
    case Add(l, r) => Eval(l, env) + Eval(r, env)
}

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function method Eval(e: Expr, env: function (string) returns (int)): int
{

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)


SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}


SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}


SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
 
SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
    OptimizerPreservesSemantics(l, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
    OptimizerPreservesSemantics(l, env);
    OptimizerPreservesSemantics(r, env);

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
    OptimizerPreservesSemantics(l, env);
    OptimizerPreservesSemantics(r, env);
}

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
    OptimizerPreservesSemantics(l, env);
    OptimizerPreservesSemantics(r, env);
}
```

SCORE
1.0
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returns the number resulting from evaluation. Then write an optimizer tha takes an expression and returns an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.
### Dafny:

```dafny
datatype Expr = Const(i: int)
             | Var(x: string)
             | Add(l: Expr, r: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e
  case Const(i) => i
  case Var(x) => env(x)
  case Add(l, r) => Eval(l, env) + Eval(r, env)
}

function Optimize(e: Expr): Expr {
  match e
  case Add(Const(0), r) => Optimize(r)
  case Add(l, Const(0)) => Optimize(l)
  case Add(l, r) => Add(Optimize(l), Optimize(r))
  case _ => e
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e
  case Const(i) => 
  case Var(x) => 
  case Add(l, r) => 
    OptimizerPreservesSemantics(l, env);
    OptimizerPreservesSemantics(r, env);
}
```

